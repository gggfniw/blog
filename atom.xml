<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王志兴的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangzx.org/"/>
  <updated>2018-05-18T08:23:00.091Z</updated>
  <id>http://wangzx.org/</id>
  
  <author>
    <name>王志兴</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《dubbo源码深度解析》之serialize 数据序列化层</title>
    <link href="http://wangzx.org/2018/05/18/dubbo-serialize%20/"/>
    <id>http://wangzx.org/2018/05/18/dubbo-serialize /</id>
    <published>2018-05-18T07:54:42.000Z</published>
    <updated>2018-05-18T08:23:00.091Z</updated>
    
    <content type="html"><![CDATA[<p>serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</p><p><strong><a id="more"></a></strong></p><h1 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@SPI(&quot;hessian2&quot;)</span><br><span class="line">public interface Serialization &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get content type id</span><br><span class="line">     *</span><br><span class="line">     * @return content type id</span><br><span class="line">     */</span><br><span class="line">    byte getContentTypeId();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get content type</span><br><span class="line">     *</span><br><span class="line">     * @return content type</span><br><span class="line">     */</span><br><span class="line">    String getContentType();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * create serializer</span><br><span class="line">     *</span><br><span class="line">     * @param url</span><br><span class="line">     * @param output</span><br><span class="line">     * @return serializer</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Adaptive</span><br><span class="line">    ObjectOutput serialize(URL url, OutputStream output) throws IOException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * create deserializer</span><br><span class="line">     *</span><br><span class="line">     * @param url</span><br><span class="line">     * @param input</span><br><span class="line">     * @return deserializer</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Adaptive</span><br><span class="line">    ObjectInput deserialize(URL url, InputStream input) throws IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Serialization即序列号接口，其中最重要的两个方法是serialize和deserialize，分别是序列化和反序列化，这两个方法会在netty服务端返回方法执行结果和netty客户端接收返回结果的时候调用，先来看下实现类有多少：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CompactedJavaSerialization (com.alibaba.dubbo.common.serialize.support.java) </span><br><span class="line">DubboSerialization (com.alibaba.dubbo.common.serialize.support.dubbo) </span><br><span class="line">FastJsonSerialization (com.alibaba.dubbo.common.serialize.support.json) </span><br><span class="line">Hessian2Serialization (com.alibaba.dubbo.common.serialize.support.hessian) </span><br><span class="line">JavaSerialization (com.alibaba.dubbo.common.serialize.support.java) </span><br><span class="line">JsonSerialization (com.alibaba.dubbo.common.serialize.support.json) </span><br><span class="line">NativeJavaSerialization (com.alibaba.dubbo.common.serialize.support.nativejava)</span><br></pre></td></tr></table></figure></p><p>共有7个序列化的实现类，通常这里也是个面试题，会问dubbo有几种序列化的方法，通过SPI注解可以得知，默认的序列化方法是Hessian2Serialization：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Hessian2Serialization implements Serialization &#123;</span><br><span class="line"></span><br><span class="line">    public static final byte ID = 2;</span><br><span class="line"></span><br><span class="line">    public byte getContentTypeId() &#123;</span><br><span class="line">        return ID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContentType() &#123;</span><br><span class="line">        return &quot;x-application/hessian2&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ObjectOutput serialize(URL url, OutputStream out) throws IOException &#123;</span><br><span class="line">        return new Hessian2ObjectOutput(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ObjectInput deserialize(URL url, InputStream is) throws IOException &#123;</span><br><span class="line">        return new Hessian2ObjectInput(is);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察到这个类有个ID属性：public static final byte ID = 2;再观察其他的实现类，发现每个类都有不同的ID，其实这个是dubbo服务端与客户端约定的序列化方法的编号，这个编号会存放在请求的header中，当客户端需要反序列化时，需要从header中取到这个ID，从而知道服务端是使用了哪种序列化的方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>《dubbo源码深度解析》之transport 网络传输层</title>
    <link href="http://wangzx.org/2018/05/15/dubbo-transport/"/>
    <id>http://wangzx.org/2018/05/15/dubbo-transport/</id>
    <published>2018-05-15T13:55:42.000Z</published>
    <updated>2018-05-18T08:21:51.941Z</updated>
    
    <content type="html"><![CDATA[<p>transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</p><p><strong><a id="more"></a></strong></p><h1 id="Transporter"><a href="#Transporter" class="headerlink" title="Transporter"></a>Transporter</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@SPI(&quot;netty&quot;)</span><br><span class="line">public interface Transporter &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Bind a server.</span><br><span class="line">     *</span><br><span class="line">     * @param url     server url</span><br><span class="line">     * @param handler</span><br><span class="line">     * @return server</span><br><span class="line">     * @throws RemotingException</span><br><span class="line">     * @see com.alibaba.dubbo.remoting.Transporters#bind(URL, Receiver, ChannelHandler)</span><br><span class="line">     */</span><br><span class="line">    @Adaptive(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    Server bind(URL url, ChannelHandler handler) throws RemotingException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Connect to a server.</span><br><span class="line">     *</span><br><span class="line">     * @param url     server url</span><br><span class="line">     * @param handler</span><br><span class="line">     * @return client</span><br><span class="line">     * @throws RemotingException</span><br><span class="line">     * @see com.alibaba.dubbo.remoting.Transporters#connect(URL, Receiver, ChannelListener)</span><br><span class="line">     */</span><br><span class="line">    @Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    Client connect(URL url, ChannelHandler handler) throws RemotingException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口和Exchange非常像，甚至连接口和接口里面的参数都差不多，其实Exchange本身就是对Transporter进一步的封装，真正干活的，是这个Transporter，我们来看下这个接口的实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GrizzlyTransporter (com.alibaba.dubbo.remoting.transport.grizzly) </span><br><span class="line">MinaTransporter (com.alibaba.dubbo.remoting.transport.mina) </span><br><span class="line">NettyTransporter (com.alibaba.dubbo.remoting.transport.netty)</span><br></pre></td></tr></table></figure></p><p>可以看到dubbo底层支持Grizzly、Mina、Netty作为网络传输层，默认使用的是netty，我们来看下NettyTransporter的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class NettyTransporter implements Transporter &#123;</span><br><span class="line"></span><br><span class="line">    public static final String NAME = &quot;netty&quot;;</span><br><span class="line"></span><br><span class="line">    public Server bind(URL url, ChannelHandler listener) throws RemotingException &#123;</span><br><span class="line">        return new NettyServer(url, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Client connect(URL url, ChannelHandler listener) throws RemotingException &#123;</span><br><span class="line">        return new NettyClient(url, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>先来看bind方法，返回的是一个NettyServer，在这个类中有个非常眼熟的方法：doOpen：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void doOpen() throws Throwable &#123;</span><br><span class="line">    NettyHelper.setNettyLoggerFactory();</span><br><span class="line">    ExecutorService boss = Executors.newCachedThreadPool(new NamedThreadFactory(&quot;NettyServerBoss&quot;, true));</span><br><span class="line">    ExecutorService worker = Executors.newCachedThreadPool(new NamedThreadFactory(&quot;NettyServerWorker&quot;, true));</span><br><span class="line">    ChannelFactory channelFactory = new NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">    bootstrap = new ServerBootstrap(channelFactory);</span><br><span class="line"></span><br><span class="line">    final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);</span><br><span class="line">    channels = nettyHandler.getChannels();</span><br><span class="line">    // https://issues.jboss.org/browse/NETTY-365</span><br><span class="line">    // https://issues.jboss.org/browse/NETTY-379</span><br><span class="line">    // final Timer timer = new HashedWheelTimer(new NamedThreadFactory(&quot;NettyIdleTimer&quot;, true));</span><br><span class="line">    bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;</span><br><span class="line">        public ChannelPipeline getPipeline() &#123;</span><br><span class="line">            NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);</span><br><span class="line">            ChannelPipeline pipeline = Channels.pipeline();</span><br><span class="line">            /*int idleTimeout = getIdleTimeout();</span><br><span class="line">            if (idleTimeout &gt; 10000) &#123;</span><br><span class="line">                pipeline.addLast(&quot;timer&quot;, new IdleStateHandler(timer, idleTimeout / 1000, 0, 0));</span><br><span class="line">            &#125;*/</span><br><span class="line">            pipeline.addLast(&quot;decoder&quot;, adapter.getDecoder());</span><br><span class="line">            pipeline.addLast(&quot;encoder&quot;, adapter.getEncoder());</span><br><span class="line">            pipeline.addLast(&quot;handler&quot;, nettyHandler);</span><br><span class="line">            return pipeline;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // bind</span><br><span class="line">    channel = bootstrap.bind(getBindAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这里几乎都是netty的代码，我们先来看下duOpen方法在什么时候被调用，再来看doOpen方法中的几个关键的对象，可以看到NettyServer继承了AbstractServer，在这个父类的构造方法中，调用了doOpen方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public AbstractServer(URL url, ChannelHandler handler) throws RemotingException &#123;</span><br><span class="line">    super(url, handler);</span><br><span class="line">    localAddress = getUrl().toInetSocketAddress();</span><br><span class="line">    String host = url.getParameter(Constants.ANYHOST_KEY, false)</span><br><span class="line">            || NetUtils.isInvalidLocalHost(getUrl().getHost())</span><br><span class="line">            ? NetUtils.ANYHOST : getUrl().getHost();</span><br><span class="line">    bindAddress = new InetSocketAddress(host, getUrl().getPort());</span><br><span class="line">    this.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);</span><br><span class="line">    this.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);</span><br><span class="line">    try &#123;</span><br><span class="line">        doOpen();</span><br><span class="line">        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(&quot;Start &quot; + getClass().getSimpleName() + &quot; bind &quot; + getBindAddress() + &quot;, export &quot; + getLocalAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        throw new RemotingException(url.toInetSocketAddress(), null, &quot;Failed to bind &quot; + getClass().getSimpleName()</span><br><span class="line">                + &quot; on &quot; + getLocalAddress() + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">    //fixme replace this with better method</span><br><span class="line">    DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();</span><br><span class="line">    executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在再来看doOpen方法中的几个关键对象，第一个就是nettyHandler这个对象，可以看到这个对象是通过new NettyHandler(getUrl(), this)产生的，来看下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class NettyHandler extends SimpleChannelHandler &#123;</span><br><span class="line"></span><br><span class="line">    private final Map&lt;String, Channel&gt; channels = new ConcurrentHashMap&lt;String, Channel&gt;(); // &lt;ip:port, channel&gt;</span><br><span class="line"></span><br><span class="line">    private final URL url;</span><br><span class="line"></span><br><span class="line">    private final ChannelHandler handler;</span><br><span class="line"></span><br><span class="line">    public NettyHandler(URL url, ChannelHandler handler) &#123;</span><br><span class="line">        if (url == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;url == null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (handler == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;handler == null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.url = url;</span><br><span class="line">        this.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //省略部分方法</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span><br><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler);</span><br><span class="line">        try &#123;</span><br><span class="line">            handler.received(channel, e.getMessage());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            NettyChannel.removeChannelIfDisconnected(ctx.getChannel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeRequested(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;</span><br><span class="line">        super.writeRequested(ctx, e);</span><br><span class="line">        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler);</span><br><span class="line">        try &#123;</span><br><span class="line">            handler.sent(channel, e.getMessage());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            NettyChannel.removeChannelIfDisconnected(ctx.getChannel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //省略部分方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个对象继承SimpleChannelHandler，这里是netty的内容，不再赘述，倒是我们观察到，这个类的每个方法体，都是调用了handler的对应方法进行处理，那这个handler是什么东西呢？其实这个handler就是在DubboProtol中定义的，通过层层的参数传递，传到了NettyServer的父类AbstractPeer中，AbstractPeer也实现了ChannelHandler方法。</p><p>第二个关键的对象，是netty的编码器和解码器，dubbo为了避免粘包和拆包问题，自己定义了一套编解码规则，这部分的内容，将在讲解dubbo编解码时说明</p><h2 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h2><p>再来看Transporter的connect方法，还是以NettyTransporter为例，NettyTransporter的connect方法中new了一个NettyClient，NettyClient的doOpen方法几乎也是netty的代码，关键对象也和NettyServer一致，因此这里不再说明，倒是NettyClient在doOpen之后，还进行了一次connect操作，连上netty服务端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected void doConnect() throws Throwable &#123;</span><br><span class="line">    ChannelFuture future = bootstrap.connect(getConnectAddress());</span><br><span class="line">    try &#123;</span><br><span class="line">        Channel newChannel = future.getChannel();</span><br><span class="line">        newChannel.setInterestOps(Channel.OP_READ_WRITE);</span><br><span class="line">        NettyClient.this.channel = newChannel;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (!isConnected()) &#123;</span><br><span class="line">            future.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码做了精简，但最终其实就是将从netty中获取的channel赋值到NettyClient的成员变量channel中，以供后续的消息发送使用，消息发送，也是NettyClient关键的一个部分，也是在讲解Exchange中遗留的问题，在NettyClient的父类AbstractClient中，有个send方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void send(Object message, boolean sent) throws RemotingException &#123;</span><br><span class="line">    if (send_reconnect &amp;&amp; !isConnected()) &#123;</span><br><span class="line">        connect();</span><br><span class="line">    &#125;</span><br><span class="line">    Channel channel = getChannel();</span><br><span class="line">    //TODO getChannel返回的状态是否包含null需要改进</span><br><span class="line">    if (channel == null || !channel.isConnected()) &#123;</span><br><span class="line">        throw new RemotingException(this, &quot;message can not send, because channel is closed . url:&quot; + getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    channel.send(message, sent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里调用了getChannel();方法，其实返回的，就是刚刚讲的channel对象，通过这个对象，可以请求netty发送数据给服务端。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>《dubbo源码深度解析》之exchange 信息交换层</title>
    <link href="http://wangzx.org/2018/05/11/dubbo-exchange/"/>
    <id>http://wangzx.org/2018/05/11/dubbo-exchange/</id>
    <published>2018-05-11T12:33:27.000Z</published>
    <updated>2018-05-18T08:21:31.027Z</updated>
    
    <content type="html"><![CDATA[<p>exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer<br><strong><a id="more"></a></strong></p><h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@SPI(HeaderExchanger.NAME)</span><br><span class="line">public interface Exchanger &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * bind.</span><br><span class="line">     *</span><br><span class="line">     * @param url</span><br><span class="line">     * @param handler</span><br><span class="line">     * @return message server</span><br><span class="line">     */</span><br><span class="line">    @Adaptive(&#123;Constants.EXCHANGER_KEY&#125;)</span><br><span class="line">    ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * connect.</span><br><span class="line">     *</span><br><span class="line">     * @param url</span><br><span class="line">     * @param handler</span><br><span class="line">     * @return message channel</span><br><span class="line">     */</span><br><span class="line">    @Adaptive(&#123;Constants.EXCHANGER_KEY&#125;)</span><br><span class="line">    ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exchanger接口就两个方法，其中bind方法针对服务端，connect方法针对客户端，bind方法和connect方法都有一个参数：ExchangeHandler，我们来看下这个类：</p><h1 id="ExchangeHandler"><a href="#ExchangeHandler" class="headerlink" title="ExchangeHandler"></a>ExchangeHandler</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public interface ExchangeHandler extends ChannelHandler, TelnetHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * reply.</span><br><span class="line">     *</span><br><span class="line">     * @param channel</span><br><span class="line">     * @param request</span><br><span class="line">     * @return response</span><br><span class="line">     * @throws RemotingException</span><br><span class="line">     */</span><br><span class="line">    Object reply(ExchangeChannel channel, Object request) throws RemotingException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有一个方法，在Protocol层的DubboProtocol中有一个内部类实现了这个接口，当时在文中也有强调它的重要性，接着看ChannelHandler</p><h1 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@SPI</span><br><span class="line">public interface ChannelHandler &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * on channel connected.</span><br><span class="line">     *</span><br><span class="line">     * @param channel channel.</span><br><span class="line">     */</span><br><span class="line">    void connected(Channel channel) throws RemotingException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * on channel disconnected.</span><br><span class="line">     *</span><br><span class="line">     * @param channel channel.</span><br><span class="line">     */</span><br><span class="line">    void disconnected(Channel channel) throws RemotingException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * on message sent.</span><br><span class="line">     *</span><br><span class="line">     * @param channel channel.</span><br><span class="line">     * @param message message.</span><br><span class="line">     */</span><br><span class="line">    void sent(Channel channel, Object message) throws RemotingException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * on message received.</span><br><span class="line">     *</span><br><span class="line">     * @param channel channel.</span><br><span class="line">     * @param message message.</span><br><span class="line">     */</span><br><span class="line">    void received(Channel channel, Object message) throws RemotingException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * on exception caught.</span><br><span class="line">     *</span><br><span class="line">     * @param channel   channel.</span><br><span class="line">     * @param exception exception.</span><br><span class="line">     */</span><br><span class="line">    void caught(Channel channel, Throwable exception) throws RemotingException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍看之下，这里的接口非常像netty的接口，实际上dubbo也是借鉴了netty的设计思路，这五个接口，将在收到netty消息的时候被调用。</p><h1 id="ExchangeClient"><a href="#ExchangeClient" class="headerlink" title="ExchangeClient"></a>ExchangeClient</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ExchangeClient extends Client, ExchangeChannel &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExchangeClient封装了发送数据的方法，这个接口的父接口比较多，为了不占篇幅，这里不再贴父接口的代码，同学们可以自行查看，其中最重要的两个方法，是send和request。<br>ExchangeClient的实现类比较少，我们来看下HeaderExchangeClient这个实现类的request方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ResponseFuture request(Object request) throws RemotingException &#123;</span><br><span class="line">    return channel.request(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的channel是HeaderExchangeChannel的对象，在HeaderExchangeClient这个类的构造方法中初始化了这个对象，这个类实现了ExchangeChannel接口，因此也有request方法，我们再来看下这个类的request方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public ResponseFuture request(Object request, int timeout) throws RemotingException &#123;</span><br><span class="line">    // create request.</span><br><span class="line">    Request req = new Request();</span><br><span class="line">    req.setVersion(&quot;2.0.0&quot;);</span><br><span class="line">    req.setTwoWay(true);</span><br><span class="line">    req.setData(request);</span><br><span class="line">    DefaultFuture future = new DefaultFuture(channel, req, timeout);</span><br><span class="line">    try &#123;</span><br><span class="line">        channel.send(req);</span><br><span class="line">    &#125; catch (RemotingException e) &#123;</span><br><span class="line">        future.cancel();</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">    return future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里构造了一个Request对象，这个对象中包含了所有与方法调用相关的信息，如方法名、方法参数等，通过channel.send(req)方法发送出去，这里是channel是NettyClient，这也是个非常关键的对象，具体的细节，将在下一节Tranport层进行说明</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer&lt;br&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>《dubbo源码深度解析》之protocol 远程调用层</title>
    <link href="http://wangzx.org/2018/05/08/dubbo-protocol/"/>
    <id>http://wangzx.org/2018/05/08/dubbo-protocol/</id>
    <published>2018-05-08T13:10:15.000Z</published>
    <updated>2018-05-18T08:21:10.007Z</updated>
    
    <content type="html"><![CDATA[<p>protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</p><p><strong><a id="more"></a></strong></p><h1 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@SPI(&quot;dubbo&quot;)</span><br><span class="line">public interface Protocol &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取缺省端口，当用户没有配置端口时使用。</span><br><span class="line">     *</span><br><span class="line">     * @return 缺省端口</span><br><span class="line">     */</span><br><span class="line">    int getDefaultPort();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 暴露远程服务：&lt;br&gt;</span><br><span class="line">     * 1. 协议在接收请求时，应记录请求来源方地址信息：RpcContext.getContext().setRemoteAddress();&lt;br&gt;</span><br><span class="line">     * 2. export()必须是幂等的，也就是暴露同一个URL的Invoker两次，和暴露一次没有区别。&lt;br&gt;</span><br><span class="line">     * 3. export()传入的Invoker由框架实现并传入，协议不需要关心。&lt;br&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param &lt;T&gt;     服务的类型</span><br><span class="line">     * @param invoker 服务的执行体</span><br><span class="line">     * @return exporter 暴露服务的引用，用于取消暴露</span><br><span class="line">     * @throws RpcException 当暴露服务出错时抛出，比如端口已占用</span><br><span class="line">     */</span><br><span class="line">    @Adaptive</span><br><span class="line">    &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 引用远程服务：&lt;br&gt;</span><br><span class="line">     * 1. 当用户调用refer()所返回的Invoker对象的invoke()方法时，协议需相应执行同URL远端export()传入的Invoker对象的invoke()方法。&lt;br&gt;</span><br><span class="line">     * 2. refer()返回的Invoker由协议实现，协议通常需要在此Invoker中发送远程请求。&lt;br&gt;</span><br><span class="line">     * 3. 当url中有设置check=false时，连接失败不能抛出异常，并内部自动恢复。&lt;br&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param &lt;T&gt;  服务的类型</span><br><span class="line">     * @param type 服务的类型</span><br><span class="line">     * @param url  远程服务的URL地址</span><br><span class="line">     * @return invoker 服务的本地代理</span><br><span class="line">     * @throws RpcException 当连接服务提供方失败时抛出</span><br><span class="line">     */</span><br><span class="line">    @Adaptive</span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放协议：&lt;br&gt;</span><br><span class="line">     * 1. 取消该协议所有已经暴露和引用的服务。&lt;br&gt;</span><br><span class="line">     * 2. 释放协议所占用的所有资源，比如连接和端口。&lt;br&gt;</span><br><span class="line">     * 3. 协议在释放后，依然能暴露和引用新的服务。&lt;br&gt;</span><br><span class="line">     */</span><br><span class="line">    void destroy();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，最主要的两个方法是export和refer，export针对服务端，将Invoker暴露为Exporter，refer方法针对客户端，通过从注册中心获取的url和接口类型，获得到Invoker，通过SPI注解的key可知，默认的实现类是DubboProtocol，先来看下DubboProtocol的export方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">    // export service.</span><br><span class="line">    String key = serviceKey(url);</span><br><span class="line">    DubboExporter&lt;T&gt; exporter = new DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line">    //省略代码</span><br><span class="line">    openServer(url);</span><br><span class="line">    return exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到暴露的逻辑其实非常简单，从url中抽取出关键参数组装为一个key，如官方demo中的DemoService的key就是com.alibaba.dubbo.demo.DemoService:20880，然后new一个DubboExporter，存入exporterMap中，就完成了暴露，后续在接收到客户端请求时，也是从exporterMap这个对象中查找Exporter，从而进行方法的调用。</p><p>但似乎暴露的逻辑没有那么简单，最后还有一行代码：openServer(url);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void openServer(URL url) &#123;</span><br><span class="line">    // find server.</span><br><span class="line">    String key = url.getAddress();</span><br><span class="line">    //client 也可以暴露一个只有server可以调用的服务。</span><br><span class="line">    boolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true);</span><br><span class="line">    if (isServer) &#123;</span><br><span class="line">        ExchangeServer server = serverMap.get(key);</span><br><span class="line">        if (server == null) &#123;</span><br><span class="line">            serverMap.put(key, createServer(url));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //server支持reset,配合override功能使用</span><br><span class="line">            server.reset(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有个关键对象serverMap，key是url的地址，如：192.168.252.169:20880，如果serverMap中没有这个key，则调用createServer方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private ExchangeServer createServer(URL url) &#123;</span><br><span class="line">    //默认开启server关闭时发送readonly事件</span><br><span class="line">    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());</span><br><span class="line">    //默认开启heartbeat</span><br><span class="line">    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line">    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class="line">    url = url.addParameter(Constants.CODEC_KEY, Version.isCompatibleVersion() ? COMPATIBLE_CODEC_NAME : DubboCodec.NAME);</span><br><span class="line">    ExchangeServer server;</span><br><span class="line">    server = Exchangers.bind(url, requestHandler);</span><br><span class="line">    //省略代码</span><br><span class="line">    return server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中Exchangers.bind方法将会打开netty端口，这一部分留到Exchangers层进行说明，这里还有一个关键的对象，就是传给Exchangers.bind方法的ExchangeHandler对象，这个对象定义在了DubboProtol类中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">private ExchangeHandler requestHandler = new ExchangeHandlerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">       public Object reply(ExchangeChannel channel, Object message) throws RemotingException &#123;</span><br><span class="line">           if (message instanceof Invocation) &#123;</span><br><span class="line">               Invocation inv = (Invocation) message;</span><br><span class="line">               Invoker&lt;?&gt; invoker = getInvoker(channel, inv);</span><br><span class="line">               //如果是callback 需要处理高版本调用低版本的问题</span><br><span class="line">               if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">                   String methodsStr = invoker.getUrl().getParameters().get(&quot;methods&quot;);</span><br><span class="line">                   boolean hasMethod = false;</span><br><span class="line">                   if (methodsStr == null || methodsStr.indexOf(&quot;,&quot;) == -1) &#123;</span><br><span class="line">                       hasMethod = inv.getMethodName().equals(methodsStr);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       String[] methods = methodsStr.split(&quot;,&quot;);</span><br><span class="line">                       for (String method : methods) &#123;</span><br><span class="line">                           if (inv.getMethodName().equals(method)) &#123;</span><br><span class="line">                               hasMethod = true;</span><br><span class="line">                               break;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (!hasMethod) &#123;</span><br><span class="line">                       logger.warn(new IllegalStateException(&quot;The methodName &quot; + inv.getMethodName() + &quot; not found in callback service interface ,invoke will be ignored. please update the api interface. url is:&quot; + invoker.getUrl()) + &quot; ,invocation is :&quot; + inv);</span><br><span class="line">                       return null;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">               return invoker.invoke(inv);</span><br><span class="line">           &#125;</span><br><span class="line">           throw new RemotingException(channel, &quot;Unsupported request: &quot; + message == null ? null : (message.getClass().getName() + &quot;: &quot; + message) + &quot;, channel: consumer: &quot; + channel.getRemoteAddress() + &quot; --&gt; provider: &quot; + channel.getLocalAddress());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void received(Channel channel, Object message) throws RemotingException &#123;</span><br><span class="line">           if (message instanceof Invocation) &#123;</span><br><span class="line">               reply((ExchangeChannel) channel, message);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               super.received(channel, message);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void connected(Channel channel) throws RemotingException &#123;</span><br><span class="line">           invoke(channel, Constants.ON_CONNECT_KEY);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void disconnected(Channel channel) throws RemotingException &#123;</span><br><span class="line">           if (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(&quot;disconected from &quot; + channel.getRemoteAddress() + &quot;,url:&quot; + channel.getUrl());</span><br><span class="line">           &#125;</span><br><span class="line">           invoke(channel, Constants.ON_DISCONNECT_KEY);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       private void invoke(Channel channel, String methodKey) &#123;</span><br><span class="line">           Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey);</span><br><span class="line">           if (invocation != null) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   received(channel, invocation);</span><br><span class="line">               &#125; catch (Throwable t) &#123;</span><br><span class="line">                   logger.warn(&quot;Failed to invoke event method &quot; + invocation.getMethodName() + &quot;(), cause: &quot; + t.getMessage(), t);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       private Invocation createInvocation(Channel channel, URL url, String methodKey) &#123;</span><br><span class="line">           String method = url.getParameter(methodKey);</span><br><span class="line">           if (method == null || method.length() == 0) &#123;</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">           RpcInvocation invocation = new RpcInvocation(method, new Class&lt;?&gt;[0], new Object[0]);</span><br><span class="line">           invocation.setAttachment(Constants.PATH_KEY, url.getPath());</span><br><span class="line">           invocation.setAttachment(Constants.GROUP_KEY, url.getParameter(Constants.GROUP_KEY));</span><br><span class="line">           invocation.setAttachment(Constants.INTERFACE_KEY, url.getParameter(Constants.INTERFACE_KEY));</span><br><span class="line">           invocation.setAttachment(Constants.VERSION_KEY, url.getParameter(Constants.VERSION_KEY));</span><br><span class="line">           if (url.getParameter(Constants.STUB_EVENT_KEY, false)) &#123;</span><br><span class="line">               invocation.setAttachment(Constants.STUB_EVENT_KEY, Boolean.TRUE.toString());</span><br><span class="line">           &#125;</span><br><span class="line">           return invocation;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></p><p>这个对象非常的重要，在后续netty收到客户端发来的请求时，会回调这个对象中的方法，从而进行方法的调用，具体细节将留到后续讲解服务发布、服务调用的流程时来说明。</p><p>再来看下refer方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; serviceType, URL url) throws RpcException &#123;</span><br><span class="line">    // create rpc invoker.</span><br><span class="line">    DubboInvoker&lt;T&gt; invoker = new DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">    invokers.add(invoker);</span><br><span class="line">    return invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法本身非常简单，通过接口类型、url即可组装一个DubboInvoker对象，因此这里本身没什么好讲，倒是生成的DubboInvoker这个对象的doInvoke方法值得深究：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected Result doInvoke(final Invocation invocation) throws Throwable &#123;</span><br><span class="line">    boolean isAsync = RpcUtils.isAsync(getUrl(), invocation);</span><br><span class="line">    boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">    int timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">    if (isOneway) &#123;</span><br><span class="line">        boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);</span><br><span class="line">        currentClient.send(inv, isSent);</span><br><span class="line">        RpcContext.getContext().setFuture(null);</span><br><span class="line">        return new RpcResult();</span><br><span class="line">    &#125; else if (isAsync) &#123;</span><br><span class="line">        ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line">        RpcContext.getContext().setFuture(new FutureAdapter&lt;Object&gt;(future));</span><br><span class="line">        return new RpcResult();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        RpcContext.getContext().setFuture(null);</span><br><span class="line">        return (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看到三种方法调用的逻辑，分别是：同步调用、异步调用、同步转异步，默认是第三种。但无论是哪种，最终调用的都是ExchangeClient对象的send或request方法，ExchangeClient的具体细节，将在下一节Exchange层进行说明。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>《dubbo源码深度解析》之monitor 监控层</title>
    <link href="http://wangzx.org/2018/05/05/dubbo-monitor/"/>
    <id>http://wangzx.org/2018/05/05/dubbo-monitor/</id>
    <published>2018-05-05T11:54:12.000Z</published>
    <updated>2018-05-18T08:20:59.161Z</updated>
    
    <content type="html"><![CDATA[<p>monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</p><p><strong><a id="more"></a></strong></p><h1 id="MonitorService"><a href="#MonitorService" class="headerlink" title="MonitorService"></a>MonitorService</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public interface MonitorService &#123;</span><br><span class="line"></span><br><span class="line">    String APPLICATION = &quot;application&quot;;</span><br><span class="line"></span><br><span class="line">    String INTERFACE = &quot;interface&quot;;</span><br><span class="line"></span><br><span class="line">    String METHOD = &quot;method&quot;;</span><br><span class="line"></span><br><span class="line">    String GROUP = &quot;group&quot;;</span><br><span class="line"></span><br><span class="line">    String VERSION = &quot;version&quot;;</span><br><span class="line"></span><br><span class="line">    String CONSUMER = &quot;consumer&quot;;</span><br><span class="line"></span><br><span class="line">    String PROVIDER = &quot;provider&quot;;</span><br><span class="line"></span><br><span class="line">    String TIMESTAMP = &quot;timestamp&quot;;</span><br><span class="line"></span><br><span class="line">    String SUCCESS = &quot;success&quot;;</span><br><span class="line"></span><br><span class="line">    String FAILURE = &quot;failure&quot;;</span><br><span class="line"></span><br><span class="line">    String INPUT = Constants.INPUT_KEY;</span><br><span class="line"></span><br><span class="line">    String OUTPUT = Constants.OUTPUT_KEY;</span><br><span class="line"></span><br><span class="line">    String ELAPSED = &quot;elapsed&quot;;</span><br><span class="line"></span><br><span class="line">    String CONCURRENT = &quot;concurrent&quot;;</span><br><span class="line"></span><br><span class="line">    String MAX_INPUT = &quot;max.input&quot;;</span><br><span class="line"></span><br><span class="line">    String MAX_OUTPUT = &quot;max.output&quot;;</span><br><span class="line"></span><br><span class="line">    String MAX_ELAPSED = &quot;max.elapsed&quot;;</span><br><span class="line"></span><br><span class="line">    String MAX_CONCURRENT = &quot;max.concurrent&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 监控数据采集.</span><br><span class="line">     * 1. 支持调用次数统计：count://host/interface?application=foo&amp;method=foo&amp;provider=10.20.153.11:20880&amp;success=12&amp;failure=2&amp;elapsed=135423423</span><br><span class="line">     * 1.1 host,application,interface,group,version,method 记录监控来源主机，应用，接口，方法信息。</span><br><span class="line">     * 1.2 如果是消费者发送的数据，加上provider地址参数，反之，加上来源consumer地址参数。</span><br><span class="line">     * 1.3 success,faulure,elapsed 记录距上次采集，调用的成功次数，失败次数，成功调用总耗时，平均时间将用总耗时除以成功次数。</span><br><span class="line">     *</span><br><span class="line">     * @param statistics</span><br><span class="line">     */</span><br><span class="line">    void collect(URL statistics);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 监控数据查询. </span><br><span class="line">     * 1. 支持按天查询：count://host/interface?application=foo&amp;method=foo&amp;side=provider&amp;view=chart&amp;date=2012-07-03</span><br><span class="line">     * 1.1 host,application,interface,group,version,method 查询主机，应用，接口，方法的匹配条件，缺失的条件的表示全部，host用0.0.0.0表示全部。</span><br><span class="line">     * 1.2 side=consumer,provider 查询由调用的哪一端采集的数据，缺省为都查询。</span><br><span class="line">     * 1.3 缺省为view=summary，返回全天汇总信息，支持view=chart表示返回全天趋势图表图片的URL地址，可以进接嵌入其它系统的页面上展示。</span><br><span class="line">     * 1.4 date=2012-07-03 指定查询数据的日期，缺省为当天。</span><br><span class="line">     *</span><br><span class="line">     * @param query</span><br><span class="line">     * @return statistics</span><br><span class="line">     */</span><br><span class="line">    List&lt;URL&gt; lookup(URL query);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>monitor的架构跟其他的有些区别，Monitor是一个独立的监控系统，其本身也是个dubbo服务提供者，我们这里不去探究这个监控系统的源码，但我们可以猜测，那边也有一个类实现了MonitorService，并且那里的collect方法，才是真正实现监控日志收集整理的地方。但我们发现本地也有个collect方法，先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public void collect(URL url) &#123;</span><br><span class="line">    // 读写统计变量</span><br><span class="line">    int success = url.getParameter(MonitorService.SUCCESS, 0);</span><br><span class="line">    int failure = url.getParameter(MonitorService.FAILURE, 0);</span><br><span class="line">    int input = url.getParameter(MonitorService.INPUT, 0);</span><br><span class="line">    int output = url.getParameter(MonitorService.OUTPUT, 0);</span><br><span class="line">    int elapsed = url.getParameter(MonitorService.ELAPSED, 0);</span><br><span class="line">    int concurrent = url.getParameter(MonitorService.CONCURRENT, 0);</span><br><span class="line">    // 初始化原子引用</span><br><span class="line">    Statistics statistics = new Statistics(url);</span><br><span class="line">    AtomicReference&lt;long[]&gt; reference = statisticsMap.get(statistics);</span><br><span class="line">    if (reference == null) &#123;</span><br><span class="line">        statisticsMap.putIfAbsent(statistics, new AtomicReference&lt;long[]&gt;());</span><br><span class="line">        reference = statisticsMap.get(statistics);</span><br><span class="line">    &#125;</span><br><span class="line">    // CompareAndSet并发加入统计数据</span><br><span class="line">    long[] current;</span><br><span class="line">    long[] update = new long[LENGTH];</span><br><span class="line">    do &#123;</span><br><span class="line">        current = reference.get();</span><br><span class="line">        if (current == null) &#123;</span><br><span class="line">            update[0] = success;</span><br><span class="line">            update[1] = failure;</span><br><span class="line">            update[2] = input;</span><br><span class="line">            update[3] = output;</span><br><span class="line">            update[4] = elapsed;</span><br><span class="line">            update[5] = concurrent;</span><br><span class="line">            update[6] = input;</span><br><span class="line">            update[7] = output;</span><br><span class="line">            update[8] = elapsed;</span><br><span class="line">            update[9] = concurrent;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            update[0] = current[0] + success;</span><br><span class="line">            update[1] = current[1] + failure;</span><br><span class="line">            update[2] = current[2] + input;</span><br><span class="line">            update[3] = current[3] + output;</span><br><span class="line">            update[4] = current[4] + elapsed;</span><br><span class="line">            update[5] = (current[5] + concurrent) / 2;</span><br><span class="line">            update[6] = current[6] &gt; input ? current[6] : input;</span><br><span class="line">            update[7] = current[7] &gt; output ? current[7] : output;</span><br><span class="line">            update[8] = current[8] &gt; elapsed ? current[8] : elapsed;</span><br><span class="line">            update[9] = current[9] &gt; concurrent ? current[9] : concurrent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (!reference.compareAndSet(current, update));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有个关键对象：ConcurrentMap<statistics, atomicreference<long[]="">&gt; statisticsMap，可以看到这里是以Statistics为key，存放的内容是一个long类型的数组。至于AtomicReference是一个原子类，不熟悉的同学请百度。从代码中可以看到，long类型的数组的每一个元素，都代表一个监控数据，如第0位代表成功次数，第1位代表失败次数等，这个collect方法会在每次方法执行的时候被调用，然后不断的更新这个long类型数组的数据，我们可以在MonitorFilter中看到这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line">    if (invoker.getUrl().hasParameter(Constants.MONITOR_KEY)) &#123;</span><br><span class="line">        RpcContext context = RpcContext.getContext(); // 提供方必须在invoke()之前获取context信息</span><br><span class="line">        String remoteHost = context.getRemoteHost();</span><br><span class="line">        long start = System.currentTimeMillis(); // 记录起始时间戮</span><br><span class="line">        getConcurrent(invoker, invocation).incrementAndGet(); // 并发计数</span><br><span class="line">        Result result = invoker.invoke(invocation); // 让调用链往下执行</span><br><span class="line">        collect(invoker, invocation, result, remoteHost, start, false);</span><br><span class="line">        return result;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></statistics,></p><p>可以看到在invoker.invoke之后，有个collect方法，这个方法最终调用的，就是我们上面看到的collect方法，但我们好像始终只看到在不断的收集数据，但并没有发送给监控系统，如果每次方法调用，都讲结果发送给监控系统，那无疑监控系统的压力会剧增，并且服务调用的性能也会降低，因此dubbo采用的是定时发送的策略，每隔一分钟发送一次，在这一分钟内，调用collect收集来的数据，都会保存在statisticsMap，在定时发送时，则从这个map中取数据，发送给监控服务端，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public DubboMonitor(Invoker&lt;MonitorService&gt; monitorInvoker, MonitorService monitorService) &#123;</span><br><span class="line">    this.monitorInvoker = monitorInvoker;</span><br><span class="line">    this.monitorService = monitorService;</span><br><span class="line">    this.monitorInterval = monitorInvoker.getUrl().getPositiveParameter(&quot;interval&quot;, 60000);</span><br><span class="line">    // 启动统计信息收集定时器</span><br><span class="line">    sendFuture = scheduledExecutorService.scheduleWithFixedDelay(new Runnable() &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            // 收集统计信息</span><br><span class="line">            try &#123;</span><br><span class="line">                send();</span><br><span class="line">            &#125; catch (Throwable t) &#123; // 防御性容错</span><br><span class="line">                logger.error(&quot;Unexpected error occur at send statistic, cause: &quot; + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, monitorInterval, monitorInterval, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到定时调用了send方法，再来看send方法代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public void send() &#123;</span><br><span class="line">    if (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(&quot;Send statistics to monitor &quot; + getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    String timestamp = String.valueOf(System.currentTimeMillis());</span><br><span class="line">    for (Map.Entry&lt;Statistics, AtomicReference&lt;long[]&gt;&gt; entry : statisticsMap.entrySet()) &#123;</span><br><span class="line">        // 获取已统计数据</span><br><span class="line">        Statistics statistics = entry.getKey();</span><br><span class="line">        AtomicReference&lt;long[]&gt; reference = entry.getValue();</span><br><span class="line">        long[] numbers = reference.get();</span><br><span class="line">        long success = numbers[0];</span><br><span class="line">        long failure = numbers[1];</span><br><span class="line">        long input = numbers[2];</span><br><span class="line">        long output = numbers[3];</span><br><span class="line">        long elapsed = numbers[4];</span><br><span class="line">        long concurrent = numbers[5];</span><br><span class="line">        long maxInput = numbers[6];</span><br><span class="line">        long maxOutput = numbers[7];</span><br><span class="line">        long maxElapsed = numbers[8];</span><br><span class="line">        long maxConcurrent = numbers[9];</span><br><span class="line"></span><br><span class="line">        // 发送汇总信息</span><br><span class="line">        URL url = statistics.getUrl()</span><br><span class="line">                .addParameters(MonitorService.TIMESTAMP, timestamp,</span><br><span class="line">                        MonitorService.SUCCESS, String.valueOf(success),</span><br><span class="line">                        MonitorService.FAILURE, String.valueOf(failure),</span><br><span class="line">                        MonitorService.INPUT, String.valueOf(input),</span><br><span class="line">                        MonitorService.OUTPUT, String.valueOf(output),</span><br><span class="line">                        MonitorService.ELAPSED, String.valueOf(elapsed),</span><br><span class="line">                        MonitorService.CONCURRENT, String.valueOf(concurrent),</span><br><span class="line">                        MonitorService.MAX_INPUT, String.valueOf(maxInput),</span><br><span class="line">                        MonitorService.MAX_OUTPUT, String.valueOf(maxOutput),</span><br><span class="line">                        MonitorService.MAX_ELAPSED, String.valueOf(maxElapsed),</span><br><span class="line">                        MonitorService.MAX_CONCURRENT, String.valueOf(maxConcurrent)</span><br><span class="line">                );</span><br><span class="line">        monitorService.collect(url);</span><br><span class="line"></span><br><span class="line">        // 减掉已统计数据</span><br><span class="line">        long[] current;</span><br><span class="line">        long[] update = new long[LENGTH];</span><br><span class="line">        do &#123;</span><br><span class="line">            current = reference.get();</span><br><span class="line">            if (current == null) &#123;</span><br><span class="line">                update[0] = 0;</span><br><span class="line">                update[1] = 0;</span><br><span class="line">                update[2] = 0;</span><br><span class="line">                update[3] = 0;</span><br><span class="line">                update[4] = 0;</span><br><span class="line">                update[5] = 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                update[0] = current[0] - success;</span><br><span class="line">                update[1] = current[1] - failure;</span><br><span class="line">                update[2] = current[2] - input;</span><br><span class="line">                update[3] = current[3] - output;</span><br><span class="line">                update[4] = current[4] - elapsed;</span><br><span class="line">                update[5] = current[5] - concurrent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (!reference.compareAndSet(current, update));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法中间的monitorService.collect(url)方法，就是调用远程监控服务，发送数据，而数据都已经被包装在了url中，发送完成后，减掉已统计的数据，然后再开始新一轮的收集-发送。</p><h1 id="Statistics"><a href="#Statistics" class="headerlink" title="Statistics"></a>Statistics</h1><p>这个类没有什么特别的方法和作用，目的就是为了组装各个参数成为一个新的对象，我们看下类中的成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private URL url;</span><br><span class="line"></span><br><span class="line">private String application;</span><br><span class="line"></span><br><span class="line">private String service;</span><br><span class="line"></span><br><span class="line">private String method;</span><br><span class="line"></span><br><span class="line">private String group;</span><br><span class="line"></span><br><span class="line">private String version;</span><br><span class="line"></span><br><span class="line">private String client;</span><br><span class="line"></span><br><span class="line">private String server;</span><br></pre></td></tr></table></figure></p><p>也就是说dubbo的监控，是按这些参数组成的key作为单位进行统计</p><h1 id="MonitorFactory"><a href="#MonitorFactory" class="headerlink" title="MonitorFactory"></a>MonitorFactory</h1><p>顾名思义MonitorFactory就是用于获取一个Monitor对象的，通过SPI注解得知默认的实现类是DubboMonitorFactroy：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected Monitor createMonitor(URL url) &#123;</span><br><span class="line">       url = url.setProtocol(url.getParameter(Constants.PROTOCOL_KEY, &quot;dubbo&quot;));</span><br><span class="line">       if (url.getPath() == null || url.getPath().length() == 0) &#123;</span><br><span class="line">           url = url.setPath(MonitorService.class.getName());</span><br><span class="line">       &#125;</span><br><span class="line">       String filter = url.getParameter(Constants.REFERENCE_FILTER_KEY);</span><br><span class="line">       if (filter == null || filter.length() == 0) &#123;</span><br><span class="line">           filter = &quot;&quot;;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           filter = filter + &quot;,&quot;;</span><br><span class="line">       &#125;</span><br><span class="line">       url = url.addParameters(Constants.CLUSTER_KEY, &quot;failsafe&quot;, Constants.CHECK_KEY, String.valueOf(false),</span><br><span class="line">               Constants.REFERENCE_FILTER_KEY, filter + &quot;-monitor&quot;);</span><br><span class="line">       Invoker&lt;MonitorService&gt; monitorInvoker = protocol.refer(MonitorService.class, url);</span><br><span class="line">       MonitorService monitorService = proxyFactory.getProxy(monitorInvoker);</span><br><span class="line">       return new DubboMonitor(monitorInvoker, monitorService);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>通过倒数第二、第三行代码可以看到，这里的MonitorService，是一个动态代理对象，这也印证了之前文中所说的MonitorService是远程监控服务提供的一个服务类。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>《dubbo源码深度解析》之cluster 路由层</title>
    <link href="http://wangzx.org/2018/05/01/dubbo-cluster/"/>
    <id>http://wangzx.org/2018/05/01/dubbo-cluster/</id>
    <published>2018-05-01T10:22:41.000Z</published>
    <updated>2018-05-18T08:20:47.189Z</updated>
    
    <content type="html"><![CDATA[<p>cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance<br><strong><a id="more"></a></strong></p><h1 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@SPI(FailoverCluster.NAME)</span><br><span class="line">public interface Cluster &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Merge the directory invokers to a virtual invoker.</span><br><span class="line">     *</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @param directory</span><br><span class="line">     * @return cluster invoker</span><br><span class="line">     * @throws RpcException</span><br><span class="line">     */</span><br><span class="line">    @Adaptive</span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; join(Directory&lt;T&gt; directory) throws RpcException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cluster接口中就一个方法，接收一个Directory的参数，返回一个Invoker对象，Directory是多个Invoker的集合，也就是说Cluster的主要作用就是将多个Invoker伪装成一个Invoker，以供后续做负载均衡、集群容错、路由规则等功能提供条件。</p><p>我们来看下Cluster的实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AvailableCluster (com.alibaba.dubbo.rpc.cluster.support) </span><br><span class="line">BroadcastCluster (com.alibaba.dubbo.rpc.cluster.support) </span><br><span class="line">FailbackCluster (com.alibaba.dubbo.rpc.cluster.support) </span><br><span class="line">FailfastCluster (com.alibaba.dubbo.rpc.cluster.support) </span><br><span class="line">FailoverCluster (com.alibaba.dubbo.rpc.cluster.support) </span><br><span class="line">FailsafeCluster (com.alibaba.dubbo.rpc.cluster.support) </span><br><span class="line">ForkingCluster (com.alibaba.dubbo.rpc.cluster.support) </span><br><span class="line">MergeableCluster (com.alibaba.dubbo.rpc.cluster.support) </span><br><span class="line">MockClusterWrapper (com.alibaba.dubbo.rpc.cluster.support.wrapper)</span><br></pre></td></tr></table></figure></p><p>其中，默认的实现类是FailoverCluster，也就是自动重试的策略，常用的还有FailfastCluster：快速失败策略，通常用于非幂等性的操作，如写操作，在一次执行失败后就立即报失败，不会进行重试。MergeableCluster：结果合并策略。BroadcastCluster：广播策略等。</p><h1 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface Directory&lt;T&gt; extends Node &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get service type.</span><br><span class="line">     *</span><br><span class="line">     * @return service type.</span><br><span class="line">     */</span><br><span class="line">    Class&lt;T&gt; getInterface();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * list invokers.</span><br><span class="line">     *</span><br><span class="line">     * @return invokers</span><br><span class="line">     */</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) throws RpcException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Directory接口就两个方法，其中getInterface方法比较简单，就是返回该Invoker的接口类型，虽然Directory是多个Invoker的集合，但并不会有多个接口类型，因为这些不同的Invoker都是同一个接口在不同机器上的Invoker。</p><p>我们来看下Directory的实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbstractDirectory (com.alibaba.dubbo.rpc.cluster.directory) </span><br><span class="line">RegistryDirectory (com.alibaba.dubbo.registry.integration) </span><br><span class="line">StaticDirectory (com.alibaba.dubbo.rpc.cluster.directory)</span><br></pre></td></tr></table></figure></p><p>其中AbstractDirectory是公共的抽象父类，StaticDirectory又非常少用，我们就以RegistryDirectory为例，在看RegistryDirectory的代码之前，先看下他父类AbstractDirectory的list方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) throws RpcException &#123;</span><br><span class="line">        if (destroyed) &#123;</span><br><span class="line">            throw new RpcException(&quot;Directory already destroyed .url: &quot; + getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);</span><br><span class="line">        List&lt;Router&gt; localRouters = this.routers; // local reference</span><br><span class="line">        if (localRouters != null &amp;&amp; localRouters.size() &gt; 0) &#123;</span><br><span class="line">            for (Router router : localRouters) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, true)) &#123;</span><br><span class="line">                        invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    logger.error(&quot;Failed to execute router: &quot; + getUrl() + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return invokers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到在获取Invoker列表时，调用的是子类的doList方法，然后进行路由选择操作，Router是在Cluster这一层中的主要概念之一，后面会讲到，先来看子类的doList方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) &#123;</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = null;</span><br><span class="line">    Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; localMethodInvokerMap = this.methodInvokerMap; // local reference</span><br><span class="line">    if (localMethodInvokerMap != null &amp;&amp; localMethodInvokerMap.size() &gt; 0) &#123;</span><br><span class="line">        String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">        Object[] args = RpcUtils.getArguments(invocation);</span><br><span class="line">        if (args != null &amp;&amp; args.length &gt; 0 &amp;&amp; args[0] != null</span><br><span class="line">                &amp;&amp; (args[0] instanceof String || args[0].getClass().isEnum())) &#123;</span><br><span class="line">            invokers = localMethodInvokerMap.get(methodName + &quot;.&quot; + args[0]); // 可根据第一个参数枚举路由</span><br><span class="line">        &#125;</span><br><span class="line">        if (invokers == null) &#123;</span><br><span class="line">            invokers = localMethodInvokerMap.get(methodName);</span><br><span class="line">        &#125;</span><br><span class="line">        if (invokers == null) &#123;</span><br><span class="line">            invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        if (invokers == null) &#123;</span><br><span class="line">            Iterator&lt;List&lt;Invoker&lt;T&gt;&gt;&gt; iterator = localMethodInvokerMap.values().iterator();</span><br><span class="line">            if (iterator.hasNext()) &#123;</span><br><span class="line">                invokers = iterator.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return invokers == null ? new ArrayList&lt;Invoker&lt;T&gt;&gt;(0) : invokers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码中有个关键对象：methodInvokerMap，这是个Map<string, list<invoker<t="">&gt;&gt;，doList的过程，也就是从这个map中寻找invoker的过程，但我们知道RegistryDirectory中的Invoker是不固定的，它会随着注册中心的变化而变化，接收这个注册中心变化通知的方法，就是refreshInvoker方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private void refreshInvoker(List&lt;URL&gt; invokerUrls) &#123;</span><br><span class="line">    if (invokerUrls != null &amp;&amp; invokerUrls.size() == 1 &amp;&amp; invokerUrls.get(0) != null</span><br><span class="line">            &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) &#123;</span><br><span class="line">        this.forbidden = true; // 禁止访问</span><br><span class="line">        this.methodInvokerMap = null; // 置空列表</span><br><span class="line">        destroyAllInvokers(); // 关闭所有Invoker</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        this.forbidden = false; // 允许访问</span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = this.urlInvokerMap; // local reference</span><br><span class="line">        if (invokerUrls.size() == 0 &amp;&amp; this.cachedInvokerUrls != null) &#123;</span><br><span class="line">            invokerUrls.addAll(this.cachedInvokerUrls);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.cachedInvokerUrls = new HashSet&lt;URL&gt;();</span><br><span class="line">            this.cachedInvokerUrls.addAll(invokerUrls);//缓存invokerUrls列表，便于交叉对比</span><br><span class="line">        &#125;</span><br><span class="line">        if (invokerUrls.size() == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);// 将URL列表转成Invoker列表</span><br><span class="line">        Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap); // 换方法名映射Invoker列表</span><br><span class="line">        // state change</span><br><span class="line">        //如果计算错误，则不进行处理.</span><br><span class="line">        if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) &#123;</span><br><span class="line">            logger.error(new IllegalStateException(&quot;urls to invokers error .invokerUrls.size :&quot; + invokerUrls.size() + &quot;, invoker.size :0. urls :&quot; + invokerUrls.toString()));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        this.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;</span><br><span class="line">        this.urlInvokerMap = newUrlInvokerMap;</span><br><span class="line">        try &#123;</span><br><span class="line">            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); // 关闭未使用的Invoker</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.warn(&quot;destroyUnusedInvokers error. &quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></string,></p><p>这个方法接收一个invokerUrls，是个url列表，将url列表转换为多个Invoker，存入到methodInvokerMap中。<br>在之类的doList方法完成后，如上所说，将会进行一次路由选择操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) throws RpcException &#123;</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);</span><br><span class="line">    List&lt;Router&gt; localRouters = this.routers; // local reference</span><br><span class="line">    if (localRouters != null &amp;&amp; localRouters.size() &gt; 0) &#123;</span><br><span class="line">        for (Router router : localRouters) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, true)) &#123;</span><br><span class="line">                    invokers = router.route(invokers, getConsumerUrl(), invocation);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.error(&quot;Failed to execute router: &quot; + getUrl() + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return invokers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法中有个关键对象：private volatile List<router> routers;这个对象跟上面提到的Map<string, list<invoker<t="">&gt;&gt; methodInvokerMap;一样，都会随着注册中心的变化而变化，而接收这个变化通知的方法，是notify方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void notify(List&lt;URL&gt; urls) &#123;</span><br><span class="line">    List&lt;URL&gt; invokerUrls = new ArrayList&lt;URL&gt;();</span><br><span class="line">    List&lt;URL&gt; routerUrls = new ArrayList&lt;URL&gt;();</span><br><span class="line">    List&lt;URL&gt; configuratorUrls = new ArrayList&lt;URL&gt;();</span><br><span class="line">    //省略代码</span><br><span class="line">    // routers</span><br><span class="line">    if (routerUrls != null &amp;&amp; routerUrls.size() &gt; 0) &#123;</span><br><span class="line">        List&lt;Router&gt; routers = toRouters(routerUrls);</span><br><span class="line">        if (routers != null) &#123; // null - do nothing</span><br><span class="line">            setRouters(routers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //省略代码</span><br><span class="line">    // providers</span><br><span class="line">    refreshInvoker(invokerUrls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></string,></router></p><p>方法中的setRouters(routers)就是更新routers对象。</p><h1 id="LoadBalance"><a href="#LoadBalance" class="headerlink" title="LoadBalance"></a>LoadBalance</h1><p>在cluster层中还有一个关键接口：LoadBalance，顾名思义这是做负载均衡用的，看下接口定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@SPI(RandomLoadBalance.NAME)</span><br><span class="line">public interface LoadBalance &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * select one invoker in list.</span><br><span class="line">     *</span><br><span class="line">     * @param invokers   invokers.</span><br><span class="line">     * @param url        refer url</span><br><span class="line">     * @param invocation invocation.</span><br><span class="line">     * @return selected invoker.</span><br><span class="line">     */</span><br><span class="line">    @Adaptive(&quot;loadbalance&quot;)</span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口只有一个方法：select，传入的对象是个Invoker列表，这里的列表，已经是经过Directory和Route筛选过了的Invoker，在LoadBalance中，不再做Invoker的校验筛选过滤等，而仅仅是对传入的Invoker列表，按照一定的规则进行负载均衡，来看下实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AbstractLoadBalance (com.alibaba.dubbo.rpc.cluster.loadbalance) </span><br><span class="line">ConsistentHashLoadBalance (com.alibaba.dubbo.rpc.cluster.loadbalance) </span><br><span class="line">LeastActiveLoadBalance (com.alibaba.dubbo.rpc.cluster.loadbalance) </span><br><span class="line">RandomLoadBalance (com.alibaba.dubbo.rpc.cluster.loadbalance) </span><br><span class="line">RoundRobinLoadBalance (com.alibaba.dubbo.rpc.cluster.loadbalance)</span><br></pre></td></tr></table></figure></p><p>AbstractLoadBalance是公共的抽象父类，其余4个，都是负载均衡的算法，分别为：一致性hash、最小活跃度、随机、轮询，通过LoadBalance的Spi注解中的key可以得知，默认的算法是随机算法，即RandomLoadBalance </p><p>我们先来看下FailoverClusterInvoker的doInvoke方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public Result doInvoke(Invocation invocation, final List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; copyinvokers = invokers;</span><br><span class="line">    checkInvokers(copyinvokers, invocation);</span><br><span class="line">    int len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;</span><br><span class="line">    if (len &lt;= 0) &#123;</span><br><span class="line">        len = 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // retry loop.</span><br><span class="line">    RpcException le = null; // last exception.</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invoked = new ArrayList&lt;Invoker&lt;T&gt;&gt;(copyinvokers.size()); // invoked invokers.</span><br><span class="line">    Set&lt;String&gt; providers = new HashSet&lt;String&gt;(len);</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        //重试时，进行重新选择，避免重试时invoker列表已发生变化.</span><br><span class="line">        //注意：如果列表发生了变化，那么invoked判断会失效，因为invoker示例已经改变</span><br><span class="line">        if (i &gt; 0) &#123;</span><br><span class="line">            checkWhetherDestroyed();</span><br><span class="line">            copyinvokers = list(invocation);</span><br><span class="line">            //重新检查一下</span><br><span class="line">            checkInvokers(copyinvokers, invocation);</span><br><span class="line">        &#125;</span><br><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyinvokers, invoked);</span><br><span class="line">        invoked.add(invoker);</span><br><span class="line">        RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">        Result result = invoker.invoke(invocation);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码中可以看到，先是进行了一次for循环，默认的循环次数为3次，然后进行了一次select方法进行Invoker选择，最后调用Invoker的invoke方法，我们看下这里的doSelect方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private Invoker&lt;T&gt; doselect(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected) throws RpcException &#123;</span><br><span class="line">    if (invokers == null || invokers.size() == 0)</span><br><span class="line">        return null;</span><br><span class="line">    if (invokers.size() == 1)</span><br><span class="line">        return invokers.get(0);</span><br><span class="line">    // 如果只有两个invoker，退化成轮循</span><br><span class="line">    if (invokers.size() == 2 &amp;&amp; selected != null &amp;&amp; selected.size() &gt; 0) &#123;</span><br><span class="line">        return selected.get(0) == invokers.get(0) ? invokers.get(1) : invokers.get(0);</span><br><span class="line">    &#125;</span><br><span class="line">    Invoker&lt;T&gt; invoker = loadbalance.select(invokers, getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">    //如果 selected中包含（优先判断） 或者 不可用&amp;&amp;availablecheck=true 则重试.</span><br><span class="line">    if ((selected != null &amp;&amp; selected.contains(invoker))</span><br><span class="line">            || (!invoker.isAvailable() &amp;&amp; getUrl() != null &amp;&amp; availablecheck)) &#123;</span><br><span class="line">        Invoker&lt;T&gt; rinvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);</span><br><span class="line">        if (rinvoker != null) &#123;</span><br><span class="line">            invoker = rinvoker;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //看下第一次选的位置，如果不是最后，选+1位置.</span><br><span class="line">            int index = invokers.indexOf(invoker);</span><br><span class="line">            //最后在避免碰撞</span><br><span class="line">            invoker = index &lt; invokers.size() - 1 ? invokers.get(index + 1) : invoker;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果Invoker只有1个，那直接返回，如果Invoker只有2个，那退化成轮询，否则才进行LoadBlance的select操作。我们来看下默认的RandomLoadBalance的doSelect方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">    int length = invokers.size(); // 总个数</span><br><span class="line">    int totalWeight = 0; // 总权重</span><br><span class="line">    boolean sameWeight = true; // 权重是否都一样</span><br><span class="line">    for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        int weight = getWeight(invokers.get(i), invocation);</span><br><span class="line">        totalWeight += weight; // 累计总权重</span><br><span class="line">        if (sameWeight &amp;&amp; i &gt; 0</span><br><span class="line">                &amp;&amp; weight != getWeight(invokers.get(i - 1), invocation)) &#123;</span><br><span class="line">            sameWeight = false; // 计算所有权重是否一样</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (totalWeight &gt; 0 &amp;&amp; !sameWeight) &#123;</span><br><span class="line">        // 如果权重不相同且权重大于0则按总权重数随机</span><br><span class="line">        int offset = random.nextInt(totalWeight);</span><br><span class="line">        // 并确定随机值落在哪个片断上</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            offset -= getWeight(invokers.get(i), invocation);</span><br><span class="line">            if (offset &lt; 0) &#123;</span><br><span class="line">                return invokers.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果权重相同或权重为0则均等随机</span><br><span class="line">    return invokers.get(random.nextInt(length));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这里有个权重的概念，所以随机算法，准确的说应该是加权随机算法，权重值可以在dubboAdmin中配置，最终也是通过zookeeper的订阅事件传到这里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance&lt;br&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>《dubbo源码深度解析》之registry 注册中心层</title>
    <link href="http://wangzx.org/2018/04/26/dubbo-registry%20/"/>
    <id>http://wangzx.org/2018/04/26/dubbo-registry /</id>
    <published>2018-04-26T10:21:32.000Z</published>
    <updated>2018-05-18T08:20:30.959Z</updated>
    
    <content type="html"><![CDATA[<p>registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService<br><strong><a id="more"></a></strong></p><h1 id="RegistryFactory"><a href="#RegistryFactory" class="headerlink" title="RegistryFactory"></a>RegistryFactory</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@SPI(&quot;dubbo&quot;)</span><br><span class="line">public interface RegistryFactory &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 连接注册中心.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 连接注册中心需处理契约：&lt;br&gt;</span><br><span class="line">     * 1. 当设置check=false时表示不检查连接，否则在连接不上时抛出异常。&lt;br&gt;</span><br><span class="line">     * 2. 支持URL上的username:password权限认证。&lt;br&gt;</span><br><span class="line">     * 3. 支持backup=10.20.153.10备选注册中心集群地址。&lt;br&gt;</span><br><span class="line">     * 4. 支持file=registry.cache本地磁盘文件缓存。&lt;br&gt;</span><br><span class="line">     * 5. 支持timeout=1000请求超时设置。&lt;br&gt;</span><br><span class="line">     * 6. 支持session=60000会话超时或过期设置。&lt;br&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param url 注册中心地址，不允许为空</span><br><span class="line">     * @return 注册中心引用，总不返回空</span><br><span class="line">     */</span><br><span class="line">    @Adaptive(&#123;&quot;protocol&quot;&#125;)</span><br><span class="line">    Registry getRegistry(URL url);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AbstractRegistryFactory (com.alibaba.dubbo.registry.support) </span><br><span class="line">DubboRegistryFactory (com.alibaba.dubbo.registry.dubbo) </span><br><span class="line">MockRegistryFactory (com.alibaba.dubbo.config.spring.registry) </span><br><span class="line">MockRegistryFactory (com.alibaba.dubbo.config.support) </span><br><span class="line">MulticastRegistryFactory (com.alibaba.dubbo.registry.multicast) </span><br><span class="line">RedisRegistryFactory (com.alibaba.dubbo.registry.redis) </span><br><span class="line">ZookeeperRegistryFactory (com.alibaba.dubbo.registry.zookeeper)</span><br></pre></td></tr></table></figure></p><h1 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface Registry extends Node, RegistryService &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AbstractRegistry (com.alibaba.dubbo.registry.support) </span><br><span class="line">Anonymous in createRegistry() in Anonymous in registryFactory in AbstractRegistryFactoryTest (com.alibaba.dubbo.registry.support) </span><br><span class="line">DubboRegistry (com.alibaba.dubbo.registry.dubbo) </span><br><span class="line">FailbackRegistry (com.alibaba.dubbo.registry.support) </span><br><span class="line">MockRegistry (com.alibaba.dubbo.config.spring.registry) </span><br><span class="line">MockRegistry (com.alibaba.dubbo.config.support) </span><br><span class="line">MockRegistry in FailbackRegistryTest (com.alibaba.dubbo.registry.support) </span><br><span class="line">MockRegistry in RegistryDirectoryTest (com.alibaba.dubbo.registry.dubbo) </span><br><span class="line">MockRegistry in RegistryProtocolTest (com.alibaba.dubbo.registry.dubbo) </span><br><span class="line">MulticastRegistry (com.alibaba.dubbo.registry.multicast) </span><br><span class="line">RedisRegistry (com.alibaba.dubbo.registry.redis) </span><br><span class="line">SimpleRegistryService (com.alibaba.dubbo.registry.simple)</span><br><span class="line">ZookeeperRegistry (com.alibaba.dubbo.registry.zookeeper)</span><br></pre></td></tr></table></figure></p><h1 id="RegistryService"><a href="#RegistryService" class="headerlink" title="RegistryService"></a>RegistryService</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public interface RegistryService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 注册数据，比如：提供者地址，消费者地址，路由规则，覆盖规则，等数据。</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 注册需处理契约：&lt;br&gt;</span><br><span class="line">     * 1. 当URL设置了check=false时，注册失败后不报错，在后台定时重试，否则抛出异常。&lt;br&gt;</span><br><span class="line">     * 2. 当URL设置了dynamic=false参数，则需持久存储，否则，当注册者出现断电等情况异常退出时，需自动删除。&lt;br&gt;</span><br><span class="line">     * 3. 当URL设置了category=routers时，表示分类存储，缺省类别为providers，可按分类部分通知数据。&lt;br&gt;</span><br><span class="line">     * 4. 当注册中心重启，网络抖动，不能丢失数据，包括断线自动删除数据。&lt;br&gt;</span><br><span class="line">     * 5. 允许URI相同但参数不同的URL并存，不能覆盖。&lt;br&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param url 注册信息，不允许为空，如：dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span><br><span class="line">     */</span><br><span class="line">    void register(URL url);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 取消注册.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 取消注册需处理契约：&lt;br&gt;</span><br><span class="line">     * 1. 如果是dynamic=false的持久存储数据，找不到注册数据，则抛IllegalStateException，否则忽略。&lt;br&gt;</span><br><span class="line">     * 2. 按全URL匹配取消注册。&lt;br&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param url 注册信息，不允许为空，如：dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span><br><span class="line">     */</span><br><span class="line">    void unregister(URL url);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 订阅符合条件的已注册数据，当有注册数据变更时自动推送.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 订阅需处理契约：&lt;br&gt;</span><br><span class="line">     * 1. 当URL设置了check=false时，订阅失败后不报错，在后台定时重试。&lt;br&gt;</span><br><span class="line">     * 2. 当URL设置了category=routers，只通知指定分类的数据，多个分类用逗号分隔，并允许星号通配，表示订阅所有分类数据。&lt;br&gt;</span><br><span class="line">     * 3. 允许以interface,group,version,classifier作为条件查询，如：interface=com.alibaba.foo.BarService&amp;version=1.0.0&lt;br&gt;</span><br><span class="line">     * 4. 并且查询条件允许星号通配，订阅所有接口的所有分组的所有版本，或：interface=*&amp;group=*&amp;version=*&amp;classifier=*&lt;br&gt;</span><br><span class="line">     * 5. 当注册中心重启，网络抖动，需自动恢复订阅请求。&lt;br&gt;</span><br><span class="line">     * 6. 允许URI相同但参数不同的URL并存，不能覆盖。&lt;br&gt;</span><br><span class="line">     * 7. 必须阻塞订阅过程，等第一次通知完后再返回。&lt;br&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param url      订阅条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span><br><span class="line">     * @param listener 变更事件监听器，不允许为空</span><br><span class="line">     */</span><br><span class="line">    void subscribe(URL url, NotifyListener listener);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 取消订阅.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * 取消订阅需处理契约：&lt;br&gt;</span><br><span class="line">     * 1. 如果没有订阅，直接忽略。&lt;br&gt;</span><br><span class="line">     * 2. 按全URL匹配取消订阅。&lt;br&gt;</span><br><span class="line">     *</span><br><span class="line">     * @param url      订阅条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span><br><span class="line">     * @param listener 变更事件监听器，不允许为空</span><br><span class="line">     */</span><br><span class="line">    void unsubscribe(URL url, NotifyListener listener);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询符合条件的已注册数据，与订阅的推模式相对应，这里为拉模式，只返回一次结果。</span><br><span class="line">     *</span><br><span class="line">     * @param url 查询条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin</span><br><span class="line">     * @return 已注册信息列表，可能为空，含义同&#123;@link com.alibaba.dubbo.registry.NotifyListener#notify(List&lt;URL&gt;)&#125;的参数。</span><br><span class="line">     * @see com.alibaba.dubbo.registry.NotifyListener#notify(List)</span><br><span class="line">     */</span><br><span class="line">    List&lt;URL&gt; lookup(URL url);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AbstractRegistry (com.alibaba.dubbo.registry.support) </span><br><span class="line">AbstractRegistryService (com.alibaba.dubbo.config.spring) </span><br><span class="line">AbstractRegistryService (com.alibaba.dubbo.registry.dubbo) Anonymous in createRegistry() in Anonymous in registryFactory in </span><br><span class="line">AbstractRegistryFactoryTest (com.alibaba.dubbo.registry.support) </span><br><span class="line">DubboRegistry (com.alibaba.dubbo.registry.dubbo) </span><br><span class="line">FailbackRegistry (com.alibaba.dubbo.registry.support) </span><br><span class="line">MockRegistry (com.alibaba.dubbo.config.spring.registry) </span><br><span class="line">MockRegistry (com.alibaba.dubbo.config.support) </span><br><span class="line">MulticastRegistry (com.alibaba.dubbo.registry.multicast) </span><br><span class="line">RedisRegistry (com.alibaba.dubbo.registry.redis) </span><br><span class="line">Registry (com.alibaba.dubbo.registry) </span><br><span class="line">SimpleRegistryService (com.alibaba.dubbo.config.spring) </span><br><span class="line">SimpleRegistryService (com.alibaba.dubbo.registry.dubbo) </span><br><span class="line">SimpleRegistryService (com.alibaba.dubbo.registry.simple) </span><br><span class="line">ZookeeperRegistry (com.alibaba.dubbo.registry.zookeeper)</span><br></pre></td></tr></table></figure></p><p>通过这几个类的接口方法可以看到，dubbo的registry层是围绕这注册中心的注册、订阅展开的，我们以最常用的zookeeper注册中心来看下注册订阅的流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void doRegister(URL url) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new RpcException(&quot;Failed to register &quot; + url + &quot; to zookeeper &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>zkClient.create的方法体在AbstractZookeeperClient中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void create(String path, boolean ephemeral) &#123;</span><br><span class="line">       int i = path.lastIndexOf(&apos;/&apos;);</span><br><span class="line">       if (i &gt; 0) &#123;</span><br><span class="line">           create(path.substring(0, i), false);</span><br><span class="line">       &#125;</span><br><span class="line">       if (ephemeral) &#123;</span><br><span class="line">           createEphemeral(path);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           createPersistent(path);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>ephemeral参数是用于控制永久节点还是临时节点的，再玩下代码基本上到了ZkClient的范畴，不在本文讨论范围内。</p><p>再看下取消注册的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void doUnregister(URL url) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            zkClient.delete(toUrlPath(url));</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new RpcException(&quot;Failed to unregister &quot; + url + &quot; to zookeeper &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>也非常的简单，调用ZKClient删除节点即可。再来看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">protected void doSubscribe(final URL url, final NotifyListener listener) &#123;</span><br><span class="line">        List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;();</span><br><span class="line">        for (String path : toCategoriesPath(url)) &#123;</span><br><span class="line">            ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br><span class="line">            if (listeners == null) &#123;</span><br><span class="line">                zkListeners.putIfAbsent(url, new ConcurrentHashMap&lt;NotifyListener, ChildListener&gt;());</span><br><span class="line">                listeners = zkListeners.get(url);</span><br><span class="line">            &#125;</span><br><span class="line">            ChildListener zkListener = listeners.get(listener);</span><br><span class="line">            if (zkListener == null) &#123;</span><br><span class="line">                listeners.putIfAbsent(listener, new ChildListener() &#123;</span><br><span class="line">                    public void childChanged(String parentPath, List&lt;String&gt; currentChilds) &#123;</span><br><span class="line">                        ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                zkListener = listeners.get(listener);</span><br><span class="line">            &#125;</span><br><span class="line">            zkClient.create(path, false);</span><br><span class="line">            List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);</span><br><span class="line">            if (children != null) &#123;</span><br><span class="line">                urls.addAll(toUrlsWithEmpty(url, path, children));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        notify(url, listener, urls);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService&lt;br&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>《dubbo源码深度解析》之proxy 服务代理层</title>
    <link href="http://wangzx.org/2018/04/22/dubbo-proxy%20/"/>
    <id>http://wangzx.org/2018/04/22/dubbo-proxy /</id>
    <published>2018-04-22T03:54:42.000Z</published>
    <updated>2018-05-18T08:20:08.678Z</updated>
    
    <content type="html"><![CDATA[<p>proxy层是dubbo架构中的第三层，在dubbo官网中的定义如下：<br>proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory<br><strong><a id="more"></a></strong></p><h1 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SPI(&quot;javassist&quot;)</span><br><span class="line">public interface ProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Adaptive(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException;</span><br><span class="line"></span><br><span class="line">    @Adaptive(&#123;Constants.PROXY_KEY&#125;)</span><br><span class="line">    &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProxyFactory只有两个方法：getProxy和getInvoker，其中，getProxy针对客户端，参数只有一个：Invoker，Invoker也多次提到，是贯穿dubbo全文的一个可执行对象，getProxy返回的是一个动态代理对象，暂时可以理解为jdk动态代理对象，当然这里不止jdk动态代理一种实现方式。</p><p>getInvoker方法针对服务端，传入的参数有三个：目标接口实现类（DemoServiceImpl）、接口的Class对象、url，通过这三个参数，构造出一个Invoker，通过这个方法也可以看出Invoker对象是一个具备执行能力的对象。</p><p>ProxyFactory的实现类有很多，但扣去包装类，公共父类等，真正的实现类就两个：JdkProxyFactory和JavassistProxyFactory</p><h1 id="JdkProxyFactory"><a href="#JdkProxyFactory" class="headerlink" title="JdkProxyFactory"></a>JdkProxyFactory</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class JdkProxyFactory extends AbstractProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Object doInvoke(T proxy, String methodName,</span><br><span class="line">                                      Class&lt;?&gt;[] parameterTypes,</span><br><span class="line">                                      Object[] arguments) throws Throwable &#123;</span><br><span class="line">                Method method = proxy.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line">                return method.invoke(proxy, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，getProxy方法就是一个标准的jdk动态代理的实现方式，对jdk动态代理不熟悉的同学可以看我之前的文章：<a href="http://wangzx.org/2018/04/28/jdk-proxy/">http://wangzx.org/2018/04/28/jdk-proxy/</a> ，这里有个关键的类，就是InvokerInvocationHandler，我们来看下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class InvokerInvocationHandler implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private final Invoker&lt;?&gt; invoker;</span><br><span class="line"></span><br><span class="line">    public InvokerInvocationHandler(Invoker&lt;?&gt; handler) &#123;</span><br><span class="line">        this.invoker = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        if (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            return method.invoke(invoker, args);</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;toString&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123;</span><br><span class="line">            return invoker.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;hashCode&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123;</span><br><span class="line">            return invoker.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;equals&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 1) &#123;</span><br><span class="line">            return invoker.equals(args[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker.invoke(new RpcInvocation(method, args)).recreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个类也是jdk动态代理的标准实现方式，最终调用的是Invoker的invoke方法，这个方法非常关键，我们在后面再讲。</p><p>然后是getInvoker方法，重申一遍这个方法针对的是服务端，从方法参数中也可以看到这是一个针对服务端的接口，因为参数中包含proxy这个对象，即实现类的对象，只有在服务端中才有实现类，返回的是一个AbstractProxyInvoker对象，这是一个实现了Invoker的抽象类，但在getInvoker方法中，我们好像并没有实现Invoker的invoker方法，而是实现了doInvoke方法，这个怎么回事呢？我们看下AbstractProxyInvoker的invoke方法就能得到答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return new RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            return new RpcResult(e.getTargetException());</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new RpcException(&quot;Failed to invoke remote proxy method &quot; + invocation.getMethodName() + &quot; to &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>AbstractProxyInvoker将在服务端收到客户端发来的请求后，通过url找到Invoker，然后调用Invoker的invoke方法，然后调用我们重写的doInvoke方法，最终通过jdk反射完成了方法的调用。</p><h1 id="JavassistProxyFactory"><a href="#JavassistProxyFactory" class="headerlink" title="JavassistProxyFactory"></a>JavassistProxyFactory</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class JavassistProxyFactory extends AbstractProxyFactory &#123;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123;</span><br><span class="line">        // TODO Wrapper类不能正确处理带$的类名</span><br><span class="line">        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&apos;$&apos;) &lt; 0 ? proxy.getClass() : type);</span><br><span class="line">        return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Object doInvoke(T proxy, String methodName,</span><br><span class="line">                                      Class&lt;?&gt;[] parameterTypes,</span><br><span class="line">                                      Object[] arguments) throws Throwable &#123;</span><br><span class="line">                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getProxy方法也就一行代码，乍看跟jdk动态代理很像，但其实这里Proxy.getProxy()方法是dubbo自己实现的一套生成动态代理类的逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static Proxy getProxy(ClassLoader cl, Class&lt;?&gt;... ics) &#123;</span><br><span class="line">        //省略代码</span><br><span class="line">        String pcn = pkg + &quot;.proxy&quot; + id;</span><br><span class="line">        ccp.setClassName(pcn);</span><br><span class="line">        ccp.addField(&quot;public static java.lang.reflect.Method[] methods;&quot;);</span><br><span class="line">        ccp.addField(&quot;private &quot; + InvocationHandler.class.getName() + &quot; handler;&quot;);</span><br><span class="line">        ccp.addConstructor(Modifier.PUBLIC, new Class&lt;?&gt;[]&#123;InvocationHandler.class&#125;, new Class&lt;?&gt;[0], &quot;handler=$1;&quot;);</span><br><span class="line">        ccp.addDefaultConstructor();</span><br><span class="line">        Class&lt;?&gt; clazz = ccp.toClass();</span><br><span class="line">        clazz.getField(&quot;methods&quot;).set(null, methods.toArray(new Method[0]));</span><br><span class="line"></span><br><span class="line">        // create Proxy class.</span><br><span class="line">        String fcn = Proxy.class.getName() + id;</span><br><span class="line">        ccm = ClassGenerator.newInstance(cl);</span><br><span class="line">        ccm.setClassName(fcn);</span><br><span class="line">        ccm.addDefaultConstructor();</span><br><span class="line">        ccm.setSuperClass(Proxy.class);</span><br><span class="line">        ccm.addMethod(&quot;public Object newInstance(&quot; + InvocationHandler.class.getName() + &quot; h)&#123; return new &quot; + pcn + &quot;($1); &#125;&quot;);</span><br><span class="line">        Class&lt;?&gt; pc = ccm.toClass();</span><br><span class="line">        proxy = (Proxy) pc.newInstance();</span><br><span class="line">        //省略代码</span><br><span class="line">        return proxy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以大概看出是通过javassist来动态生成类，具体的生成逻辑我们不用他太过关心，倒是可以看下最终生成的类是什么样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Proxy0 extends Proxy implements com.alibaba.dubbo.rpc.service.EchoService,com.alibaba.dubbo.demo.DemoService&#123;</span><br><span class="line">    </span><br><span class="line">    public static java.lang.reflect.Method[] methods;</span><br><span class="line">    </span><br><span class="line">    private java.lang.reflect.InvocationHandler handler;</span><br><span class="line">    </span><br><span class="line">    public Proxy0(java.lang.reflect.InvocationHandler arg0)&#123;</span><br><span class="line">        handler=arg0;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object newInstance(InvocationHandler h)&#123;</span><br><span class="line">        return new Proxy0(h);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public java.lang.String sayHello(java.lang.String arg0) throws Throwable &#123;</span><br><span class="line">        Object[] args = new Object[1];</span><br><span class="line">        args[0] = arg0;</span><br><span class="line">        Object ret = handler.invoke(this, methods[0], args);</span><br><span class="line">        return (java.lang.String)ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public java.lang.Object $echo(java.lang.Object arg0) throws Throwable &#123;</span><br><span class="line">        Object[] args = new Object[1];</span><br><span class="line">        args[0] = arg0;</span><br><span class="line">        Object ret = handler.invoke(this, methods[1], args);</span><br><span class="line">        return (java.lang.Object)ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个就是代理对象的代码，可以看到在调用sayHello这个方法是，最终调用的其实也是InvocationHandler对象的invoke方法，而InvocationHandler 这个对象，是在newInstance这个方法中传进去的，这里的而InvocationHandler用的和JdkProxyFactory中用的是同一个，所以我们可以近似的认为，在getProxy这个方法上，ProxyFactory的两个实现类的实现，并没有多大差别。</p><p>再看getInvoker方法，返回的依然是个AbstractProxyInvoker对象，但在重新的doInvoke方法中，调用的是Wrapper类的invokeMethod方法，而不是JdkProxyFactory中的用反射调用，这里是多了一个包装类的逻辑，其实这里非常像jdk动态代理和cglib动态代理之间的关系，jdk动态代理在最终方法调用时，是通过反射调用，但cglib在最终方法调用时，是通过一个fastClass机制调用，避免过多使用反射造成性能问题，我们可以来看下这个Wrapper类的生成过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private static Wrapper makeWrapper(Class&lt;?&gt; c) &#123;</span><br><span class="line">        StringBuilder c1 = new StringBuilder(&quot;public void setPropertyValue(Object o, String n, Object v)&#123; &quot;);</span><br><span class="line">        StringBuilder c2 = new StringBuilder(&quot;public Object getPropertyValue(Object o, String n)&#123; &quot;);</span><br><span class="line">        StringBuilder c3 = new StringBuilder(&quot;public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws &quot; + InvocationTargetException.class.getName() + &quot;&#123; &quot;);</span><br><span class="line"></span><br><span class="line">        c1.append(name).append(&quot; w; try&#123; w = ((&quot;).append(name).append(&quot;)$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;&quot;);</span><br><span class="line">        c2.append(name).append(&quot; w; try&#123; w = ((&quot;).append(name).append(&quot;)$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;&quot;);</span><br><span class="line">        c3.append(name).append(&quot; w; try&#123; w = ((&quot;).append(name).append(&quot;)$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;&quot;);</span><br><span class="line">        c1.append(&quot; throw new &quot; + NoSuchPropertyException.class.getName() + &quot;(\&quot;Not found property \\\&quot;\&quot;+$2+\&quot;\\\&quot; filed or setter method in class &quot; + c.getName() + &quot;.\&quot;); &#125;&quot;);</span><br><span class="line">        c2.append(&quot; throw new &quot; + NoSuchPropertyException.class.getName() + &quot;(\&quot;Not found property \\\&quot;\&quot;+$2+\&quot;\\\&quot; filed or setter method in class &quot; + c.getName() + &quot;.\&quot;); &#125;&quot;);</span><br><span class="line"></span><br><span class="line">        // make class</span><br><span class="line">        long id = WRAPPER_CLASS_COUNTER.getAndIncrement();</span><br><span class="line">        ClassGenerator cc = ClassGenerator.newInstance(cl);</span><br><span class="line">        cc.setClassName((Modifier.isPublic(c.getModifiers()) ? Wrapper.class.getName() : c.getName() + &quot;$sw&quot;) + id);</span><br><span class="line">        cc.setSuperClass(Wrapper.class);</span><br><span class="line"></span><br><span class="line">        cc.addDefaultConstructor();</span><br><span class="line">        cc.addField(&quot;public static String[] pns;&quot;); // property name array.</span><br><span class="line">        cc.addField(&quot;public static &quot; + Map.class.getName() + &quot; pts;&quot;); // property type map.</span><br><span class="line">        cc.addField(&quot;public static String[] mns;&quot;); // all method name array.</span><br><span class="line">        cc.addField(&quot;public static String[] dmns;&quot;); // declared method name array.</span><br><span class="line">        for (int i = 0, len = ms.size(); i &lt; len; i++)</span><br><span class="line">            cc.addField(&quot;public static Class[] mts&quot; + i + &quot;;&quot;);</span><br><span class="line"></span><br><span class="line">        cc.addMethod(&quot;public String[] getPropertyNames()&#123; return pns; &#125;&quot;);</span><br><span class="line">        cc.addMethod(&quot;public boolean hasProperty(String n)&#123; return pts.containsKey($1); &#125;&quot;);</span><br><span class="line">        cc.addMethod(&quot;public Class getPropertyType(String n)&#123; return (Class)pts.get($1); &#125;&quot;);</span><br><span class="line">        cc.addMethod(&quot;public String[] getMethodNames()&#123; return mns; &#125;&quot;);</span><br><span class="line">        cc.addMethod(&quot;public String[] getDeclaredMethodNames()&#123; return dmns; &#125;&quot;);</span><br><span class="line">        //省略代码        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到同样是通过Javassist来动态生成类，与其看生成的逻辑，还不如看下最终生成的类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Wrapper1 extends Wrapper &#123;</span><br><span class="line"></span><br><span class="line">    //省略代码</span><br><span class="line"></span><br><span class="line">    public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws java.lang.reflect.InvocationTargetException&#123;</span><br><span class="line">        com.alibaba.dubbo.demo.provider.DemoServiceImpl w;</span><br><span class="line">        try&#123;</span><br><span class="line">            w = ((com.alibaba.dubbo.demo.provider.DemoServiceImpl)o);</span><br><span class="line">        &#125;catch(Throwable e)&#123;</span><br><span class="line">            throw new IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        try&#123;</span><br><span class="line">            if( &quot;sayHello&quot;.equals( n )  &amp;&amp;  p.length == 1 ) &#123;</span><br><span class="line">                return w.sayHello((java.lang.String)v[0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch(Throwable e) &#123;</span><br><span class="line">            throw new java.lang.reflect.InvocationTargetException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new com.alibaba.dubbo.common.bytecode.NoSuchMethodException(&quot;Not found method \&quot;&quot;+n+&quot;\&quot; in class com.alibaba.dubbo.demo.provider.DemoServiceImpl.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到这里是通过直接调用的方式来调用目标方法，相比于JdkProxyFactory的反射调用，直接调用能带来更大的性能提升，因此JavassistProxyFactory也是dubbo的默认配置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;proxy层是dubbo架构中的第三层，在dubbo官网中的定义如下：&lt;br&gt;proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory&lt;br&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>《dubbo源码深度解析》之config配置层</title>
    <link href="http://wangzx.org/2018/04/18/dubbo-config/"/>
    <id>http://wangzx.org/2018/04/18/dubbo-config/</id>
    <published>2018-04-18T11:55:29.000Z</published>
    <updated>2018-05-18T08:19:44.668Z</updated>
    
    <content type="html"><![CDATA[<p>config层是dubbo架构中的第二层，第一层的service即是我们的业务层，因此我们从config层开始看，config层在官网中的解释如下:</p><blockquote><p>配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类<br><strong><a id="more"></a></strong></p></blockquote><h1 id="spring自定义标签"><a href="#spring自定义标签" class="headerlink" title="spring自定义标签"></a>spring自定义标签</h1><p>我们在通过xml文件配置dubbo时，使用了dubbo给我们提供的spring自定义标签，入口类在dubbo-config包下的DubboNamespaceHandler文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false));</span><br><span class="line">        registerBeanDefinitionParser(&quot;annotation&quot;, new DubboBeanDefinitionParser(AnnotationBean.class, true));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在xml中配置的标签，将会转换为如ApplicationConfig、RegistryConfig、ProtocolConfig、ServiceBean等一个个bean，xml到bean的过程，不是重点，我们稍微看下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) &#123;</span><br><span class="line">    RootBeanDefinition beanDefinition = new RootBeanDefinition();</span><br><span class="line">    beanDefinition.setBeanClass(beanClass);</span><br><span class="line">    beanDefinition.setLazyInit(false);</span><br><span class="line">    String id = element.getAttribute(&quot;id&quot;);</span><br><span class="line">    if ((id == null || id.length() == 0) &amp;&amp; required) &#123;</span><br><span class="line">        String generatedBeanName = element.getAttribute(&quot;name&quot;);</span><br><span class="line">        if (generatedBeanName == null || generatedBeanName.length() == 0) &#123;</span><br><span class="line">            if (ProtocolConfig.class.equals(beanClass)) &#123;</span><br><span class="line">                generatedBeanName = &quot;dubbo&quot;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                generatedBeanName = element.getAttribute(&quot;interface&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (generatedBeanName == null || generatedBeanName.length() == 0) &#123;</span><br><span class="line">            generatedBeanName = beanClass.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        id = generatedBeanName;</span><br><span class="line">        int counter = 2;</span><br><span class="line">        while (parserContext.getRegistry().containsBeanDefinition(id)) &#123;</span><br><span class="line">            id = generatedBeanName + (counter++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (id != null &amp;&amp; id.length() &gt; 0) &#123;</span><br><span class="line">        if (parserContext.getRegistry().containsBeanDefinition(id)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Duplicate spring bean id &quot; + id);</span><br><span class="line">        &#125;</span><br><span class="line">        parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);</span><br><span class="line">        beanDefinition.getPropertyValues().addPropertyValue(&quot;id&quot;, id);</span><br><span class="line">    &#125;</span><br><span class="line">    if (ProtocolConfig.class.equals(beanClass)) &#123;</span><br><span class="line">        for (String name : parserContext.getRegistry().getBeanDefinitionNames()) &#123;</span><br><span class="line">            BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);</span><br><span class="line">            PropertyValue property = definition.getPropertyValues().getPropertyValue(&quot;protocol&quot;);</span><br><span class="line">            if (property != null) &#123;</span><br><span class="line">                Object value = property.getValue();</span><br><span class="line">                if (value instanceof ProtocolConfig &amp;&amp; id.equals(((ProtocolConfig) value).getName())) &#123;</span><br><span class="line">                    definition.getPropertyValues().addPropertyValue(&quot;protocol&quot;, new RuntimeBeanReference(id));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (ServiceBean.class.equals(beanClass)) &#123;</span><br><span class="line">        String className = element.getAttribute(&quot;class&quot;);</span><br><span class="line">        if (className != null &amp;&amp; className.length() &gt; 0) &#123;</span><br><span class="line">            RootBeanDefinition classDefinition = new RootBeanDefinition();</span><br><span class="line">            classDefinition.setBeanClass(ReflectUtils.forName(className));</span><br><span class="line">            classDefinition.setLazyInit(false);</span><br><span class="line">            parseProperties(element.getChildNodes(), classDefinition);</span><br><span class="line">            beanDefinition.getPropertyValues().addPropertyValue(&quot;ref&quot;, new BeanDefinitionHolder(classDefinition, id + &quot;Impl&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (ProviderConfig.class.equals(beanClass)) &#123;</span><br><span class="line">        parseNested(element, parserContext, ServiceBean.class, true, &quot;service&quot;, &quot;provider&quot;, id, beanDefinition);</span><br><span class="line">    &#125; else if (ConsumerConfig.class.equals(beanClass)) &#123;</span><br><span class="line">        parseNested(element, parserContext, ReferenceBean.class, false, &quot;reference&quot;, &quot;consumer&quot;, id, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; props = new HashSet&lt;String&gt;();</span><br><span class="line">    ManagedMap parameters = null;</span><br><span class="line">    //省略部分代码</span><br><span class="line">    NamedNodeMap attributes = element.getAttributes();</span><br><span class="line">    int len = attributes.getLength();</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        Node node = attributes.item(i);</span><br><span class="line">        String name = node.getLocalName();</span><br><span class="line">        if (!props.contains(name)) &#123;</span><br><span class="line">            if (parameters == null) &#123;</span><br><span class="line">                parameters = new ManagedMap();</span><br><span class="line">            &#125;</span><br><span class="line">            String value = node.getNodeValue();</span><br><span class="line">            parameters.put(name, new TypedStringValue(value, String.class));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (parameters != null) &#123;</span><br><span class="line">        beanDefinition.getPropertyValues().addPropertyValue(&quot;parameters&quot;, parameters);</span><br><span class="line">    &#125;</span><br><span class="line">    return beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造BeanDefinition的过程并没有什么特殊，但由于dubbo把所有的解析过程都写在这个方法里，看上去难免杂乱一些，与其看BeanDefinition的解析过程，还不如看最终解析出了什么东西，在此之前先附上xml配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">       xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span><br><span class="line">http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span><br><span class="line">    &lt;dubbo:application name=&quot;demo-provider&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;</span><br><span class="line">    &lt;dubbo:registry address=&quot;192.168.32.145:2181&quot; protocol=&quot;zookeeper&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span><br><span class="line">    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 声明需要暴露的服务接口 --&gt;</span><br><span class="line">    &lt;bean id=&quot;demoService&quot; class=&quot;com.alibaba.dubbo.demo.provider.DemoServiceImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 和本地bean一样实现服务 --&gt;</span><br><span class="line">    &lt;dubbo:service interface=&quot;com.alibaba.dubbo.demo.DemoService&quot; ref=&quot;demoService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>ApplicationConfig:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;demo-provider&quot;</span><br><span class="line">version = null</span><br><span class="line">owner = null</span><br><span class="line">organization = null</span><br><span class="line">architecture = null</span><br><span class="line">environment = null</span><br><span class="line">compiler = null</span><br><span class="line">logger = null</span><br><span class="line">registries = null</span><br><span class="line">monitor = null</span><br><span class="line">isDefault = null</span><br><span class="line">id = &quot;demo-provider&quot; //自动把id设置为和name一样</span><br></pre></td></tr></table></figure></p><p>RegistryConfig:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">address = &quot;192.168.32.145:2181&quot;</span><br><span class="line">username = null</span><br><span class="line">password = null</span><br><span class="line">port = null</span><br><span class="line">protocol = &quot;zookeeper&quot;</span><br><span class="line">transporter = null</span><br><span class="line">server = null</span><br><span class="line">client = null</span><br><span class="line">cluster = null</span><br><span class="line">group = null</span><br><span class="line">version = null</span><br><span class="line">timeout = null</span><br><span class="line">session = null</span><br><span class="line">file = null</span><br><span class="line">wait = null</span><br><span class="line">check = null</span><br><span class="line">dynamic = null</span><br><span class="line">register = null</span><br><span class="line">subscribe = null</span><br><span class="line">parameters = null</span><br><span class="line">isDefault = null</span><br><span class="line">id = &quot;com.alibaba.dubbo.config.RegistryConfig&quot; //自动设置了id</span><br></pre></td></tr></table></figure></p><p>ProtocolConfig：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;dubbo&quot;</span><br><span class="line">host = null</span><br><span class="line">port = &#123;Integer@1956&#125; &quot;20880&quot;</span><br><span class="line">contextpath = null</span><br><span class="line">threadpool = null</span><br><span class="line">threads = null</span><br><span class="line">iothreads = null</span><br><span class="line">queues = null</span><br><span class="line">accepts = null</span><br><span class="line">codec = null</span><br><span class="line">serialization = null</span><br><span class="line">charset = null</span><br><span class="line">payload = null</span><br><span class="line">buffer = null</span><br><span class="line">heartbeat = null</span><br><span class="line">accesslog = null</span><br><span class="line">transporter = null</span><br><span class="line">exchanger = null</span><br><span class="line">dispatcher = null</span><br><span class="line">networker = null</span><br><span class="line">server = null</span><br><span class="line">client = null</span><br><span class="line">telnet = null</span><br><span class="line">prompt = null</span><br><span class="line">status = null</span><br><span class="line">register = null</span><br><span class="line">parameters = null</span><br><span class="line">isDefault = null</span><br><span class="line">id = &quot;dubbo&quot; //自动把id设置为和name一样</span><br></pre></td></tr></table></figure></p><p>可以看到基本上就和我们在配置文件中看到的一样，当然，这是在最简单的配置下，如果有配置多注册中心，多protocol，配置method等，解析过程就稍微复杂一些。</p><h1 id="ServiceConfig"><a href="#ServiceConfig" class="headerlink" title="ServiceConfig"></a>ServiceConfig</h1><p>代码的入口在ServiceBean这个类中，这里有两个关键方法：afterPropertiesSet()和onApplicationEvent()，在初始化这个Bean的时候会调用afterPropertiesSet()方法，这个方法的主要作用，就是获取ApplicationConfig、RegistryConfig、ProtocolConfig等对象，注入到ServiceBean当中，已供ServiceBean在后续的服务暴露过程中使用。onApplicationEvent()方法会在spring初始化完成后调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void onApplicationEvent(ApplicationEvent event) &#123;</span><br><span class="line">        if (ContextRefreshedEvent.class.getName().equals(event.getClass().getName())) &#123;</span><br><span class="line">            if (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">                if (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(&quot;The service ready on spring started. service: &quot; + getInterface());</span><br><span class="line">                &#125;</span><br><span class="line">                export();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>export()方法在其父类ServiceConfig中，这个方法就做一些简单的检查后跳到doExport()方法，在这个方法中，除了一些检查设置外，还有一个填充默认配置的方法：appendProperties(this)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">protected static void appendProperties(AbstractConfig config) &#123;</span><br><span class="line">        if (config == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String prefix = &quot;dubbo.&quot; + getTagName(config.getClass()) + &quot;.&quot;;</span><br><span class="line">        Method[] methods = config.getClass().getMethods();</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String name = method.getName();</span><br><span class="line">                if (name.length() &gt; 3 &amp;&amp; name.startsWith(&quot;set&quot;) &amp;&amp; Modifier.isPublic(method.getModifiers())</span><br><span class="line">                        &amp;&amp; method.getParameterTypes().length == 1 &amp;&amp; isPrimitive(method.getParameterTypes()[0])) &#123;</span><br><span class="line">                    String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), &quot;-&quot;);</span><br><span class="line"></span><br><span class="line">                    String value = null;</span><br><span class="line">                    if (config.getId() != null &amp;&amp; config.getId().length() &gt; 0) &#123;</span><br><span class="line">                        String pn = prefix + config.getId() + &quot;.&quot; + property;</span><br><span class="line">                        value = System.getProperty(pn);</span><br><span class="line">                        if (!StringUtils.isBlank(value)) &#123;</span><br><span class="line">                            logger.info(&quot;Use System Property &quot; + pn + &quot; to config dubbo&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (value == null || value.length() == 0) &#123;</span><br><span class="line">                        String pn = prefix + property;</span><br><span class="line">                        value = System.getProperty(pn);</span><br><span class="line">                        if (!StringUtils.isBlank(value)) &#123;</span><br><span class="line">                            logger.info(&quot;Use System Property &quot; + pn + &quot; to config dubbo&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (value == null || value.length() == 0) &#123;</span><br><span class="line">                        Method getter;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            getter = config.getClass().getMethod(&quot;get&quot; + name.substring(3), new Class&lt;?&gt;[0]);</span><br><span class="line">                        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                getter = config.getClass().getMethod(&quot;is&quot; + name.substring(3), new Class&lt;?&gt;[0]);</span><br><span class="line">                            &#125; catch (NoSuchMethodException e2) &#123;</span><br><span class="line">                                getter = null;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (getter != null) &#123;</span><br><span class="line">                            if (getter.invoke(config, new Object[0]) == null) &#123;</span><br><span class="line">                                if (config.getId() != null &amp;&amp; config.getId().length() &gt; 0) &#123;</span><br><span class="line">                                    value = ConfigUtils.getProperty(prefix + config.getId() + &quot;.&quot; + property);</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (value == null || value.length() == 0) &#123;</span><br><span class="line">                                    value = ConfigUtils.getProperty(prefix + property);</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (value == null || value.length() == 0) &#123;</span><br><span class="line">                                    String legacyKey = legacyProperties.get(prefix + property);</span><br><span class="line">                                    if (legacyKey != null &amp;&amp; legacyKey.length() &gt; 0) &#123;</span><br><span class="line">                                        value = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey));</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (value != null &amp;&amp; value.length() &gt; 0) &#123;</span><br><span class="line">                        method.invoke(config, new Object[]&#123;convertPrimitive(method.getParameterTypes()[0], value)&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的主要作用，是从系统的环境变量、dubbo.properties中获取配置，注入到ApplicationConfig、RegistryConfig、ProtocolConfig等对象中，这也是dubbo默认参数的实现方式，可以将一些公共的配置，写在dubbo.properties中，dubbo会帮我们注入，由于我们没有使用dubbo.properties配置，因此这一轮检查和注入过后，配置没有发生变化，之后就到了正在开始暴露服务：doExportUrls():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void doExportUrls() &#123;</span><br><span class="line">        List&lt;URL&gt; registryURLs = loadRegistries(true);</span><br><span class="line">        for (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">            doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法首先进行了url的组装：loadRegistries(boolean provider)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;URL&gt; loadRegistries(boolean provider) &#123;</span><br><span class="line">        checkRegistry();</span><br><span class="line">        List&lt;URL&gt; registryList = new ArrayList&lt;URL&gt;();</span><br><span class="line">        if (registries != null &amp;&amp; registries.size() &gt; 0) &#123;</span><br><span class="line">            for (RegistryConfig config : registries) &#123;</span><br><span class="line">                String address = config.getAddress();</span><br><span class="line">                if (address == null || address.length() == 0) &#123;</span><br><span class="line">                    address = Constants.ANYHOST_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                String sysaddress = System.getProperty(&quot;dubbo.registry.address&quot;);</span><br><span class="line">                if (sysaddress != null &amp;&amp; sysaddress.length() &gt; 0) &#123;</span><br><span class="line">                    address = sysaddress;</span><br><span class="line">                &#125;</span><br><span class="line">                if (address != null &amp;&amp; address.length() &gt; 0</span><br><span class="line">                        &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123;</span><br><span class="line">                    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">                    appendParameters(map, application);</span><br><span class="line">                    appendParameters(map, config);</span><br><span class="line">                    map.put(&quot;path&quot;, RegistryService.class.getName());</span><br><span class="line">                    map.put(&quot;dubbo&quot;, Version.getVersion());</span><br><span class="line">                    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                    if (ConfigUtils.getPid() &gt; 0) &#123;</span><br><span class="line">                        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!map.containsKey(&quot;protocol&quot;)) &#123;</span><br><span class="line">                        if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(&quot;remote&quot;)) &#123;</span><br><span class="line">                            map.put(&quot;protocol&quot;, &quot;remote&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            map.put(&quot;protocol&quot;, &quot;dubbo&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map);</span><br><span class="line">                    for (URL url : urls) &#123;</span><br><span class="line">                        url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());</span><br><span class="line">                        url = url.setProtocol(Constants.REGISTRY_PROTOCOL);</span><br><span class="line">                        if ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true))</span><br><span class="line">                                || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, true))) &#123;</span><br><span class="line">                            registryList.add(url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return registryList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法分为2部分，第一部分组装map和address，第二部分根据map和address生成url，在第一部分中有个比较重要的方法：appendParameters()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">protected static void appendParameters(Map&lt;String, String&gt; parameters, Object config, String prefix) &#123;</span><br><span class="line">        if (config == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Method[] methods = config.getClass().getMethods();</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String name = method.getName();</span><br><span class="line">                if ((name.startsWith(&quot;get&quot;) || name.startsWith(&quot;is&quot;))</span><br><span class="line">                        &amp;&amp; !&quot;getClass&quot;.equals(name)</span><br><span class="line">                        &amp;&amp; Modifier.isPublic(method.getModifiers())</span><br><span class="line">                        &amp;&amp; method.getParameterTypes().length == 0</span><br><span class="line">                        &amp;&amp; isPrimitive(method.getReturnType())) &#123;</span><br><span class="line">                    Parameter parameter = method.getAnnotation(Parameter.class);</span><br><span class="line">                    if (method.getReturnType() == Object.class || parameter != null &amp;&amp; parameter.excluded()) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    int i = name.startsWith(&quot;get&quot;) ? 3 : 2;</span><br><span class="line">                    String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), &quot;.&quot;);</span><br><span class="line">                    String key;</span><br><span class="line">                    if (parameter != null &amp;&amp; parameter.key() != null &amp;&amp; parameter.key().length() &gt; 0) &#123;</span><br><span class="line">                        key = parameter.key();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        key = prop;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Object value = method.invoke(config, new Object[0]);</span><br><span class="line">                    String str = String.valueOf(value).trim();</span><br><span class="line">                    if (value != null &amp;&amp; str.length() &gt; 0) &#123;</span><br><span class="line">                        if (parameter != null &amp;&amp; parameter.escaped()) &#123;</span><br><span class="line">                            str = URL.encode(str);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (parameter != null &amp;&amp; parameter.append()) &#123;</span><br><span class="line">                            String pre = (String) parameters.get(Constants.DEFAULT_KEY + &quot;.&quot; + key);</span><br><span class="line">                            if (pre != null &amp;&amp; pre.length() &gt; 0) &#123;</span><br><span class="line">                                str = pre + &quot;,&quot; + str;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pre = (String) parameters.get(key);</span><br><span class="line">                            if (pre != null &amp;&amp; pre.length() &gt; 0) &#123;</span><br><span class="line">                                str = pre + &quot;,&quot; + str;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (prefix != null &amp;&amp; prefix.length() &gt; 0) &#123;</span><br><span class="line">                            key = prefix + &quot;.&quot; + key;</span><br><span class="line">                        &#125;</span><br><span class="line">                        parameters.put(key, str);</span><br><span class="line">                    &#125; else if (parameter != null &amp;&amp; parameter.required()) &#123;</span><br><span class="line">                        throw new IllegalStateException(config.getClass().getSimpleName() + &quot;.&quot; + key + &quot; == null&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (&quot;getParameters&quot;.equals(name)</span><br><span class="line">                        &amp;&amp; Modifier.isPublic(method.getModifiers())</span><br><span class="line">                        &amp;&amp; method.getParameterTypes().length == 0</span><br><span class="line">                        &amp;&amp; method.getReturnType() == Map.class) &#123;</span><br><span class="line">                    Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) method.invoke(config, new Object[0]);</span><br><span class="line">                    if (map != null &amp;&amp; map.size() &gt; 0) &#123;</span><br><span class="line">                        String pre = (prefix != null &amp;&amp; prefix.length() &gt; 0 ? prefix + &quot;.&quot; : &quot;&quot;);</span><br><span class="line">                        for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">                            parameters.put(pre + entry.getKey().replace(&apos;-&apos;, &apos;.&apos;), entry.getValue());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new IllegalStateException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的作用如下：遍历传进来的config对象的所有方法，如果是get或is开头，就调用该方法，如果返回值不为空，就存入map中，存入的key跟该方法是否有@Parameter注解有关，如果有，则以这个注解指定的key作为key值。</p><p>最终收集到的map如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 = &#123;HashMap$Entry@1722&#125; &quot;timestamp&quot; -&gt; &quot;1526381630841&quot;</span><br><span class="line">1 = &#123;HashMap$Entry@1723&#125; &quot;dubbo&quot; -&gt; &quot;2.0.0&quot;</span><br><span class="line">2 = &#123;HashMap$Entry@1724&#125; &quot;protocol&quot; -&gt; &quot;zookeeper&quot;</span><br><span class="line">3 = &#123;HashMap$Entry@1725&#125; &quot;application&quot; -&gt; &quot;demo-provider&quot;</span><br><span class="line">4 = &#123;HashMap$Entry@1726&#125; &quot;path&quot; -&gt; &quot;com.alibaba.dubbo.registry.RegistryService&quot;</span><br><span class="line">5 = &#123;HashMap$Entry@1727&#125; &quot;pid&quot; -&gt; &quot;1448&quot;</span><br></pre></td></tr></table></figure></p><p>然后调用UrlUtils.parseURLs(address, map)方法组装url，这个方法就是一些拼装逻辑，与其去看它如何拼装，不如看下最终拼装的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper://192.168.32.145:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.0&amp;pid=1448&amp;registry=zookeeper&amp;timestamp=1526381630841</span><br></pre></td></tr></table></figure><p>url拼装完成后，调用doExportUrlsFor1Protocol(protocolConfig, registryURLs)方法，这个方法是Config层的最后一个方法，这个方法过后将转到Registry层,由于这个方法太长，因此这里分为为2个部分进行说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123;</span><br><span class="line">        //省略代码</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">        if (anyhost) &#123;</span><br><span class="line">            map.put(Constants.ANYHOST_KEY, &quot;true&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">        map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());</span><br><span class="line">        map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        if (ConfigUtils.getPid() &gt; 0) &#123;</span><br><span class="line">            map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">        &#125;</span><br><span class="line">        appendParameters(map, application);</span><br><span class="line">        appendParameters(map, module);</span><br><span class="line">        appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">        appendParameters(map, protocolConfig);</span><br><span class="line">        appendParameters(map, this);</span><br><span class="line">        if (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">            map.put(&quot;generic&quot;, generic);</span><br><span class="line">            map.put(&quot;methods&quot;, Constants.ANY_VALUE);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">            if (revision != null &amp;&amp; revision.length() &gt; 0) &#123;</span><br><span class="line">                map.put(&quot;revision&quot;, revision);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">            if (methods.length == 0) &#123;</span><br><span class="line">                logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName());</span><br><span class="line">                map.put(&quot;methods&quot;, Constants.ANY_VALUE);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                map.put(&quot;methods&quot;, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">            if (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">                map.put(&quot;token&quot;, UUID.randomUUID().toString());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                map.put(&quot;token&quot;, token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;injvm&quot;.equals(protocolConfig.getName())) &#123;</span><br><span class="line">            protocolConfig.setRegister(false);</span><br><span class="line">            map.put(&quot;notify&quot;, &quot;false&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //省略第二部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的作用跟上面的方法一样，从各个config中，获取信息组装到map中，最后的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 = &#123;HashMap$Entry@2469&#125; &quot;methods&quot; -&gt; &quot;sayHello&quot;</span><br><span class="line">1 = &#123;HashMap$Entry@2204&#125; &quot;generic&quot; -&gt; &quot;false&quot;</span><br><span class="line">2 = &#123;HashMap$Entry@2205&#125; &quot;timestamp&quot; -&gt; &quot;1526382333491&quot;</span><br><span class="line">3 = &#123;HashMap$Entry@2206&#125; &quot;dubbo&quot; -&gt; &quot;2.0.0&quot;</span><br><span class="line">4 = &#123;HashMap$Entry@2207&#125; &quot;application&quot; -&gt; &quot;demo-provider&quot;</span><br><span class="line">5 = &#123;HashMap$Entry@2208&#125; &quot;side&quot; -&gt; &quot;provider&quot;</span><br><span class="line">6 = &#123;HashMap$Entry@2209&#125; &quot;pid&quot; -&gt; &quot;1448&quot;</span><br><span class="line">7 = &#123;HashMap$Entry@2210&#125; &quot;interface&quot; -&gt; &quot;com.alibaba.dubbo.demo.DemoService&quot;</span><br><span class="line">8 = &#123;HashMap$Entry@2211&#125; &quot;anyhost&quot; -&gt; &quot;true&quot;</span><br></pre></td></tr></table></figure></p><p>第二部分代码，根据这个map，组装url，然后进行export：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123;</span><br><span class="line">        //省略第一部分代码</span><br><span class="line">        // 导出服务</span><br><span class="line">        String contextPath = protocolConfig.getContextpath();</span><br><span class="line">        if ((contextPath == null || contextPath.length() == 0) &amp;&amp; provider != null) &#123;</span><br><span class="line">            contextPath = provider.getContextpath();</span><br><span class="line">        &#125;</span><br><span class="line">        URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? &quot;&quot; : contextPath + &quot;/&quot;) + path, map);</span><br><span class="line"></span><br><span class="line">        if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">            url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                    .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line">        //配置为none不暴露</span><br><span class="line">        if (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line"></span><br><span class="line">            //配置不是remote的情况下做本地暴露 (配置为remote，则表示只暴露远程服务)</span><br><span class="line">            if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                exportLocal(url);</span><br><span class="line">            &#125;</span><br><span class="line">            //如果配置不是local则暴露为远程服务.(配置为local，则表示只暴露本地服务)</span><br><span class="line">            if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                if (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() + &quot; to url &quot; + url);</span><br><span class="line">                &#125;</span><br><span class="line">                if (registryURLs != null &amp;&amp; registryURLs.size() &gt; 0</span><br><span class="line">                        &amp;&amp; url.getParameter(&quot;register&quot;, true)) &#123;</span><br><span class="line">                    for (URL registryURL : registryURLs) &#123;</span><br><span class="line">                        url = url.addParameterIfAbsent(&quot;dynamic&quot;, registryURL.getParameter(&quot;dynamic&quot;));</span><br><span class="line">                        URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line">                        if (monitorUrl != null) &#123;</span><br><span class="line">                            url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(&quot;Register dubbo service &quot; + interfaceClass.getName() + &quot; url &quot; + url + &quot; to registry &quot; + registryURL);</span><br><span class="line">                        &#125;</span><br><span class="line">                        Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line"></span><br><span class="line">                        Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br><span class="line">                        exporters.add(exporter);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line"></span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.urls.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先进行了一次url组装，组装结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo://192.168.252.169:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=1448&amp;side=provider&amp;timestamp=1526382333491</span><br></pre></td></tr></table></figure></p><p>然后判断url中的scope属性的值，如果是remote，则值进行远程暴露，如果是local，则只进行本地暴露，本地暴露和远程暴露的逻辑差不多，首先是获取一个Invoker，然后进行export，export完成后存入List<exporter<?>&gt; exporters这个对象中，这里的Invoker，是dubbo中贯穿全文的对象，我们将在新的篇幅中来说明这个对象。</exporter<?></p><h1 id="ReferenceConfig"><a href="#ReferenceConfig" class="headerlink" title="ReferenceConfig"></a>ReferenceConfig</h1><p>ReferenceConfig的入口在ReferenceBean的getObject()方法中，这个方法返回的即是com.alibaba.dubbo.demo.DemoService这个接口的代理对象，跟ServiceBean相同的是，ReferenceBean也进行过afterPropertiesSet()方法，进行config注入，我们来看下getObject的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">private void init() &#123;</span><br><span class="line">        // 获取消费者全局配置</span><br><span class="line">        checkDefault();</span><br><span class="line">        appendProperties(this);</span><br><span class="line">        checkApplication();</span><br><span class="line">        checkStubAndMock(interfaceClass);</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; attributes = new HashMap&lt;Object, Object&gt;();</span><br><span class="line">        map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);</span><br><span class="line">        map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());</span><br><span class="line">        map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        if (ConfigUtils.getPid() &gt; 0) &#123;</span><br><span class="line">            map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (!isGeneric()) &#123;</span><br><span class="line">            String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">            if (revision != null &amp;&amp; revision.length() &gt; 0) &#123;</span><br><span class="line">                map.put(&quot;revision&quot;, revision);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">            if (methods.length == 0) &#123;</span><br><span class="line">                logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName());</span><br><span class="line">                map.put(&quot;methods&quot;, Constants.ANY_VALUE);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                map.put(&quot;methods&quot;, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(Constants.INTERFACE_KEY, interfaceName);</span><br><span class="line">        appendParameters(map, application);</span><br><span class="line">        appendParameters(map, module);</span><br><span class="line">        appendParameters(map, consumer, Constants.DEFAULT_KEY);</span><br><span class="line">        appendParameters(map, this);</span><br><span class="line">        String prifix = StringUtils.getServiceKey(map);</span><br><span class="line">        if (methods != null &amp;&amp; methods.size() &gt; 0) &#123;</span><br><span class="line">            for (MethodConfig method : methods) &#123;</span><br><span class="line">                appendParameters(map, method, method.getName());</span><br><span class="line">                String retryKey = method.getName() + &quot;.retry&quot;;</span><br><span class="line">                if (map.containsKey(retryKey)) &#123;</span><br><span class="line">                    String retryValue = map.remove(retryKey);</span><br><span class="line">                    if (&quot;false&quot;.equals(retryValue)) &#123;</span><br><span class="line">                        map.put(method.getName() + &quot;.retries&quot;, &quot;0&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                appendAttributes(attributes, method, prifix + &quot;.&quot; + method.getName());</span><br><span class="line">                checkAndConvertImplicitConfig(method, map, attributes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //attributes通过系统context进行存储.</span><br><span class="line">        StaticContext.getSystemContext().putAll(attributes);</span><br><span class="line">        ref = createProxy(map);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法跟ServiceConfig中的非常相似，都是通过appendParameters()方法获取各个config的值，存入到map中，最终map的值如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 = &#123;HashMap$Entry@1819&#125; &quot;methods&quot; -&gt; &quot;sayHello&quot;</span><br><span class="line">1 = &#123;HashMap$Entry@1820&#125; &quot;timestamp&quot; -&gt; &quot;1526384412044&quot;</span><br><span class="line">2 = &#123;HashMap$Entry@1821&#125; &quot;dubbo&quot; -&gt; &quot;2.0.0&quot;</span><br><span class="line">3 = &#123;HashMap$Entry@1822&#125; &quot;application&quot; -&gt; &quot;demo-consumer&quot;</span><br><span class="line">4 = &#123;HashMap$Entry@1823&#125; &quot;check&quot; -&gt; &quot;false&quot;</span><br><span class="line">5 = &#123;HashMap$Entry@1824&#125; &quot;side&quot; -&gt; &quot;consumer&quot;</span><br><span class="line">6 = &#123;HashMap$Entry@1825&#125; &quot;pid&quot; -&gt; &quot;6564&quot;</span><br><span class="line">7 = &#123;HashMap$Entry@1826&#125; &quot;interface&quot; -&gt; &quot;com.alibaba.dubbo.demo.DemoService&quot;</span><br></pre></td></tr></table></figure></p><p>然后根据这个map，创建代理对象：createProxy(map)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private T createProxy(Map&lt;String, String&gt; map) &#123;</span><br><span class="line">    //省略代码</span><br><span class="line">    List&lt;URL&gt; us = loadRegistries(false);</span><br><span class="line">    if (us != null &amp;&amp; us.size() &gt; 0) &#123;</span><br><span class="line">        for (URL u : us) &#123;</span><br><span class="line">            URL monitorUrl = loadMonitor(u);</span><br><span class="line">            if (monitorUrl != null) &#123;</span><br><span class="line">                map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">            &#125;</span><br><span class="line">            urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    invoker = refprotocol.refer(interfaceClass, urls.get(0));</span><br><span class="line">    //省略代码</span><br><span class="line">    return (T) proxyFactory.getProxy(invoker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先进行了一次url拼装，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry://192.168.32.145:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&amp;dubbo=2.0.0&amp;pid=7780&amp;refer=application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D7780%26side%3Dconsumer%26timestamp%3D1526384969049&amp;registry=zookeeper&amp;timestamp=1526384970818</span><br></pre></td></tr></table></figure></p><p>其中，关键的部分在refer=后面的部分，经过url解码后得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application=demo-consumer&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=7780&amp;side=consumer&amp;timestamp=1526384969049&amp;registry=zookeeper&amp;timestamp=1526384970818</span><br></pre></td></tr></table></figure></p><p>这里包含了所需要的对象的各个信息，Protocol层将根据这个信息，返回对应的invoker，获取到invoker之后，就可以通过Proxy层获取到代理对象，获取代理对象的内容将在下一节Proxy层中讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;config层是dubbo架构中的第二层，第一层的service即是我们的业务层，因此我们从config层开始看，config层在官网中的解释如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类&lt;br&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>《dubbo源码深度解析》之dubbo扩展点加载机制</title>
    <link href="http://wangzx.org/2018/04/15/dubbo-spi/"/>
    <id>http://wangzx.org/2018/04/15/dubbo-spi/</id>
    <published>2018-04-15T07:22:15.000Z</published>
    <updated>2018-05-18T08:19:25.851Z</updated>
    
    <content type="html"><![CDATA[<p>dubbo的扩展点加载机制是dubbo的内核，是贯穿整个dubbo的设计思想，在dubbo的官方文档中，也是将扩展点加载机制放在第一篇幅，要想看懂dubbo的源码，首先要看懂dubbo的扩展点加载机制。本章会从java spi的例子开始，到dubbo spi的例子，然后到分析源码，帮助读者看懂dubbo的扩展点加载机制。</p><p><strong><a id="more"></a></strong></p><h1 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h1><h2 id="java-spi"><a href="#java-spi" class="headerlink" title="java spi"></a>java spi</h2><h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Operate &#123;</span><br><span class="line">    double count(double c1,double c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类1"><a href="#实现类1" class="headerlink" title="实现类1"></a>实现类1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import com.example.java_spi.spi.Operate;</span><br><span class="line"></span><br><span class="line">public class AddOperate implements Operate &#123;</span><br><span class="line"></span><br><span class="line">    public double count(double c1,double c2) &#123;</span><br><span class="line">        return c1 + c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类2"><a href="#实现类2" class="headerlink" title="实现类2"></a>实现类2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import com.example.java_spi.spi.Operate;</span><br><span class="line"></span><br><span class="line">public class DelOperate implements Operate &#123;</span><br><span class="line">    public double count(double c1,double c2) &#123;</span><br><span class="line">        return c1 - c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="META-INF文件"><a href="#META-INF文件" class="headerlink" title="META-INF文件"></a>META-INF文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.example.java_spi.impl.AddOperate</span><br><span class="line">com.example.java_spi.impl.DelOperate</span><br></pre></td></tr></table></figure><p>文件路径：META-INF/services/com.example.java_spi.spi.Operate</p><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import com.example.java_spi.spi.Operate;</span><br><span class="line">import java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ServiceLoader&lt;Operate&gt; loaders = ServiceLoader.load(Operate.class);</span><br><span class="line">        for (Operate d : loaders) &#123;</span><br><span class="line">            double res = d.count(2,1);</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.0</span><br><span class="line">1.0</span><br></pre></td></tr></table></figure><p>可以看到java spi会加载所有的扩展点，且功能比较简单，没有apo ioc等功能</p><h2 id="dubbo-spi"><a href="#dubbo-spi" class="headerlink" title="dubbo spi"></a>dubbo spi</h2><h3 id="接口类-1"><a href="#接口类-1" class="headerlink" title="接口类"></a>接口类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.alibaba.dubbo.common.extension.Adaptive;</span><br><span class="line">import com.alibaba.dubbo.common.extension.SPI;</span><br><span class="line"></span><br><span class="line">@SPI</span><br><span class="line">public interface Operate &#123;</span><br><span class="line">    @Adaptive</span><br><span class="line">    double count(URL url,double c1,double c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类1-1"><a href="#实现类1-1" class="headerlink" title="实现类1"></a>实现类1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.example.dubbo_spi.spi.Operate;</span><br><span class="line"></span><br><span class="line">public class AddOperate implements Operate &#123;</span><br><span class="line"></span><br><span class="line">    public double count(URL url,double c1,double c2) &#123;</span><br><span class="line">        return c1 + c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类2-1"><a href="#实现类2-1" class="headerlink" title="实现类2"></a>实现类2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.example.dubbo_spi.spi.Operate;</span><br><span class="line"></span><br><span class="line">public class DelOperate implements Operate &#123;</span><br><span class="line">    public double count(URL url,double c1,double c2) &#123;</span><br><span class="line">        return c1 - c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="META-INF文件-1"><a href="#META-INF文件-1" class="headerlink" title="META-INF文件"></a>META-INF文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add=com.example.dubbo_spi.impl.AddOperate</span><br><span class="line">del=com.example.dubbo_spi.impl.DelOperate</span><br></pre></td></tr></table></figure><p>文件路径：META-INF/dubbo/com.example.dubbo_spi.spi.Operate</p><h3 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">import com.example.dubbo_spi.spi.Operate;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Main</span><br><span class="line">&#123;</span><br><span class="line">    public static void main( String[] args )</span><br><span class="line">    &#123;</span><br><span class="line">        Operate p = ExtensionLoader.getExtensionLoader(Operate.class).getAdaptiveExtension();</span><br><span class="line">        Map paramMap = new HashMap();</span><br><span class="line">        paramMap.put(&quot;operate&quot;,&quot;add&quot;);</span><br><span class="line">        URL url = new URL(&quot;&quot;,&quot;&quot;,20880,paramMap);</span><br><span class="line">        double res = p.count(url,2,1);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.0</span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这个是dubbo spi最简单的一个例子，但也可以看出要比java 的spi要复杂的多。</p><p>首先从接口类看，类上要加一个注解：@SPI，否则会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Extension type(interface com.example.dubbo_spi.spi.Operate) is not extension, because WITHOUT @SPI Annotation!</span><br></pre></td></tr></table></figure></p><p>我们会在后面的源码解析中，分析出这些报错的原因及代码位置。</p><p>第二、接口方法至少一个要有@Adaptive注解，否则会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: fail to create adaptive instance: java.lang.IllegalStateException: Can not create adaptive extenstion interface com.example.dubbo_spi.spi.Operate, cause: No adaptive method on extension com.example.dubbo_spi.spi.Operate, refuse to create the adaptive class!</span><br></pre></td></tr></table></figure></p><p>第三、注明@Adaptive的方法的参数中，必须要有URL类型的参数，或者参数的属性中包含URL类型的属性，否则会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: fail to create adaptive instance: java.lang.IllegalStateException: Can not create adaptive extenstion interface com.example.dubbo_spi.spi.Operate, cause: fail to create adative class for interface com.example.dubbo_spi.spi.Operate: not found url parameter or url attribute in parameters of method count</span><br></pre></td></tr></table></figure></p><p>第四、META-INF文件中要指定key，如add=com.xxx.AddOperate,不指定不会报错，但会生成一个默认的key，比如AddOperate的默认key就是add，这个key，将会在url中用到。</p><p>第五、测试类中的URL对象要有paramMap，并且这个map中要包含一个key，就是接口类的方法中，有注明@Adaptive的方法，这个注解有个属性，如果指定，这这里的url的key，就是指定的这个，如果不指定，则这里url的key就是接口类的类名（驼峰转”.”,如SayHello的默认key是“say.hello”），本案例中没有指定，因此这里的key，应该是operate，因此需指定operate及其值，否则会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Fail to get extension(com.example.dubbo_spi.spi.Operate) name from url() use keys([operate])</span><br></pre></td></tr></table></figure></p><p>到这里会难免有疑问，dubbo为什么要指定这么多奇奇怪怪的规则，我们来看测试类中Operate p的实际对象，通过源码分析可以取到代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.example.dubbo_spi.spi;</span><br><span class="line">        import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">public class Operate$Adpative implements com.example.dubbo_spi.spi.Operate &#123;</span><br><span class="line">    public double count(com.alibaba.dubbo.common.URL arg0, double arg1, double arg2) &#123;</span><br><span class="line">        if (arg0 == null) throw new IllegalArgumentException(&quot;url == null&quot;);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(&quot;operate&quot;);</span><br><span class="line">        if(extName == null) throw new IllegalStateException(&quot;Fail to get extension(com.example.dubbo_spi.spi.Operate) name from url(&quot; + url.toString() + &quot;) use keys([operate])&quot;);</span><br><span class="line">        com.example.dubbo_spi.spi.Operate extension = (com.example.dubbo_spi.spi.Operate)ExtensionLoader.getExtensionLoader(com.example.dubbo_spi.spi.Operate.class).getExtension(extName);</span><br><span class="line">        return extension.count(arg0, arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主要代码是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader.getExtensionLoader(com.example.dubbo_spi.spi.Operate.class).getExtension(extName);</span><br></pre></td></tr></table></figure></p><p>这里的extName就是add，通过这行代码取到的对象就是AddOperate的实例，到这里完成了最简单的dubbo spi的调用。</p><h3 id="dubbo-spi之aop"><a href="#dubbo-spi之aop" class="headerlink" title="dubbo spi之aop"></a>dubbo spi之aop</h3><p>dubbo spi可以实现类似spring的aop功能，我们需要先创建一个OperateWrapper类，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.example.dubbo_spi.spi.Operate;</span><br><span class="line"></span><br><span class="line">public class OperateWrapper implements Operate &#123;</span><br><span class="line"></span><br><span class="line">    private Operate operate;</span><br><span class="line"></span><br><span class="line">    public OperateWrapper(Operate operate) &#123;</span><br><span class="line">        this.operate = operate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double count(URL url,double c1,double c2) &#123;</span><br><span class="line">        System.out.println(&quot;==before==&quot;);</span><br><span class="line">        double result = this.operate.count(url,c1,c2);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        System.out.println(&quot;==after==&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==before==</span><br><span class="line">3.0</span><br><span class="line">==after==</span><br></pre></td></tr></table></figure></p><p>OperateWrapper也需要实现Operate接口，并且在构造方法中，需要有Operate这个接口参数，这样的类，dubbo的扩展点加载机制会认为它是一个代理类，用于实现aop的功能，这种包装类可以有多个，会按照在META-INF中的顺序排下来</p><h3 id="dubbo-spi之ioc"><a href="#dubbo-spi之ioc" class="headerlink" title="dubbo spi之ioc"></a>dubbo spi之ioc</h3><p>首先我们需要如法炮制创建一个SayHello接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.alibaba.dubbo.common.extension.Adaptive;</span><br><span class="line">import com.alibaba.dubbo.common.extension.SPI;</span><br><span class="line"></span><br><span class="line">@SPI</span><br><span class="line">public interface SayHello &#123;</span><br><span class="line">    @Adaptive</span><br><span class="line">    void say(URL url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后再创建一个实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.example.dubbo_spi.spi.SayHello;</span><br><span class="line"></span><br><span class="line">public class ChineseSayHello implements SayHello &#123;</span><br><span class="line">    public void say(URL url) &#123;</span><br><span class="line">        System.out.println(&quot;你好！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加META-INF文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chinese=com.example.dubbo_spi.impl.ChineseSayHello</span><br></pre></td></tr></table></figure></p><p>然后修改AddOperate代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.example.dubbo_spi.spi.Operate;</span><br><span class="line">import com.example.dubbo_spi.spi.SayHello;</span><br><span class="line"></span><br><span class="line">public class AddOperate implements Operate &#123;</span><br><span class="line"></span><br><span class="line">    private SayHello sayHello;</span><br><span class="line"></span><br><span class="line">    public SayHello getSayHello() &#123;</span><br><span class="line">        return sayHello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSayHello(SayHello sayHello) &#123;</span><br><span class="line">        this.sayHello = sayHello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double count(URL url, double c1, double c2) &#123;</span><br><span class="line">        sayHello.say(url);</span><br><span class="line">        return c1 + c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后在测试类的paramMap中加上say.hello的key和value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paramMap.put(&quot;say.hello&quot;,&quot;chinese&quot;);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">==before==</span><br><span class="line">你好！</span><br><span class="line">3.0</span><br><span class="line">==after==</span><br></pre></td></tr></table></figure></p><p>这里的关键代码，在ExtensionLoader的injectExtension方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private T injectExtension(T instance) &#123;</span><br><span class="line">        for (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">            if (method.getName().startsWith(&quot;set&quot;)</span><br><span class="line">                    &amp;&amp; method.getParameterTypes().length == 1</span><br><span class="line">                    &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                Class&lt;?&gt; pt = method.getParameterTypes()[0];</span><br><span class="line">                String property = method.getName().length() &gt; 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : &quot;&quot;;</span><br><span class="line">                Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                if (object != null) &#123;</span><br><span class="line">                    method.invoke(instance, object);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>代码做了适当精简，主要逻辑是遍历目标类的方法，如果是set开头，如setSayHello，那就去找sayHello有没有这个对象，如果有，就通过set方法注入，问题是怎么找sayHello这个对象？答案是通过objectFactory的getExtension方法来找，这是个关键对象，后面会再提到，这里插播一个知识点，dubbo的自动注入，需要提供属性的set方法，否则无法注入，spring通过xml配置的属性，同样要有set方法，否则也无法注入，但spring通过@Autowired配置的属性，可以没有set方法，那spring是怎么实现的呢？答案是通过setAccessible()方法改变属性的访问标志，从而达到修改属性的目的，即注入。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>代码入口在：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader.getExtensionLoader(Operate.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure></p><p>进入getExtensionLoader方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) &#123;</span><br><span class="line">        ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        if (loader == null) &#123;</span><br><span class="line">            EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">            loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        &#125;</span><br><span class="line">        return loader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里有个关键对象：</p><blockquote><p>ConcurrentMap<class<?>, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS;</class<?></p></blockquote><p>这是所有ExtensionLoader的缓存对象，获取ExtensionLoader时，先从缓存对象中取，如果没有，再new一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private ExtensionLoader(Class&lt;?&gt; type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">        objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里又有一个关键对象：</p><blockquote><p>ExtensionFactory objectFactory;</p></blockquote><p>objectFactory只有一个作用，就是在自动注入的时候用于寻找扩展对象，由于objectFactory的初始化过程就是本章内容，内容重复，因此略过，new完后存入EXTENSION_LOADERS缓存对象，getExtensionLoader的过程结束。</p><p>紧接着进入getAdaptiveExtension()的过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public T getAdaptiveExtension() &#123;</span><br><span class="line">        Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = createAdaptiveExtension();</span><br><span class="line">            cachedAdaptiveInstance.set(instance);</span><br><span class="line">        &#125;</span><br><span class="line">        return (T) instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里有个关键对象：</p><blockquote><p>Holder<object> cachedAdaptiveInstance</object></p></blockquote><p>先从这个缓存对象中取，如果没有，开始createAdaptiveExtension：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private T createAdaptiveExtension() &#123;</span><br><span class="line">    return injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有两个关键的方法，1是getAdaptiveExtensionClass，2是injectExtension，顾名思义，1方法是获得AdaptiveExtensionClass的Class对象，2方法是进行注入。先来看getAdaptiveExtensionClass方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        if (cachedAdaptiveClass != null) &#123;</span><br><span class="line">            return cachedAdaptiveClass;</span><br><span class="line">        &#125;</span><br><span class="line">        return cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先进行了getExtensionClasses方法，即获得该接口的所有扩展对象，即在META-INF所罗列出的所有的实现类，在这实现类中，如果包含有Adaptive对象，则第三行的cachedAdaptiveClass就不为空，先来看getExtensionClasses方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">        if (classes == null) &#123;</span><br><span class="line">            synchronized (cachedClasses) &#123;</span><br><span class="line">                classes = cachedClasses.get();</span><br><span class="line">                if (classes == null) &#123;</span><br><span class="line">                    //关键代码</span><br><span class="line">                    classes = loadExtensionClasses();</span><br><span class="line">                    cachedClasses.set(classes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return classes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里有个关键对象：</p><blockquote><p>Holder<map<string, class<?="">&gt;&gt; cachedClasses</map<string,></p></blockquote><p>用于存储该接口的所有扩展对象的Class对象，做一些缓存校验后进入loadExtensionClasses方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = new HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">        loadFile(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br><span class="line">        loadFile(extensionClasses, DUBBO_DIRECTORY);</span><br><span class="line">        loadFile(extensionClasses, SERVICES_DIRECTORY);</span><br><span class="line">        return extensionClasses;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里的extensionClasses在加载完所有的扩展对象后，就会返回存赋值给刚刚的cachedClasses对象，可以看到dubbo会从三个第三加载扩展对象：</p><ul><li>META-INF/dubbo/internal/</li><li>META-INF/dubbo/</li><li>META-INF/services/<br>先进入loadFile方法查看具体怎么加载：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private void loadFile(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir) &#123;</span><br><span class="line">        String fileName = dir + type.getName();</span><br><span class="line">        //省略读取文件代码</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(line, true, classLoader);</span><br><span class="line">        if (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">            if (cachedAdaptiveClass == null) &#123;</span><br><span class="line">                cachedAdaptiveClass = clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                clazz.getConstructor(type);</span><br><span class="line">                Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">                if (wrappers == null) &#123;</span><br><span class="line">                    cachedWrapperClasses = new ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">                    wrappers = cachedWrapperClasses;</span><br><span class="line">                &#125;</span><br><span class="line">                wrappers.add(clazz);</span><br><span class="line">            &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                clazz.getConstructor();</span><br><span class="line">                //省略name为空情况的代码</span><br><span class="line">                String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">                if (names != null &amp;&amp; names.length &gt; 0) &#123;</span><br><span class="line">                    Activate activate = clazz.getAnnotation(Activate.class);</span><br><span class="line">                    if (activate != null) &#123;</span><br><span class="line">                        cachedActivates.put(names[0], activate);</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (String n : names) &#123;</span><br><span class="line">                        if (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">                            cachedNames.put(clazz, n);</span><br><span class="line">                        &#125;</span><br><span class="line">                        Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">                        if (c == null) &#123;</span><br><span class="line">                            extensionClasses.put(n, clazz);</span><br><span class="line">                        &#125; else if (c != clazz) &#123;</span><br><span class="line">                            throw new IllegalStateException(&quot;Duplicate extension &quot; + type.getName() + &quot; name &quot; + n + &quot; on &quot; + c.getName() + &quot; and &quot; + clazz.getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>代码省略了循环读取META-INF文件的代码，每读取到一行后，就会进行解析，解析的过程有三种情况：</p><ul><li>这个扩展类有@Adaptive注解</li><li>这个扩展类的构造方法包含这个接口</li><li>其他</li></ul><p>对于第一种情况，会把这个扩展对象缓存进cachedAdaptiveClass这个对象，这个对象即是Adaptive对象，意思是如果扩展类中已经有了Adaptive对象，那就不用自动生成，直接用这个，否则需要动态生成一个Adaptive对象。</p><p>对于第二种情况，会把这个扩展对象缓存进cachedWrapperClasses这个对象，这个对象是个set，可以存放多个，这种情况的意思是这个扩展类是个包装对象，用于实现aop</p><p>第三种情况，会缓存进extensionClasses，这个对象稍后会赋值给cachedClasses对象，cachedClasses也是个关键对象，在后续getExtension(String name)方法中，就是在这个对象中寻找。</p><p>加载完成后，代码回到getAdaptiveExtensionClass方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        if (cachedAdaptiveClass != null) &#123;</span><br><span class="line">            return cachedAdaptiveClass;</span><br><span class="line">        &#125;</span><br><span class="line">        return cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>由于我们这个例子，没有一个扩展对象有@Adaptive注解，也就是说没有自己实现的Adaptive类，因此cachedAdaptiveClass这个对象为空，需要进行动态创建，动态创建的过程在很多框架代码中都有，比如jdk动态代理、cglib动态代理等，我们来看具体代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">        String code = createAdaptiveExtensionClassCode();</span><br><span class="line">        ClassLoader classLoader = findClassLoader();</span><br><span class="line">        com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">        return compiler.compile(code, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>createAdaptiveExtensionClassCode的代码都是逻辑代码，最后产生的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.example.dubbo_spi.spi;</span><br><span class="line">        import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">public class Operate$Adpative implements com.example.dubbo_spi.spi.Operate &#123;</span><br><span class="line">    public double count(com.alibaba.dubbo.common.URL arg0, double arg1, double arg2) &#123;</span><br><span class="line">        if (arg0 == null) throw new IllegalArgumentException(&quot;url == null&quot;);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(&quot;operate&quot;);</span><br><span class="line">        if(extName == null) throw new IllegalStateException(&quot;Fail to get extension(com.example.dubbo_spi.spi.Operate) name from url(&quot; + url.toString() + &quot;) use keys([operate])&quot;);</span><br><span class="line">        com.example.dubbo_spi.spi.Operate extension = (com.example.dubbo_spi.spi.Operate)ExtensionLoader.getExtensionLoader(com.example.dubbo_spi.spi.Operate.class).getExtension(extName);</span><br><span class="line">        return extension.count(arg0, arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>紧接着通过扩展点获取到具体的Compiler，这里为JavassistCompiler，将这段代码通过JavassistCompiler编译成Class，编译完成后，代码返回到createAdaptiveExtension方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private T createAdaptiveExtension() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Can not create adaptive extenstion &quot; + type + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>然后开始自动注入，即injectExtension方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private T injectExtension(T instance) &#123;</span><br><span class="line">        for (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">            if (method.getName().startsWith(&quot;set&quot;)</span><br><span class="line">                    &amp;&amp; method.getParameterTypes().length == 1</span><br><span class="line">                    &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                Class&lt;?&gt; pt = method.getParameterTypes()[0];</span><br><span class="line">                try &#123;</span><br><span class="line">                    String property = method.getName().length() &gt; 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : &quot;&quot;;</span><br><span class="line">                    Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                    if (object != null) &#123;</span><br><span class="line">                        method.invoke(instance, object);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    logger.error(&quot;fail to inject via method &quot; + method.getName()</span><br><span class="line">                            + &quot; of interface &quot; + type.getName() + &quot;: &quot; + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>主要的逻辑，是遍历这个Class的方法，如果以set开头，就去查找有没有这个set方法所需要的对象，比如有个setSayHello方法，那么就去查找有没有sayHello这个对象，查询方法就是通过objectFactory.getExtension(pt, property)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) &#123;</span><br><span class="line">        for (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            T extension = factory.getExtension(type, name);</span><br><span class="line">            if (extension != null) &#123;</span><br><span class="line">                return extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里的逻辑也很简单，遍历factories，即遍历所有的扩展点工厂，在每个工厂中寻找对象，这里有两个扩展点工厂：</p><ul><li>SpiExtensionFactory</li><li>SpringExtensionFactory</li></ul><p>代码分别如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) &#123;</span><br><span class="line">        if (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123;</span><br><span class="line">            ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type);</span><br><span class="line">            if (loader.getSupportedExtensions().size() &gt; 0) &#123;</span><br><span class="line">                return loader.getAdaptiveExtension();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) &#123;</span><br><span class="line">        for (ApplicationContext context : contexts) &#123;</span><br><span class="line">            if (context.containsBean(name)) &#123;</span><br><span class="line">                Object bean = context.getBean(name);</span><br><span class="line">                if (type.isInstance(bean)) &#123;</span><br><span class="line">                    return (T) bean;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果这些扩展点工厂返回的对象不为空，就可以进行注入，至此，完成了dubbo spi的代码，完！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dubbo的扩展点加载机制是dubbo的内核，是贯穿整个dubbo的设计思想，在dubbo的官方文档中，也是将扩展点加载机制放在第一篇幅，要想看懂dubbo的源码，首先要看懂dubbo的扩展点加载机制。本章会从java spi的例子开始，到dubbo spi的例子，然后到分析源码，帮助读者看懂dubbo的扩展点加载机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>cglib动态代理解析</title>
    <link href="http://wangzx.org/2018/03/30/cglib-proxy/"/>
    <id>http://wangzx.org/2018/03/30/cglib-proxy/</id>
    <published>2018-03-30T13:25:21.000Z</published>
    <updated>2018-05-18T08:25:55.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="目标类"><a href="#目标类" class="headerlink" title="目标类"></a>目标类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HelloService &#123;</span><br><span class="line">    </span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;=== hello ===&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a id="more"></a></strong></p><h3 id="拦截器类"><a href="#拦截器类" class="headerlink" title="拦截器类"></a>拦截器类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">public class MyMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args,MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;=== before ===&quot;);</span><br><span class="line">        Object object = proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(&quot;=== after ===&quot;);</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line">public class MyProxy&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public T getProxy(Class&lt;T&gt; tClass)&#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(tClass);</span><br><span class="line">        enhancer.setCallback(new MyMethodInterceptor());</span><br><span class="line">        return (T) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        MyProxy&lt;HelloService&gt; myProxy = new MyProxy();</span><br><span class="line">        HelloService helloService = myProxy.getProxy(HelloService.class);</span><br><span class="line">        helloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== before ===</span><br><span class="line">=== hello ===</span><br><span class="line">=== after ===</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>不同于jdk动态代理，cglib采用了继承目标类的方式来实现动态代理，因此cglib无法代理final类型的方法，相比比jdk动态代理，产生代理类，需要接口Class对象以及实现类的实例而言，cglib所需要的“原材料”更少，只需要目标类的Class对象即可实现动态代理。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>代码入口就在MyProxy类的enhancer.create()方法，很明显这个方法产生出来的就是目标类的子类，但我们的代码中并没有存在目标类的子类，cglib如何new出来？这里的原理与jdk动态代理类似，都是动态产生字节码技术，不过不同于jdk动态代理直接写二进制文件，cglib底层采用asm框架来产生字节码文件，效率上笔者认为是比jdk动态代理要慢一点，但这不是关键，因为一个代理类的产生，只会经过一次这个步骤，而后成千上万次的方法调用，才是效率的关键。</p><p>来看enhancer.create()的具体步骤，经过createHelper()–&gt;super.create(key)–&gt;data.get(this)–&gt;generatedClasses.get(gen)–&gt;createEntry(key, cacheKey, v)–&gt;loader.apply(key)–&gt;gen.generate(ClassLoaderData.this)–&gt;super.generate(data)–&gt;strategy.generate(this)–&gt;transform(cg).generateClass(cw)后到达产生二进制文件的核心Enhancer类的generateClass(ClassVisitor v)方法。</p><p>这个方法采用asm动态生成字节码文件，具体如何生成，笔者认为没有必要去看具体的逻辑过程，繁琐且没有营养，我们熟悉asm的话也可以写的出来。反而是这个方法，到底生成了什么东西，值得我们关注。</p><h2 id="动态代理类源码"><a href="#动态代理类源码" class="headerlink" title="动态代理类源码"></a>动态代理类源码</h2><p>我们可以将上一步中取到的byte数组，写入到文件，通过反编译工具查看源码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import net.sf.cglib.core.ReflectUtils;</span><br><span class="line">import net.sf.cglib.proxy.Callback;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">//关键点，继承目标类</span><br><span class="line">public class HelloService$$EnhancerByCGLIB$$a89dc216 extends HelloService &#123;</span><br><span class="line">    private boolean CGLIB$BOUND;</span><br><span class="line">    private static ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    private MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">    private static MethodProxy CGLIB$sayHello$0$Proxy;</span><br><span class="line">    private static Object[] CGLIB$emptyArgs;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            CGLIB$STATICHOOK2();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void CGLIB$STATICHOOK2() throws ClassNotFoundException &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = new ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs = new Object[0];</span><br><span class="line">        Class var0 = Class.forName(&quot;com.example.demo.java_demo.cglib.HelloService$$EnhancerByCGLIB$$a89dc216&quot;);</span><br><span class="line">        Class var1;</span><br><span class="line">        Method[] var10000 = ReflectUtils.findMethods(new String[]&#123;&quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;, &quot;hashCode&quot;, &quot;()I&quot;, &quot;clone&quot;, &quot;()Ljava/lang/Object;&quot;&#125;, (var1 = Class.forName(&quot;java.lang.Object&quot;)).getDeclaredMethods());</span><br><span class="line">        //关键代码，产生MethodProxy</span><br><span class="line">        CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //拦截器类将会调用此方法</span><br><span class="line">    final void CGLIB$sayHello$0() &#123;</span><br><span class="line">        super.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //关键方法</span><br><span class="line">    public final void sayHello()  &#123;</span><br><span class="line">        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        if(this.CGLIB$CALLBACK_0 == null) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">            var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(var10000 != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //关键方法</span><br><span class="line">                var10000.intercept(this, null, CGLIB$emptyArgs, CGLIB$sayHello$0$Proxy);</span><br><span class="line">            &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.sayHello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public HelloService$$EnhancerByCGLIB$$a89dc216() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过这个方法注入拦截器类</span><br><span class="line">    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS.set(var0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置拦截器类</span><br><span class="line">    private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">        HelloService$$EnhancerByCGLIB$$a89dc216 var1 = (HelloService$$EnhancerByCGLIB$$a89dc216)var0;</span><br><span class="line">        if(!var1.CGLIB$BOUND) &#123;</span><br><span class="line">            var1.CGLIB$BOUND = true;</span><br><span class="line">            Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">            if(var10000 == null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">            &#125;</span><br><span class="line">            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个源码已经做了大量的精简，但看上去仍然比jdk动态代理生成的动态代理类要复杂的多，有了这个动态代理类，我们就可以修改测试类中的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import net.sf.cglib.proxy.Callback;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //设置拦截器</span><br><span class="line">        HelloService$$EnhancerByCGLIB$$a89dc216.CGLIB$SET_THREAD_CALLBACKS( new Callback[]&#123; new MyMethodInterceptor() &#125; );</span><br><span class="line">        //创建实例</span><br><span class="line">        HelloService helloService = new HelloService$$EnhancerByCGLIB$$a89dc216();</span><br><span class="line">        //调用方法</span><br><span class="line">        helloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先来看第一步设置拦截器，传入的拦截器将在稍后被设置到成员变量CGLIB$CALLBACK_0中，这个属性会在方法调用时发挥作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS.set(var0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">        HelloService$$EnhancerByCGLIB$$a89dc216 var1 = (HelloService$$EnhancerByCGLIB$$a89dc216)var0;</span><br><span class="line">        if(!var1.CGLIB$BOUND) &#123;</span><br><span class="line">            var1.CGLIB$BOUND = true;</span><br><span class="line">            Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">            if(var10000 == null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">            &#125;</span><br><span class="line">            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第二步创建实例，这里有一行非常关键的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;);</span><br></pre></td></tr></table></figure></p><p>这个代码可以先忽略，等到方法执行时再看</p><p>第三步方法调用，即调用动态代理类的sayHello()方法，进而调用拦截器类的intercept方法，传入的4个参数分别为：1、动态代理类的对象本身 2、通过反射获得的method对象 3、方法参数 4、方法代理对象（关键）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var10000.intercept(this, null, CGLIB$emptyArgs, CGLIB$sayHello$0$Proxy);</span><br></pre></td></tr></table></figure></p><p>代码跳到拦截器类的intercept方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object obj, Method method, Object[] args,MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">    System.out.println(&quot;=== before ===&quot;);</span><br><span class="line">    Object object = proxy.invokeSuper(obj, args);</span><br><span class="line">    System.out.println(&quot;=== after ===&quot;);</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在jdk动态代理中，也有类似的方法，但在jdk动态代理在执行目标方法时，是通过反射调用，我们知道反射调用比直接调用，效率上是要低的多，而cglib实现了自己的一套反射调用，查看MethodProxy类的init方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void init()&#123;</span><br><span class="line">       CreateInfo ci = createInfo;</span><br><span class="line">       FastClassInfo fci = new FastClassInfo();</span><br><span class="line">       fci.f1 = helper(ci, ci.c1);</span><br><span class="line">       fci.f2 = helper(ci, ci.c2);</span><br><span class="line">       fci.i1 = fci.f1.getIndex(sig1);</span><br><span class="line">       fci.i2 = fci.f2.getIndex(sig2);</span><br><span class="line">       fastClassInfo = fci;</span><br><span class="line">       createInfo = null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这里的c1，c2，sig1，sig2，即在动态代理类中传入的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;);</span><br></pre></td></tr></table></figure><p>这个方法会产生FastClassInfo对象，这个对象有4个属性，f1，f2，i1，i2，其中最主要的是f2和i2，将在稍后的调用中使用到，为了更清晰明了，我们先来看后面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return fci.f2.invoke(fci.i2, obj, args);</span><br></pre></td></tr></table></figure></p><p>这行代码就是进行了代理类的方法调用，如果此时按F5进入方法，会发现代码跳到了刚刚的动态代理类的CGLIB$sayHello$0()方法，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void CGLIB$sayHello$0() &#123;</span><br><span class="line">        super.sayHello();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>但f2的invoke方法，为何会调用到动态代理类的CGLIB$sayHello$0方法？这里就要看f2是如何产生的，回头看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fci.f2 = helper(ci, ci.c2);</span><br></pre></td></tr></table></figure></p><p>helper()方法会产生一个FastClass对象，这个FastClass对象也是通过动态字节码技术产生的，产生流程跟产生动态代理类一致，通过反编译可以获得源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import com.example.demo.java_demo.cglib.HelloService..EnhancerByCGLIB..a89dc216;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import net.sf.cglib.core.Signature;</span><br><span class="line">import net.sf.cglib.proxy.Callback;</span><br><span class="line">import net.sf.cglib.reflect.FastClass;</span><br><span class="line"></span><br><span class="line">public class HelloService$$EnhancerByCGLIB$$a89dc216$$FastClassByCGLIB$$7d6c4fc4 extends FastClass &#123;</span><br><span class="line">    public HelloService$$EnhancerByCGLIB$$a89dc216$$FastClassByCGLIB$$7d6c4fc4(Class var1) &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getIndex(Signature var1) &#123;</span><br><span class="line">        String var10000 = var1.toString();</span><br><span class="line">        switch(var10000.hashCode()) &#123;</span><br><span class="line">        case -2055565910:</span><br><span class="line">            if(var10000.equals(&quot;CGLIB$SET_THREAD_CALLBACKS([Lnet/sf/cglib/proxy/Callback;)V&quot;)) &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case -1457505897:</span><br><span class="line">            if(var10000.equals(&quot;CGLIB$STATICHOOK2()V&quot;)) &#123;</span><br><span class="line">                return 2;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 291273791:</span><br><span class="line">            if(var10000.equals(&quot;CGLIB$sayHello$0()V&quot;)) &#123;</span><br><span class="line">                return 3;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 1535311470:</span><br><span class="line">            if(var10000.equals(&quot;sayHello()V&quot;)) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException &#123;</span><br><span class="line">        a89dc216 var10000 = (a89dc216)var2;</span><br><span class="line">        int var10001 = var1;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            switch(var10001) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                var10000.sayHello();</span><br><span class="line">                return null;</span><br><span class="line">            case 1:</span><br><span class="line">                a89dc216.CGLIB$SET_THREAD_CALLBACKS((Callback[])var3[0]);</span><br><span class="line">                return null;</span><br><span class="line">            case 2:</span><br><span class="line">                a89dc216.CGLIB$STATICHOOK2();</span><br><span class="line">                return null;</span><br><span class="line">            case 3:</span><br><span class="line">                var10000.CGLIB$sayHello$0();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new InvocationTargetException(var4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码同样做了精简，到这里流程差不多已经走完了，在进行f2的invoke调用时，会传入i1，i1即是通过f2的getinde方法获得的，这里的值为3，在进行invoker调用时，可以看到最终调用的是动态代理类的CGLIB$sayHello$0()方法，CGLIB$sayHello$0()方法的方法体在刚刚已经展示过，就一行代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void CGLIB$sayHello$0() &#123;</span><br><span class="line">        super.sayHello();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>至此，完成了cglib动态调用的过程<br>完！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单的例子&quot;&gt;&lt;a href=&quot;#简单的例子&quot; class=&quot;headerlink&quot; title=&quot;简单的例子&quot;&gt;&lt;/a&gt;简单的例子&lt;/h1&gt;&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;h3 id=&quot;目标类&quot;&gt;&lt;a href=&quot;#目标类&quot; class=&quot;headerlink&quot; title=&quot;目标类&quot;&gt;&lt;/a&gt;目标类&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class HelloService &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void sayHello() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;=== hello ===&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>jdk动态代理解析</title>
    <link href="http://wangzx.org/2018/03/28/jdk-proxy/"/>
    <id>http://wangzx.org/2018/03/28/jdk-proxy/</id>
    <published>2018-03-28T07:43:02.000Z</published>
    <updated>2018-05-18T08:25:56.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloService &#123;</span><br><span class="line">    void sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a id="more"></a></strong></p><h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HelloServiceImpl implements HelloService &#123;</span><br><span class="line"></span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class MyProxy &lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    private Class interfaceClass;</span><br><span class="line"></span><br><span class="line">    public MyProxy(Object target,Class interfaceClass) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.target = target;</span><br><span class="line">        this.interfaceClass = interfaceClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getProxy() &#123;</span><br><span class="line">        return (T)Proxy.newProxyInstance(interfaceClass.getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), new InvocationHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                        System.out.println(&quot;=== begin ===&quot;);</span><br><span class="line">                        Object result = method.invoke(target,args);</span><br><span class="line">                        System.out.println(&quot;=== end ===&quot;);</span><br><span class="line">                        return result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws Throwable &#123;</span><br><span class="line">        new Main().testProxy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testProxy() throws Throwable &#123;</span><br><span class="line">        HelloService userService = new HelloServiceImpl();</span><br><span class="line">        MyProxy&lt;HelloService&gt; myProxy = new MyProxy(userService,HelloService.class);</span><br><span class="line">        HelloService proxy = myProxy.getProxy();</span><br><span class="line">        proxy.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== begin ===</span><br><span class="line">hello</span><br><span class="line">=== end ===</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>在讲核心代码前先插播一个内容：ClassLoader，可以看到在匿名内部类中，有个interfaceClass.getClassLoader()的操作，interfaceClass是个Class对象，在new MyProxy是传入，唯一的作用就是获得这个对象的ClassLoader，这是由于ClassLoader的机制导致的，由不同ClassLoader加载的类，即便已经实现了目标接口的方法，也不会被认为是这个目标接口的子类，因此需要用同一个ClassLoader，才能使最终生成的代理对象，能够被强制转换成接口对象，更详细的内容请参考双亲委派模型。</p><p>接下来开始讲核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure></p><p>这行代码将会产生一个代理类，这个类实现了HelloService的所有方法，在方法体重，调用第三个参数h，这个h即为我们上面代码中的匿名内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new InvocationHandler() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;=== begin ===&quot;);</span><br><span class="line">        Object result = method.invoke(target,args);</span><br><span class="line">        System.out.println(&quot;=== end ===&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>先来看newProxyInstance()这个方法，以下源码摘自jdk1.8，源码做了大量精简，仅保留核心代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)throws IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        //获取代理类的Class对象</span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">        //获取代理类的构造方法</span><br><span class="line">        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        //生成实例</span><br><span class="line">        return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>getProxyClass0()方法也就是动态代理核心，经过各种缓存机制判断后，我们可以找到真正干活的那个方法，即ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags)，这个方法中，又调用了ProxyGenerator类的generateClassFile()方法，这个方法就是产生Class二进制文件的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private byte[] generateClassFile() &#123;</span><br><span class="line">        this.addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">        this.addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">        this.addProxyMethod(toStringMethod, Object.class);</span><br><span class="line">        //...省略代码</span><br><span class="line">        ByteArrayOutputStream var13 = new ByteArrayOutputStream();</span><br><span class="line">        DataOutputStream var14 = new DataOutputStream(var13);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var14.writeInt(-889275714);</span><br><span class="line">            var14.writeShort(0);</span><br><span class="line">            var14.writeShort(49);</span><br><span class="line">            this.cp.write(var14);</span><br><span class="line">            var14.writeShort(this.accessFlags);</span><br><span class="line">            var14.writeShort(this.cp.getClass(dotToSlash(this.className)));</span><br><span class="line">            var14.writeShort(this.cp.getClass(&quot;java/lang/reflect/Proxy&quot;));</span><br><span class="line">            var14.writeShort(this.interfaces.length);</span><br><span class="line">            //...省略代码</span><br><span class="line">            return var13.toByteArray();</span><br><span class="line">        &#125; catch (IOException var9) &#123;</span><br><span class="line">            throw new InternalError(&quot;unexpected I/O Exception&quot;, var9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法充斥着大量的逻辑性代码，没有什么值得看的地方，倒是这种生成Class二进制文件的方式是个亮点，笔者在看dubbo源码时，dubbo也会产生类似的动态代理类，但dubbo的方式是先生成java代码，就是 public class XXX这样，然后通过javassist变成Class文件，但jdk动态代理直接省去了生成java代码这一步，直接写二进制文件，显然这能提高效率，这里可以作为面试的一个点。</p><p>顺便介绍下Class文件的结构，java的Class文件是严格按照顺序来书写，各个属性之间没有间隔（如<bean>之类称之为间隔），通过预定义好的顺序写入和读取Class文件，以保证能够正确的读写，从上面的代码也能看出来</bean></p><p>第一行：writeInt(-889275714) -889275714转成十六进制即为CAFEBABY，熟悉Class文件结构的同学都知道这是Java Class文件的标记，任何Class文件都是以这个开头。</p><p>第二行：writeShort(0)，即两个字节的0，转为十六进制是00 00，这两个字节目前没有意义，是Class文件中罕见的没有意义的字符</p><p>第三行：writeShort(49)，49是jdk的版本，即jdk1.5，即生成的Class文件，能被jdk1.5以上的虚拟机运行</p><p>第四行：cp.write(var14)，写入常量池，常量池包括字面量和符号引用，字面量即文本字符串，声明为final的常量，符号引用即类和接口的全限定名，方法、字段的名称和描述符等，在上面的逻辑步骤中已经解析出了所有需要的常量池</p><p>第五行：writeShort(this.accessFlags);accessFlags即类的访问标志，这里的值是17，十六进制为11，查表可知这代表 final 和 public两种访问标志。</p><p>第六行：常量池写完，后面的所有操作都是写常量池中的编号，而不会再写入具体的名称</p><p>Class文件的结构严谨而复杂，有兴趣的同学可以阅读周志明编写的深入理解java虚拟机这一书</p><p>我们可以手动调用ProxyGenerator.generateProxyClass(“$Proxy0”, HelloServiceImpl.class.getInterfaces())这个方法，得到二进制数据，将它写入磁盘，然后用反编译工具看下到底写了什么代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">package com.sun.proxy;</span><br><span class="line"></span><br><span class="line">import com.example.demo.java_demo.jdk_proxy.HelloService;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">public final class $Proxy0 extends Proxy</span><br><span class="line">  implements HelloService</span><br><span class="line">&#123;</span><br><span class="line">  private static Method m1;</span><br><span class="line">  private static Method m3;</span><br><span class="line">  private static Method m2;</span><br><span class="line">  private static Method m0;</span><br><span class="line"></span><br><span class="line">  public $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    super(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final boolean equals(Object paramObject)</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void sayHello()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      this.h.invoke(this, m3, null);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final String toString()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return (String)this.h.invoke(this, m2, null);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final int hashCode()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return ((Integer)this.h.invoke(this, m0, null)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class="line">      m3 = Class.forName(&quot;com.example.demo.java_demo.jdk_proxy.HelloService&quot;).getMethod(&quot;sayHello&quot;, new Class[0]);</span><br><span class="line">      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键的sayHello方法，其实也是调用了this.h.invoke(this, m2, null);这个h，即我们上面写的那个匿名内部类。</p><p>完！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单的例子&quot;&gt;&lt;a href=&quot;#简单的例子&quot; class=&quot;headerlink&quot; title=&quot;简单的例子&quot;&gt;&lt;/a&gt;简单的例子&lt;/h1&gt;&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;h3 id=&quot;接口类&quot;&gt;&lt;a href=&quot;#接口类&quot; class=&quot;headerlink&quot; title=&quot;接口类&quot;&gt;&lt;/a&gt;接口类&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public interface HelloService &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void sayHello();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java内存结构与垃圾回收</title>
    <link href="http://wangzx.org/2018/02/24/jvm/"/>
    <id>http://wangzx.org/2018/02/24/jvm/</id>
    <published>2018-02-24T11:12:56.000Z</published>
    <updated>2018-02-24T11:55:08.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="堆内存（线程共享）"><a href="#堆内存（线程共享）" class="headerlink" title="堆内存（线程共享）"></a>堆内存（线程共享）</h2><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新创建的对象放入新生代，由于新生代的对象，大部分是朝生夕死，为了更好的垃圾回收，大多数垃圾收集器都采用复制算法，但由于最初的复制算法，将内存一分为二，浪费了50%的内存，因此后来将新生代内存划分为1块Eden区域和两块Survivor区域，默认的比例为8：1：1</p><h4 id="Eden"><a href="#Eden" class="headerlink" title="Eden"></a>Eden</h4><p>新创建的对象优先放入Eden区域</p><p><strong><a id="more"></a></strong></p><h4 id="Suvider"><a href="#Suvider" class="headerlink" title="Suvider"></a>Suvider</h4><p>Survivor区域有两块，进行一次垃圾回收后，Eden中存活的对象，被复制到Survivor区域中</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>长期存活的对象放入老年代</p><h2 id="方法区（线程共享）"><a href="#方法区（线程共享）" class="headerlink" title="方法区（线程共享）"></a>方法区（线程共享）</h2><p>用于存储已被加载的类信息，常量，静态变量，即使编译器编译后的代码数据等</p><h2 id="虚拟机栈（线程独享）"><a href="#虚拟机栈（线程独享）" class="headerlink" title="虚拟机栈（线程独享）"></a>虚拟机栈（线程独享）</h2><p>每个方法执行时，都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，栈帧伴随着方法的执行而入栈，随着方法的结束而出栈</p><h2 id="本地方法栈（线程独享）"><a href="#本地方法栈（线程独享）" class="headerlink" title="本地方法栈（线程独享）"></a>本地方法栈（线程独享）</h2><p>功能类似于虚拟机栈，只是这部分内存由native方法使用</p><h2 id="程序计数器（线程独享）"><a href="#程序计数器（线程独享）" class="headerlink" title="程序计数器（线程独享）"></a>程序计数器（线程独享）</h2><p>用于记录方法执行的行号，如果执行native方法，则无法记录行号，这是内存中唯一一块不会出现OOM的区域</p><h1 id="如何判断对象为垃圾对象"><a href="#如何判断对象为垃圾对象" class="headerlink" title="如何判断对象为垃圾对象"></a>如何判断对象为垃圾对象</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>添加一个引用计数器，当对象被引用时+1，解除引用时-1，当值为0时，即为垃圾对象，但由于这种算法，无法回收相互引用的对象，因此很少jvm采用这种算法</p><h2 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h2><p>从GCRoot向下搜索，所走过的路径，称之为引用链，都为有用的对象，否则即为垃圾对象</p><h3 id="可作为GCroot的节点："><a href="#可作为GCroot的节点：" class="headerlink" title="可作为GCroot的节点："></a>可作为GCroot的节点：</h3><p>全局性的引用（常量或静态类的引用）与执行上下文（栈帧中的本地变量表）</p><h1 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h1><h2 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>当对象被确认为垃圾对象之后，就会被标记为垃圾对象，标记的位置，在对象的header中，标记清除算法的两个缺点：1、效率不高 2、空间问题，不连续，后续创建大对象时寻址困难</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将堆内存分为两块区域，当创建对象时，仅仅使用其中一块区域，当进行垃圾回收时，不再是清除那些被标记为垃圾的对象，而是将没有被标记为垃圾的对象，复制到另一块内存区域，然后将原来那块区域清空，这样很好的解决了标记-清除算法的空间问题，但同时引入了一个新问题，就是内存的浪费，将一块内存分为相等的两块内存，意味着浪费了50%的空间，为此，IBM公司的一个专项研究表明，新生代内存中，98%的对象都是朝生夕死，因此不需要按照1：1来分配内存，而是将内存划分为1块较大的Eden空间和两块较小的Survivor空间，具体的比例为8：1：1，在垃圾回收时，Eden区域和其中一块Surivor区域中还存活的对象，一次性被复制到另一块Surivivor空间上，然后清理掉Eden和刚刚那块Surivivor空间，如果遇到大对象，Surivivor空间不够放时，将进行空间分配担保，将对象放入老年代</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制算法更适合新生代，但对于老年代，对象存活率比较高，无法采用复制算法，因此有人想出标记-整理算法，整个过程也分为两步，标记和整理，标记过程与标记清楚算法无异，但是标记完成后并没有马上清除，而是将所有存活的对象向内存的其中一端移动，然后再清理掉另一端的内存</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前主流的垃圾收集器都采用此算法，但这种算法并没有特别的思想，只是针对不同的区域，进行不同的算法，比如新生代采用复制算法，老年代采用标记-清除或标记-整理算法</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>最早的垃圾收集器，使用单线程收集垃圾，收集效率低下，无法利用多核Cpu的资源，但是现在Client模式的jvm，仍然默认使用这个收集器。</p><h3 id="Parnew"><a href="#Parnew" class="headerlink" title="Parnew"></a>Parnew</h3><p>是Serial的多线程版本，能充分利用多核cpu的资源，另一个重要的原因是能与CMS收集器配合使用</p><h3 id="Cms"><a href="#Cms" class="headerlink" title="Cms"></a>Cms</h3><p>并发标记清除垃圾收集器，能使GC产生的停顿时间减小到最小，除了枚举根节点，会产生GC停顿之外，其他的都能并发执行</p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>是当今收集器最前沿的成果之一</p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="回收过程分析"><a href="#回收过程分析" class="headerlink" title="回收过程分析"></a>回收过程分析</h2><h3 id="打印垃圾回收报告"><a href="#打印垃圾回收报告" class="headerlink" title="打印垃圾回收报告"></a>打印垃圾回收报告</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VM参数： -XX:+PrintGCDetails -verbose:gc -XX:+UseSerialGC</span><br></pre></td></tr></table></figure><ul><li><h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 69085K-&gt;8704K(78656K), 0.0203408 secs] 69085K-&gt;64309K(253440K), 0.0203707 secs] [Times: user=0.02 sys=0.02, real=0.02 secs]</span><br></pre></td></tr></table></figure></li></ul><h4 id="DefNew"><a href="#DefNew" class="headerlink" title="DefNew"></a>DefNew</h4><p>新生代区域名称，由垃圾收集器指定，如使用Serial收集器时，新生代的名字叫DefNew，采用Parallel收集器时，新生代的名称为PSYoungGen</p><h4 id="69085K-gt-8704K-78656K"><a href="#69085K-gt-8704K-78656K" class="headerlink" title="69085K-&gt;8704K(78656K)"></a>69085K-&gt;8704K(78656K)</h4><p>69085K代表本区域GC前的内存大小，8704K代表本区域GC后的内存大小，(78656K)代表本区域总内存大小</p><h4 id="69085K-gt-64309K-253440K"><a href="#69085K-gt-64309K-253440K" class="headerlink" title="69085K-&gt;64309K(253440K)"></a>69085K-&gt;64309K(253440K)</h4><p>69085K代表堆内存GC前的内存大小，64309K代表堆内存GC后的内存大小，(253440K)代表堆内存的总大小</p><h2 id="GC停顿"><a href="#GC停顿" class="headerlink" title="GC停顿"></a>GC停顿</h2><p>在枚举根节点时，不能出现对象的引用关系还在不断发生变化的情况，因此造成GC进行时，必须停止所有的线程，Sun将这件事称之为“Stop The World”，即使在号称几乎不会发生停顿的CMS（并发标记收集）收集器中，枚举根节点时也必须要停顿</p><h1 id="内存的创建"><a href="#内存的创建" class="headerlink" title="内存的创建"></a>内存的创建</h1><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h3 id="优先分配到eden"><a href="#优先分配到eden" class="headerlink" title="优先分配到eden"></a>优先分配到eden</h3><p>Eden区域新生代中的一块区域，也是垃圾收集器最常光顾的地方，新创建对象默认放置这个区域。</p><h3 id="大对象直接分配到老年代"><a href="#大对象直接分配到老年代" class="headerlink" title="大对象直接分配到老年代"></a>大对象直接分配到老年代</h3><p>由于在Eden区域中，一般使用复制算法进行垃圾清理，并且次数非常频繁，大对象在频繁但复制过程中性能低下，因此放到老年代中，gc次数相对较少，并且也并不使用复制算法，以提高性能。大对象的标准会根据内存环境自动计算得出，也可以使用-XX:PretenureSizeThreshold=10M,指定大于10Mb的对象叫大对象。</p><h3 id="长期存活到对象分配到老年代"><a href="#长期存活到对象分配到老年代" class="headerlink" title="长期存活到对象分配到老年代"></a>长期存活到对象分配到老年代</h3><p>每一次的垃圾回收之后，都会给对象的年龄+1，当年龄达到某个值当时候，即称之为长期存活，进入老年代。我们可以使用-XX:MaxTenuringThreshshold=10,指定age达到10的时候进入老年代，默认值为15</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><p>并非所有对象都需要到达MaxTenuringThreshshold指定的分代年龄之后才会进入老年代，但Survivor区域中，所有相同年龄的对象内存总和，大于Survivor的一半，即会进入老年代，不受MaxTenuringThreshshold的限制</p><h3 id="逃逸分析与栈上分配"><a href="#逃逸分析与栈上分配" class="headerlink" title="逃逸分析与栈上分配"></a>逃逸分析与栈上分配</h3><p>当对象仅在方法体内部使用时，由于方法当调用会创建栈帧，当调用结束就会出栈，因此将仅供该方法使用的对象，放在栈内存中，随着方法的出入栈而出入栈，而不用垃圾回收机制进行干预，可大大提高性能</p><h1 id="虚拟机工具"><a href="#虚拟机工具" class="headerlink" title="虚拟机工具"></a>虚拟机工具</h1><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>是一个命令行工具，全称是java process status，<br>常用的命令如下：</p><p>jps -l 可以显示java进程执行的主类</p><p>jps -m 可以显示程序执行所接收的参数，即main方法中的args参数</p><p>jps -v 可以显示虚拟机执行所接收的参数，如-Xms8m</p><h1 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h1><h2 id="Xmx"><a href="#Xmx" class="headerlink" title="-Xmx"></a>-Xmx</h2><p>最大堆容量</p><h2 id="Xms"><a href="#Xms" class="headerlink" title="-Xms"></a>-Xms</h2><p>最小堆容量</p><h2 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h2><p>栈内存大小，注意是单个线程的栈内存大小</p><h2 id="Xmn"><a href="#Xmn" class="headerlink" title="-Xmn"></a>-Xmn</h2><p>新生代内存大小</p><h2 id="XX-SurvivorRatio-8"><a href="#XX-SurvivorRatio-8" class="headerlink" title="-XX:SurvivorRatio=8"></a>-XX:SurvivorRatio=8</h2><p>新生代中，Eden区域与其中一个Surivivor区的大小比例是8：1</p><h2 id="XX-PertenureSizeThreshold"><a href="#XX-PertenureSizeThreshold" class="headerlink" title="-XX:PertenureSizeThreshold"></a>-XX:PertenureSizeThreshold</h2><p>大对象的定义，超过这个值的称之为大对象，直接放入老年代，避免在新生代中来回复制造成性能问题</p><h2 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h2><p>对象分代年龄分界线，超过这个值进入老年代，默认为15</p><h2 id="XX-MaxPermSize"><a href="#XX-MaxPermSize" class="headerlink" title="-XX:MaxPermSize"></a>-XX:MaxPermSize</h2><p>最大方法区(非堆)容量</p><h2 id="XX-MaxDirectMemorySize"><a href="#XX-MaxDirectMemorySize" class="headerlink" title="-XX:MaxDirectMemorySize"></a>-XX:MaxDirectMemorySize</h2><p>最大直接内存，如果不指定，默认与最大堆内存一致</p><h2 id="XX-PrintGCDetail"><a href="#XX-PrintGCDetail" class="headerlink" title="-XX:+PrintGCDetail"></a>-XX:+PrintGCDetail</h2><p>打印GC日志</p><h2 id="XX-PrintTenuringDistribution"><a href="#XX-PrintTenuringDistribution" class="headerlink" title="-XX:+PrintTenuringDistribution"></a>-XX:+PrintTenuringDistribution</h2><p>打印对象分代年龄</p><h2 id="HeapDumpOnOutOfMemoryError"><a href="#HeapDumpOnOutOfMemoryError" class="headerlink" title="HeapDumpOnOutOfMemoryError"></a>HeapDumpOnOutOfMemoryError</h2><p>当内存溢出时打印堆栈信息</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内存结构&quot;&gt;&lt;a href=&quot;#内存结构&quot; class=&quot;headerlink&quot; title=&quot;内存结构&quot;&gt;&lt;/a&gt;内存结构&lt;/h1&gt;&lt;h2 id=&quot;堆内存（线程共享）&quot;&gt;&lt;a href=&quot;#堆内存（线程共享）&quot; class=&quot;headerlink&quot; title=&quot;堆内存（线程共享）&quot;&gt;&lt;/a&gt;堆内存（线程共享）&lt;/h2&gt;&lt;h3 id=&quot;新生代&quot;&gt;&lt;a href=&quot;#新生代&quot; class=&quot;headerlink&quot; title=&quot;新生代&quot;&gt;&lt;/a&gt;新生代&lt;/h3&gt;&lt;p&gt;新创建的对象放入新生代，由于新生代的对象，大部分是朝生夕死，为了更好的垃圾回收，大多数垃圾收集器都采用复制算法，但由于最初的复制算法，将内存一分为二，浪费了50%的内存，因此后来将新生代内存划分为1块Eden区域和两块Survivor区域，默认的比例为8：1：1&lt;/p&gt;
&lt;h4 id=&quot;Eden&quot;&gt;&lt;a href=&quot;#Eden&quot; class=&quot;headerlink&quot; title=&quot;Eden&quot;&gt;&lt;/a&gt;Eden&lt;/h4&gt;&lt;p&gt;新创建的对象优先放入Eden区域&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://wangzx.org/categories/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>centos7搭建saltstack</title>
    <link href="http://wangzx.org/2018/02/07/salt-install/"/>
    <id>http://wangzx.org/2018/02/07/salt-install/</id>
    <published>2018-02-07T06:25:36.000Z</published>
    <updated>2018-02-09T02:29:13.226Z</updated>
    
    <content type="html"><![CDATA[<p>Salt，一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯。</p><p>salt底层采用动态的连接总线, 使其可以用于编配, 远程执行, 配置管理等等.</p><p><strong><a id="more"></a></strong></p><p>本次搭建使用centos7.1，共搭建1台master，2台minion，ip分配如下：</p><table><thead><tr><th style="text-align:left">服务器ip</th><th style="text-align:left">hostname</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">192.168.32.140</td><td style="text-align:left">salt-master</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.141</td><td style="text-align:left">salt-minion1</td><td style="text-align:left">minion</td></tr><tr><td style="text-align:left">192.168.32.142</td><td style="text-align:left">salt-minion2</td><td style="text-align:left">minion</td></tr></tbody></table><h1 id="服务器基础设置"><a href="#服务器基础设置" class="headerlink" title="服务器基础设置"></a>服务器基础设置</h1><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld</span><br><span class="line">$ systemctl disable firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ setenforce 0</span><br><span class="line">$ vi /etc/selinux/config</span><br></pre></td></tr></table></figure><p>将第6行修改为SELINUX=permissive<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># This file controls the state of SELinux on the system.</span><br><span class="line"># SELINUX= can take one of these three values:</span><br><span class="line">#     enforcing - SELinux security policy is enforced.</span><br><span class="line">#     permissive - SELinux prints warnings instead of enforcing.</span><br><span class="line">#     disabled - No SELinux policy is loaded.</span><br><span class="line">SELINUX=permissive</span><br><span class="line"># SELINUXTYPE= can take one of three two values:</span><br><span class="line">#     targeted - Targeted processes are protected,</span><br><span class="line">#     minimum - Modification of targeted policy. Only selected processes are protected.</span><br><span class="line">#     mls - Multi Level Security protection.</span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure></p><h2 id="设置hostname"><a href="#设置hostname" class="headerlink" title="设置hostname"></a>设置hostname</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hostnamectl set-hostname salt-master</span><br></pre></td></tr></table></figure><h2 id="修改host文件"><a href="#修改host文件" class="headerlink" title="修改host文件"></a>修改host文件</h2><p>修改/etc/hosts文件为如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.32.140 salt-master</span><br><span class="line">192.168.32.141 salt-minion1</span><br><span class="line">192.168.32.142 salt-minion2</span><br></pre></td></tr></table></figure></p><p>使用scp命令复制到其他2台服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp /etc/hosts root@salt-minion1:/etc/hosts</span><br></pre></td></tr></table></figure></p><h1 id="环境准备，依赖解决"><a href="#环境准备，依赖解决" class="headerlink" title="环境准备，依赖解决"></a>环境准备，依赖解决</h1><p>分别为三台机器添加阿里云epel源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup</span><br><span class="line">$ mv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup</span><br><span class="line">$ wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br></pre></td></tr></table></figure></p><p>解决依赖关系，不然会报python依赖错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum clean expire-cache</span><br><span class="line">$ yum upgrade</span><br><span class="line">$ yum -y install epel-release</span><br><span class="line">$ yum install zeromq3 m2crypto python-crypto python-jinja2 python-msgpack python-yaml python-zmq -y</span><br></pre></td></tr></table></figure><h1 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h1><h2 id="salt-master安装"><a href="#salt-master安装" class="headerlink" title="salt-master安装"></a>salt-master安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y salt-master</span><br></pre></td></tr></table></figure><h2 id="salt-minion安装"><a href="#salt-minion安装" class="headerlink" title="salt-minion安装"></a>salt-minion安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y salt-minion</span><br></pre></td></tr></table></figure><h1 id="配置-amp-启动"><a href="#配置-amp-启动" class="headerlink" title="配置&amp;启动"></a>配置&amp;启动</h1><h2 id="master配置"><a href="#master配置" class="headerlink" title="master配置"></a>master配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/salt/master</span><br></pre></td></tr></table></figure><p>修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#master消息发布端口 Default: 4505</span><br><span class="line">publish_port: 4505</span><br><span class="line">#工作线程数，应答和接受minion Default: 5</span><br><span class="line">worker_threads: 100</span><br><span class="line">#客户端与服务端通信的端口 Default: 4506</span><br><span class="line">ret_port: 4506</span><br><span class="line">#自动接受所有客户端</span><br><span class="line">auto_accept: True</span><br><span class="line">#启动salt-master</span><br></pre></td></tr></table></figure></p><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start salt-master</span><br></pre></td></tr></table></figure></p><h2 id="minion配置"><a href="#minion配置" class="headerlink" title="minion配置"></a>minion配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/salt/minion</span><br></pre></td></tr></table></figure><p>修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># master IP或域名</span><br><span class="line">master: salt-master</span><br><span class="line"># 客户端与服务端通信的端口。 Default: 4506</span><br><span class="line">master_port: 4506</span><br><span class="line"># id minion的唯一标示。Default: hostname</span><br><span class="line">id: salt-minion1</span><br></pre></td></tr></table></figure><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start salt-minion</span><br></pre></td></tr></table></figure></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="查看master的key列表"><a href="#查看master的key列表" class="headerlink" title="查看master的key列表"></a>查看master的key列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# salt-key -L</span><br><span class="line">Accepted Keys:（接受的key）</span><br><span class="line">salt-minion1</span><br><span class="line">salt-minion2</span><br><span class="line">Denied Keys:（否认的key）</span><br><span class="line">Unaccepted Keys:（未接受的key）</span><br><span class="line">Rejected Keys:（拒绝的key）</span><br></pre></td></tr></table></figure><h2 id="salt-key常用参数说明："><a href="#salt-key常用参数说明：" class="headerlink" title="salt-key常用参数说明："></a>salt-key常用参数说明：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-L 列出当前所有认证，包括Accepted Keys、Denied Keys、Unaccepted Keys、Rejected Keys</span><br><span class="line">-a 添加某个或某些个未接受(Unaccepted Keys)认证</span><br><span class="line">-A 添加所有未接受(Unaccepted Keys)认证</span><br><span class="line">-d 删除某个或某些个已接受(Accepted Keys)认证</span><br><span class="line">-D 删除所有已接受(Accepted Keys)认证</span><br><span class="line">-y 使用该参数可免去证书操作的交互，除非对minion端很信任，一般不建议使用</span><br><span class="line">-h 帮助</span><br></pre></td></tr></table></figure><h2 id="test-ping"><a href="#test-ping" class="headerlink" title="test.ping"></a>test.ping</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ salt &apos;*&apos; test.ping</span><br><span class="line">salt-minion1:</span><br><span class="line">True</span><br><span class="line">salt-minion2:</span><br><span class="line">True</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Salt，一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯。&lt;/p&gt;
&lt;p&gt;salt底层采用动态的连接总线, 使其可以用于编配, 远程执行, 配置管理等等.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="运维" scheme="http://wangzx.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>centos7搭建mesos集群</title>
    <link href="http://wangzx.org/2018/01/09/mesos-install/"/>
    <id>http://wangzx.org/2018/01/09/mesos-install/</id>
    <published>2018-01-09T11:08:36.000Z</published>
    <updated>2018-02-09T02:32:37.856Z</updated>
    
    <content type="html"><![CDATA[<p>Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。</p><p><strong><a id="more"></a></strong></p><p>本次搭建使用centos7.1，共搭建3台master，3台slave，ip分配如下：</p><table><thead><tr><th style="text-align:left">服务器ip</th><th style="text-align:left">hostname</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">192.168.32.131</td><td style="text-align:left">docker1.nd.com</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.132</td><td style="text-align:left">docker2.nd.com</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.133</td><td style="text-align:left">docker3.nd.com</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.134</td><td style="text-align:left">docker4.nd.com</td><td style="text-align:left">slave</td></tr><tr><td style="text-align:left">192.168.32.135</td><td style="text-align:left">docker5.nd.com</td><td style="text-align:left">slave</td></tr><tr><td style="text-align:left">192.168.32.136</td><td style="text-align:left">docker6.nd.com</td><td style="text-align:left">slave</td></tr></tbody></table><h1 id="服务器基础设置"><a href="#服务器基础设置" class="headerlink" title="服务器基础设置"></a>服务器基础设置</h1><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld</span><br><span class="line">$ systemctl disable firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ setenforce 0</span><br><span class="line">$ vi /etc/selinux/config</span><br></pre></td></tr></table></figure><p>将第6行修改为SELINUX=permissive<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># This file controls the state of SELinux on the system.</span><br><span class="line"># SELINUX= can take one of these three values:</span><br><span class="line">#     enforcing - SELinux security policy is enforced.</span><br><span class="line">#     permissive - SELinux prints warnings instead of enforcing.</span><br><span class="line">#     disabled - No SELinux policy is loaded.</span><br><span class="line">SELINUX=permissive</span><br><span class="line"># SELINUXTYPE= can take one of three two values:</span><br><span class="line">#     targeted - Targeted processes are protected,</span><br><span class="line">#     minimum - Modification of targeted policy. Only selected processes are protected.</span><br><span class="line">#     mls - Multi Level Security protection.</span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure></p><h2 id="设置hostname"><a href="#设置hostname" class="headerlink" title="设置hostname"></a>设置hostname</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hostnamectl set-hostname docker1.nd.com</span><br></pre></td></tr></table></figure><h2 id="修改host文件"><a href="#修改host文件" class="headerlink" title="修改host文件"></a>修改host文件</h2><p>修改/etc/hosts文件为如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">192.168.32.131 docker1.nd.com</span><br><span class="line">192.168.32.132 docker2.nd.com</span><br><span class="line">192.168.32.133 docker3.nd.com</span><br><span class="line">192.168.32.134 docker4.nd.com</span><br><span class="line">192.168.32.135 docker5.nd.com</span><br><span class="line">192.168.32.136 docker6.nd.com</span><br></pre></td></tr></table></figure></p><p>使用scp命令复制到其他5台服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp /etc/hosts root@docker2.nd.com:/etc/hosts</span><br></pre></td></tr></table></figure></p><h1 id="安装mesos、zookeeper包"><a href="#安装mesos、zookeeper包" class="headerlink" title="安装mesos、zookeeper包"></a>安装mesos、zookeeper包</h1><p> 1、分别在6台服务器上执行如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -Uvh http://repos.mesosphere.io/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm</span><br><span class="line">$ rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-mesosphere</span><br></pre></td></tr></table></figure></p><p>2、进入3台master服务器安装mesos、marathon和zookeeper<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install mesos marathon mesosphere-zookeeper -y</span><br></pre></td></tr></table></figure></p><p>3、进入3台slave服务器安装mesos<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install mesos -y</span><br></pre></td></tr></table></figure></p><h1 id="配置mesos、zookeeper"><a href="#配置mesos、zookeeper" class="headerlink" title="配置mesos、zookeeper"></a>配置mesos、zookeeper</h1><h2 id="配置zookeeper"><a href="#配置zookeeper" class="headerlink" title="配置zookeeper"></a>配置zookeeper</h2><p>1、修改/var/lib/zookeeper/myid文件，三台master服务器，分别设置为1、2、3<br>2、修改/etc/zookeeper/conf/zoo.cfg文件，在文件末尾添加以下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=192.168.32.131:2888:3888</span><br><span class="line">server.2=192.168.32.132:2888:3888</span><br><span class="line">server.3=192.168.32.133:2888:3888</span><br></pre></td></tr></table></figure></p><p>3、启动zookeeper服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start zookeeper</span><br></pre></td></tr></table></figure></p><p>4、查看zookeeper服务是否已启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl is-active zookeeper</span><br></pre></td></tr></table></figure><h2 id="配置mesos-master"><a href="#配置mesos-master" class="headerlink" title="配置mesos-master"></a>配置mesos-master</h2><p>1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos</span><br></pre></td></tr></table></figure></p><p>2、设置/etc/mesos-master/quorum文件中quorum的值，这个值要大于master数量的1/2，我们这里设置为2<br>3、停用mesos-slave<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop mesos-slave.service</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl disable mesos-slave.service</span><br></pre></td></tr></table></figure><p>4、启动mesos-master marathon<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start mesos-master</span><br><span class="line">$ marathon --master zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos</span><br></pre></td></tr></table></figure></p><p>正常情况下此时已经可以通过<a href="http://docker1.nd.com:5050打开mesos页面" target="_blank" rel="noopener">http://docker1.nd.com:5050打开mesos页面</a></p><h2 id="配置mesos-slave"><a href="#配置mesos-slave" class="headerlink" title="配置mesos-slave"></a>配置mesos-slave</h2><p>1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos</span><br></pre></td></tr></table></figure></p><p>2、停用mesos-master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop mesos-master.service</span><br><span class="line">$ systemctl disable mesos-master.service</span><br></pre></td></tr></table></figure></p><p>3、启动mesos-slave<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start mesos-slave</span><br></pre></td></tr></table></figure></p><h1 id="docker配置"><a href="#docker配置" class="headerlink" title="docker配置"></a>docker配置</h1><p>如需要在slave上运行docker，除docker自身安装配置外，还需要做如下设置<br>1、指定使用docker容器化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;docker,mesos&apos; &gt; /etc/mesos-slave/containerizers</span><br></pre></td></tr></table></figure></p><p>2、考虑到拉取容器镜像等的操作，适当增加timeout的时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;5mins&apos; &gt; /etc/mesos-slave/executor_registration_timeout</span><br></pre></td></tr></table></figure></p><p>3、重启mesos-slave以使上面配置生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart mesos-slave</span><br></pre></td></tr></table></figure></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>在测试环境中我们可以关闭防火墙，但在生产环境中，为了安全考虑，还是需要将防火墙开启<br>此时应注意，master需要向agent的所有ip开放5050端口，所有agent需要向master开放5051端口<br>并且为了用户可以访问mesos的前端页面，master需向用户ip开放5050端口，所有agent也需要向用户ip开放5051端口，否则会出现agent信息无法查看，task日志无法查看等问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="运维" scheme="http://wangzx.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
</feed>
