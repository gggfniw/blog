<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王志兴的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangzx.org/"/>
  <updated>2018-02-24T11:47:14.550Z</updated>
  <id>http://wangzx.org/</id>
  
  <author>
    <name>王志兴</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java内存结构与垃圾回收</title>
    <link href="http://wangzx.org/2018/02/24/jvm/"/>
    <id>http://wangzx.org/2018/02/24/jvm/</id>
    <published>2018-02-24T11:12:56.000Z</published>
    <updated>2018-02-24T11:47:14.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="堆内存（线程共享）"><a href="#堆内存（线程共享）" class="headerlink" title="堆内存（线程共享）"></a>堆内存（线程共享）</h2><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新创建的对象放入新生代，由于新生代的对象，大部分是朝生夕死，为了更好的垃圾回收，大多数垃圾收集器都采用复制算法，但由于最初的复制算法，将内存一分为二，浪费了50%的内存，因此后来将新生代内存划分为1块Eden区域和两块Survivor区域，默认的比例为8：1：1</p><h4 id="Eden"><a href="#Eden" class="headerlink" title="Eden"></a>Eden</h4><p>新创建的对象优先放入Eden区域</p><p><strong><a id="more"></a></strong></p><h4 id="Suvider"><a href="#Suvider" class="headerlink" title="Suvider"></a>Suvider</h4><p>Survivor区域有两块，进行一次垃圾回收后，Eden中存活的对象，被复制到Survivor区域中</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>长期存活的对象放入老年代</p><h2 id="方法区（线程共享）"><a href="#方法区（线程共享）" class="headerlink" title="方法区（线程共享）"></a>方法区（线程共享）</h2><p>用于存储已被加载的类信息，常量，静态变量，即使编译器编译后的代码数据等</p><h2 id="虚拟机栈（线程独享）"><a href="#虚拟机栈（线程独享）" class="headerlink" title="虚拟机栈（线程独享）"></a>虚拟机栈（线程独享）</h2><p>每个方法执行时，都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，栈帧伴随着方法的执行而入栈，随着方法的结束而出栈</p><h2 id="本地方法栈（线程独享）"><a href="#本地方法栈（线程独享）" class="headerlink" title="本地方法栈（线程独享）"></a>本地方法栈（线程独享）</h2><p>功能类似于虚拟机栈，只是这部分内存由native方法使用</p><h2 id="程序计数器（线程独享）"><a href="#程序计数器（线程独享）" class="headerlink" title="程序计数器（线程独享）"></a>程序计数器（线程独享）</h2><p>用于记录方法执行的行号，如果执行native方法，则无法记录行号，这是内存中唯一一块不会出现OOM的区域</p><h1 id="如何判断对象为垃圾对象"><a href="#如何判断对象为垃圾对象" class="headerlink" title="如何判断对象为垃圾对象"></a>如何判断对象为垃圾对象</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>添加一个引用计数器，当对象被引用时+1，解除引用时-1，当值为0时，即为垃圾对象，但由于这种算法，无法回收相互引用的对象，因此很少jvm采用这种算法</p><h2 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h2><p>从GCRoot向下搜索，所走过的路径，称之为引用链，都为有用的对象，否则即为垃圾对象</p><h4 id="可作为GCroot的节点："><a href="#可作为GCroot的节点：" class="headerlink" title="可作为GCroot的节点："></a>可作为GCroot的节点：</h4><p>全局性的引用（常量或静态类的引用）与执行上下文（栈帧中的本地变量表）</p><h4 id="GC停顿"><a href="#GC停顿" class="headerlink" title="GC停顿"></a>GC停顿</h4><p>在枚举根节点时，不能出现对象的引用关系还在不断发生变化的情况，因此造成GC进行时，必须停止所有的线程，Sun将这件事称之为“Stop The World”，即使在号称几乎不会发生停顿的CMS（并发标记收集）收集器中，枚举根节点时也必须要停顿</p><h1 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h1><h2 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h2><ul><li><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3>当对象被确认为垃圾对象之后，就会被标记为垃圾对象，标记的位置，在对象的header中，标记清除算法的两个缺点：1、效率不高 2、空间问题，不连续，后续创建大对象时寻址困难</li><li><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3>将堆内存分为两块区域，当创建对象时，仅仅使用其中一块区域，当进行垃圾回收时，不再是清除那些被标记为垃圾的对象，而是将没有被标记为垃圾的对象，复制到另一块内存区域，然后将原来那块区域清空，这样很好的解决了标记-清除算法的空间问题，但同时引入了一个新问题，就是内存的浪费，将一块内存分为相等的两块内存，意味着浪费了50%的空间，为此，IBM公司的一个专项研究表明，新生代内存中，98%的对象都是朝生夕死，因此不需要按照1：1来分配内存，而是将内存划分为1块较大的Eden空间和两块较小的Survivor空间，具体的比例为8：1：1，在垃圾回收时，Eden区域和其中一块Surivor区域中还存活的对象，一次性被复制到另一块Surivivor空间上，然后清理掉Eden和刚刚那块Surivivor空间，如果遇到大对象，Surivivor空间不够放时，将进行空间分配担保，将对象放入老年代</li><li><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3>复制算法更适合新生代，但对于老年代，对象存活率比较高，无法采用复制算法，因此有人想出标记-整理算法，整个过程也分为两步，标记和整理，标记过程与标记清楚算法无异，但是标记完成后并没有马上清除，而是将所有存活的对象向内存的其中一端移动，然后再清理掉另一端的内存</li><li><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3>当前主流的垃圾收集器都采用此算法，但这种算法并没有特别的思想，只是针对不同的区域，进行不同的算法，比如新生代采用复制算法，老年代采用标记-清除或标记-整理算法</li></ul><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><ul><li><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3>最早的垃圾收集器，使用单线程收集垃圾，收集效率低下，无法利用多核Cpu的资源，但是现在Client模式的jvm，仍然默认使用这个收集器。</li><li><h3 id="Parnew"><a href="#Parnew" class="headerlink" title="Parnew"></a>Parnew</h3>是Serial的多线程版本，能充分利用多核cpu的资源，另一个重要的原因是能与CMS收集器配合使用</li><li><h3 id="Cms"><a href="#Cms" class="headerlink" title="Cms"></a>Cms</h3>并发标记清除垃圾收集器，能使GC产生的停顿时间减小到最小，除了枚举根节点，会产生GC停顿之外，其他的都能并发执行</li><li><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3>是当今收集器最前沿的成果之一</li></ul><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="回收过程分析"><a href="#回收过程分析" class="headerlink" title="回收过程分析"></a>回收过程分析</h2><ul><li><h3 id="打印垃圾回收报告"><a href="#打印垃圾回收报告" class="headerlink" title="打印垃圾回收报告"></a>打印垃圾回收报告</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VM参数： -XX:+PrintGCDetails -verbose:gc -XX:+UseSerialGC</span><br></pre></td></tr></table></figure></li><li><h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 69085K-&gt;8704K(78656K), 0.0203408 secs] 69085K-&gt;64309K(253440K), 0.0203707 secs] [Times: user=0.02 sys=0.02, real=0.02 secs]</span><br></pre></td></tr></table></figure></li><li><h5 id="DefNew"><a href="#DefNew" class="headerlink" title="DefNew"></a>DefNew</h5><p>新生代区域名称，由垃圾收集器指定，如使用Serial收集器时，新生代的名字叫DefNew，采用Parallel收集器时，新生代的名称为PSYoungGen</p></li><li><h5 id="69085K-gt-8704K-78656K"><a href="#69085K-gt-8704K-78656K" class="headerlink" title="69085K-&gt;8704K(78656K)"></a>69085K-&gt;8704K(78656K)</h5>69085K代表本区域GC前的内存大小，8704K代表本区域GC后的内存大小，(78656K)代表本区域总内存大小</li><li><h5 id="69085K-gt-64309K-253440K"><a href="#69085K-gt-64309K-253440K" class="headerlink" title="69085K-&gt;64309K(253440K)"></a>69085K-&gt;64309K(253440K)</h5>69085K代表堆内存GC前的内存大小，64309K代表堆内存GC后的内存大小，(253440K)代表堆内存的总大小</li></ul><h1 id="内存的创建"><a href="#内存的创建" class="headerlink" title="内存的创建"></a>内存的创建</h1><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ul><li><h3 id="优先分配到eden"><a href="#优先分配到eden" class="headerlink" title="优先分配到eden"></a>优先分配到eden</h3>Eden区域新生代中的一块区域，也是垃圾收集器最常光顾的地方，新创建对象默认放置这个区域。</li><li><h3 id="大对象直接分配到老年代"><a href="#大对象直接分配到老年代" class="headerlink" title="大对象直接分配到老年代"></a>大对象直接分配到老年代</h3>由于在Eden区域中，一般使用复制算法进行垃圾清理，并且次数非常频繁，大对象在频繁但复制过程中性能低下，因此放到老年代中，gc次数相对较少，并且也并不使用复制算法，以提高性能。大对象的标准会根据内存环境自动计算得出，也可以使用-XX:PretenureSizeThreshold=10M,指定大于10Mb的对象叫大对象。</li><li><h3 id="长期存活到对象分配到老年代"><a href="#长期存活到对象分配到老年代" class="headerlink" title="长期存活到对象分配到老年代"></a>长期存活到对象分配到老年代</h3>每一次的垃圾回收之后，都会给对象的年龄+1，当年龄达到某个值当时候，即称之为长期存活，进入老年代。我们可以使用-XX:MaxTenuringThreshshold=10,指定age达到10的时候进入老年代，默认值为15</li><li><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3></li><li><h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3>并非所有对象都需要到达MaxTenuringThreshshold指定的分代年龄之后才会进入老年代，但Survivor区域中，所有相同年龄的对象内存总和，大于Survivor的一半，即会进入老年代，不受MaxTenuringThreshshold的限制</li><li><h3 id="逃逸分析与栈上分配"><a href="#逃逸分析与栈上分配" class="headerlink" title="逃逸分析与栈上分配"></a>逃逸分析与栈上分配</h3>当对象仅在方法体内部使用时，由于方法当调用会创建栈帧，当调用结束就会出栈，因此将仅供该方法使用的对象，放在栈内存中，随着方法的出入栈而出入栈，而不用垃圾回收机制进行干预，可大大提高性能</li></ul><h1 id="虚拟机工具"><a href="#虚拟机工具" class="headerlink" title="虚拟机工具"></a>虚拟机工具</h1><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>是一个命令行工具，全称是java process status，<br>常用的命令如下：</p><ul><li>jps -l 可以显示java进程执行的主类</li><li>jps -m 可以显示程序执行所接收的参数，即main方法中的args参数</li><li>jps -v 可以显示虚拟机执行所接收的参数，如-Xms8m</li></ul><h1 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h1><h2 id="Xmx"><a href="#Xmx" class="headerlink" title="-Xmx"></a>-Xmx</h2><p>最大堆容量</p><h2 id="Xms"><a href="#Xms" class="headerlink" title="-Xms"></a>-Xms</h2><p>最小堆容量</p><h2 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h2><p>栈内存大小，注意是单个线程的栈内存大小</p><h2 id="Xmn"><a href="#Xmn" class="headerlink" title="-Xmn"></a>-Xmn</h2><p>新生代内存大小</p><h2 id="XX-SurvivorRatio-8"><a href="#XX-SurvivorRatio-8" class="headerlink" title="-XX:SurvivorRatio=8"></a>-XX:SurvivorRatio=8</h2><p>新生代中，Eden区域与其中一个Surivivor区的大小比例是8：1</p><h2 id="XX-PertenureSizeThreshold"><a href="#XX-PertenureSizeThreshold" class="headerlink" title="-XX:PertenureSizeThreshold"></a>-XX:PertenureSizeThreshold</h2><p>大对象的定义，超过这个值的称之为大对象，直接放入老年代，避免在新生代中来回复制造成性能问题</p><h2 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h2><p>对象分代年龄分界线，超过这个值进入老年代，默认为15</p><h2 id="XX-MaxPermSize"><a href="#XX-MaxPermSize" class="headerlink" title="-XX:MaxPermSize"></a>-XX:MaxPermSize</h2><p>最大方法区(非堆)容量</p><h2 id="XX-MaxDirectMemorySize"><a href="#XX-MaxDirectMemorySize" class="headerlink" title="-XX:MaxDirectMemorySize"></a>-XX:MaxDirectMemorySize</h2><p>最大直接内存，如果不指定，默认与最大堆内存一致</p><h2 id="XX-PrintGCDetail"><a href="#XX-PrintGCDetail" class="headerlink" title="-XX:+PrintGCDetail"></a>-XX:+PrintGCDetail</h2><p>打印GC日志</p><h2 id="XX-PrintTenuringDistribution"><a href="#XX-PrintTenuringDistribution" class="headerlink" title="-XX:+PrintTenuringDistribution"></a>-XX:+PrintTenuringDistribution</h2><p>打印对象分代年龄</p><h2 id="HeapDumpOnOutOfMemoryError"><a href="#HeapDumpOnOutOfMemoryError" class="headerlink" title="HeapDumpOnOutOfMemoryError"></a>HeapDumpOnOutOfMemoryError</h2><p>当内存溢出时打印堆栈信息</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内存结构&quot;&gt;&lt;a href=&quot;#内存结构&quot; class=&quot;headerlink&quot; title=&quot;内存结构&quot;&gt;&lt;/a&gt;内存结构&lt;/h1&gt;&lt;h2 id=&quot;堆内存（线程共享）&quot;&gt;&lt;a href=&quot;#堆内存（线程共享）&quot; class=&quot;headerlink&quot; title=&quot;堆内存（线程共享）&quot;&gt;&lt;/a&gt;堆内存（线程共享）&lt;/h2&gt;&lt;h3 id=&quot;新生代&quot;&gt;&lt;a href=&quot;#新生代&quot; class=&quot;headerlink&quot; title=&quot;新生代&quot;&gt;&lt;/a&gt;新生代&lt;/h3&gt;&lt;p&gt;新创建的对象放入新生代，由于新生代的对象，大部分是朝生夕死，为了更好的垃圾回收，大多数垃圾收集器都采用复制算法，但由于最初的复制算法，将内存一分为二，浪费了50%的内存，因此后来将新生代内存划分为1块Eden区域和两块Survivor区域，默认的比例为8：1：1&lt;/p&gt;
&lt;h4 id=&quot;Eden&quot;&gt;&lt;a href=&quot;#Eden&quot; class=&quot;headerlink&quot; title=&quot;Eden&quot;&gt;&lt;/a&gt;Eden&lt;/h4&gt;&lt;p&gt;新创建的对象优先放入Eden区域&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://wangzx.org/categories/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>centos7搭建saltstack</title>
    <link href="http://wangzx.org/2018/02/07/salt-install/"/>
    <id>http://wangzx.org/2018/02/07/salt-install/</id>
    <published>2018-02-07T06:25:36.000Z</published>
    <updated>2018-02-09T02:29:13.226Z</updated>
    
    <content type="html"><![CDATA[<p>Salt，一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯。</p><p>salt底层采用动态的连接总线, 使其可以用于编配, 远程执行, 配置管理等等.</p><p><strong><a id="more"></a></strong></p><p>本次搭建使用centos7.1，共搭建1台master，2台minion，ip分配如下：</p><table><thead><tr><th style="text-align:left">服务器ip</th><th style="text-align:left">hostname</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">192.168.32.140</td><td style="text-align:left">salt-master</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.141</td><td style="text-align:left">salt-minion1</td><td style="text-align:left">minion</td></tr><tr><td style="text-align:left">192.168.32.142</td><td style="text-align:left">salt-minion2</td><td style="text-align:left">minion</td></tr></tbody></table><h1 id="服务器基础设置"><a href="#服务器基础设置" class="headerlink" title="服务器基础设置"></a>服务器基础设置</h1><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld</span><br><span class="line">$ systemctl disable firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ setenforce 0</span><br><span class="line">$ vi /etc/selinux/config</span><br></pre></td></tr></table></figure><p>将第6行修改为SELINUX=permissive<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># This file controls the state of SELinux on the system.</span><br><span class="line"># SELINUX= can take one of these three values:</span><br><span class="line">#     enforcing - SELinux security policy is enforced.</span><br><span class="line">#     permissive - SELinux prints warnings instead of enforcing.</span><br><span class="line">#     disabled - No SELinux policy is loaded.</span><br><span class="line">SELINUX=permissive</span><br><span class="line"># SELINUXTYPE= can take one of three two values:</span><br><span class="line">#     targeted - Targeted processes are protected,</span><br><span class="line">#     minimum - Modification of targeted policy. Only selected processes are protected.</span><br><span class="line">#     mls - Multi Level Security protection.</span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure></p><h2 id="设置hostname"><a href="#设置hostname" class="headerlink" title="设置hostname"></a>设置hostname</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hostnamectl set-hostname salt-master</span><br></pre></td></tr></table></figure><h2 id="修改host文件"><a href="#修改host文件" class="headerlink" title="修改host文件"></a>修改host文件</h2><p>修改/etc/hosts文件为如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.32.140 salt-master</span><br><span class="line">192.168.32.141 salt-minion1</span><br><span class="line">192.168.32.142 salt-minion2</span><br></pre></td></tr></table></figure></p><p>使用scp命令复制到其他2台服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp /etc/hosts root@salt-minion1:/etc/hosts</span><br></pre></td></tr></table></figure></p><h1 id="环境准备，依赖解决"><a href="#环境准备，依赖解决" class="headerlink" title="环境准备，依赖解决"></a>环境准备，依赖解决</h1><p>分别为三台机器添加阿里云epel源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup</span><br><span class="line">$ mv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup</span><br><span class="line">$ wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br></pre></td></tr></table></figure></p><p>解决依赖关系，不然会报python依赖错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum clean expire-cache</span><br><span class="line">$ yum upgrade</span><br><span class="line">$ yum -y install epel-release</span><br><span class="line">$ yum install zeromq3 m2crypto python-crypto python-jinja2 python-msgpack python-yaml python-zmq -y</span><br></pre></td></tr></table></figure><h1 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h1><h2 id="salt-master安装"><a href="#salt-master安装" class="headerlink" title="salt-master安装"></a>salt-master安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y salt-master</span><br></pre></td></tr></table></figure><h2 id="salt-minion安装"><a href="#salt-minion安装" class="headerlink" title="salt-minion安装"></a>salt-minion安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y salt-minion</span><br></pre></td></tr></table></figure><h1 id="配置-amp-启动"><a href="#配置-amp-启动" class="headerlink" title="配置&amp;启动"></a>配置&amp;启动</h1><h2 id="master配置"><a href="#master配置" class="headerlink" title="master配置"></a>master配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/salt/master</span><br></pre></td></tr></table></figure><p>修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#master消息发布端口 Default: 4505</span><br><span class="line">publish_port: 4505</span><br><span class="line">#工作线程数，应答和接受minion Default: 5</span><br><span class="line">worker_threads: 100</span><br><span class="line">#客户端与服务端通信的端口 Default: 4506</span><br><span class="line">ret_port: 4506</span><br><span class="line">#自动接受所有客户端</span><br><span class="line">auto_accept: True</span><br><span class="line">#启动salt-master</span><br></pre></td></tr></table></figure></p><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start salt-master</span><br></pre></td></tr></table></figure></p><h2 id="minion配置"><a href="#minion配置" class="headerlink" title="minion配置"></a>minion配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/salt/minion</span><br></pre></td></tr></table></figure><p>修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># master IP或域名</span><br><span class="line">master: salt-master</span><br><span class="line"># 客户端与服务端通信的端口。 Default: 4506</span><br><span class="line">master_port: 4506</span><br><span class="line"># id minion的唯一标示。Default: hostname</span><br><span class="line">id: salt-minion1</span><br></pre></td></tr></table></figure><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start salt-minion</span><br></pre></td></tr></table></figure></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="查看master的key列表"><a href="#查看master的key列表" class="headerlink" title="查看master的key列表"></a>查看master的key列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# salt-key -L</span><br><span class="line">Accepted Keys:（接受的key）</span><br><span class="line">salt-minion1</span><br><span class="line">salt-minion2</span><br><span class="line">Denied Keys:（否认的key）</span><br><span class="line">Unaccepted Keys:（未接受的key）</span><br><span class="line">Rejected Keys:（拒绝的key）</span><br></pre></td></tr></table></figure><h2 id="salt-key常用参数说明："><a href="#salt-key常用参数说明：" class="headerlink" title="salt-key常用参数说明："></a>salt-key常用参数说明：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-L 列出当前所有认证，包括Accepted Keys、Denied Keys、Unaccepted Keys、Rejected Keys</span><br><span class="line">-a 添加某个或某些个未接受(Unaccepted Keys)认证</span><br><span class="line">-A 添加所有未接受(Unaccepted Keys)认证</span><br><span class="line">-d 删除某个或某些个已接受(Accepted Keys)认证</span><br><span class="line">-D 删除所有已接受(Accepted Keys)认证</span><br><span class="line">-y 使用该参数可免去证书操作的交互，除非对minion端很信任，一般不建议使用</span><br><span class="line">-h 帮助</span><br></pre></td></tr></table></figure><h2 id="test-ping"><a href="#test-ping" class="headerlink" title="test.ping"></a>test.ping</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ salt &apos;*&apos; test.ping</span><br><span class="line">salt-minion1:</span><br><span class="line">True</span><br><span class="line">salt-minion2:</span><br><span class="line">True</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Salt，一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯。&lt;/p&gt;
&lt;p&gt;salt底层采用动态的连接总线, 使其可以用于编配, 远程执行, 配置管理等等.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="运维" scheme="http://wangzx.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>centos7搭建mesos集群</title>
    <link href="http://wangzx.org/2018/01/09/mesos-install/"/>
    <id>http://wangzx.org/2018/01/09/mesos-install/</id>
    <published>2018-01-09T11:08:36.000Z</published>
    <updated>2018-02-09T02:32:37.856Z</updated>
    
    <content type="html"><![CDATA[<p>Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。</p><p><strong><a id="more"></a></strong></p><p>本次搭建使用centos7.1，共搭建3台master，3台slave，ip分配如下：</p><table><thead><tr><th style="text-align:left">服务器ip</th><th style="text-align:left">hostname</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">192.168.32.131</td><td style="text-align:left">docker1.nd.com</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.132</td><td style="text-align:left">docker2.nd.com</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.133</td><td style="text-align:left">docker3.nd.com</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.134</td><td style="text-align:left">docker4.nd.com</td><td style="text-align:left">slave</td></tr><tr><td style="text-align:left">192.168.32.135</td><td style="text-align:left">docker5.nd.com</td><td style="text-align:left">slave</td></tr><tr><td style="text-align:left">192.168.32.136</td><td style="text-align:left">docker6.nd.com</td><td style="text-align:left">slave</td></tr></tbody></table><h1 id="服务器基础设置"><a href="#服务器基础设置" class="headerlink" title="服务器基础设置"></a>服务器基础设置</h1><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld</span><br><span class="line">$ systemctl disable firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ setenforce 0</span><br><span class="line">$ vi /etc/selinux/config</span><br></pre></td></tr></table></figure><p>将第6行修改为SELINUX=permissive<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># This file controls the state of SELinux on the system.</span><br><span class="line"># SELINUX= can take one of these three values:</span><br><span class="line">#     enforcing - SELinux security policy is enforced.</span><br><span class="line">#     permissive - SELinux prints warnings instead of enforcing.</span><br><span class="line">#     disabled - No SELinux policy is loaded.</span><br><span class="line">SELINUX=permissive</span><br><span class="line"># SELINUXTYPE= can take one of three two values:</span><br><span class="line">#     targeted - Targeted processes are protected,</span><br><span class="line">#     minimum - Modification of targeted policy. Only selected processes are protected.</span><br><span class="line">#     mls - Multi Level Security protection.</span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure></p><h2 id="设置hostname"><a href="#设置hostname" class="headerlink" title="设置hostname"></a>设置hostname</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hostnamectl set-hostname docker1.nd.com</span><br></pre></td></tr></table></figure><h2 id="修改host文件"><a href="#修改host文件" class="headerlink" title="修改host文件"></a>修改host文件</h2><p>修改/etc/hosts文件为如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">192.168.32.131 docker1.nd.com</span><br><span class="line">192.168.32.132 docker2.nd.com</span><br><span class="line">192.168.32.133 docker3.nd.com</span><br><span class="line">192.168.32.134 docker4.nd.com</span><br><span class="line">192.168.32.135 docker5.nd.com</span><br><span class="line">192.168.32.136 docker6.nd.com</span><br></pre></td></tr></table></figure></p><p>使用scp命令复制到其他5台服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp /etc/hosts root@docker2.nd.com:/etc/hosts</span><br></pre></td></tr></table></figure></p><h1 id="安装mesos、zookeeper包"><a href="#安装mesos、zookeeper包" class="headerlink" title="安装mesos、zookeeper包"></a>安装mesos、zookeeper包</h1><p> 1、分别在6台服务器上执行如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -Uvh http://repos.mesosphere.io/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm</span><br><span class="line">$ rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-mesosphere</span><br></pre></td></tr></table></figure></p><p>2、进入3台master服务器安装mesos、marathon和zookeeper<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install mesos marathon mesosphere-zookeeper -y</span><br></pre></td></tr></table></figure></p><p>3、进入3台slave服务器安装mesos<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install mesos -y</span><br></pre></td></tr></table></figure></p><h1 id="配置mesos、zookeeper"><a href="#配置mesos、zookeeper" class="headerlink" title="配置mesos、zookeeper"></a>配置mesos、zookeeper</h1><h2 id="配置zookeeper"><a href="#配置zookeeper" class="headerlink" title="配置zookeeper"></a>配置zookeeper</h2><p>1、修改/var/lib/zookeeper/myid文件，三台master服务器，分别设置为1、2、3<br>2、修改/etc/zookeeper/conf/zoo.cfg文件，在文件末尾添加以下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=192.168.32.131:2888:3888</span><br><span class="line">server.2=192.168.32.132:2888:3888</span><br><span class="line">server.3=192.168.32.133:2888:3888</span><br></pre></td></tr></table></figure></p><p>3、启动zookeeper服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start zookeeper</span><br></pre></td></tr></table></figure></p><p>4、查看zookeeper服务是否已启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl is-active zookeeper</span><br></pre></td></tr></table></figure><h2 id="配置mesos-master"><a href="#配置mesos-master" class="headerlink" title="配置mesos-master"></a>配置mesos-master</h2><p>1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos</span><br></pre></td></tr></table></figure></p><p>2、设置/etc/mesos-master/quorum文件中quorum的值，这个值要大于master数量的1/2，我们这里设置为2<br>3、停用mesos-slave<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop mesos-slave.service</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl disable mesos-slave.service</span><br></pre></td></tr></table></figure><p>4、启动mesos-master marathon<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start mesos-master</span><br><span class="line">$ marathon --master zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos</span><br></pre></td></tr></table></figure></p><p>正常情况下此时已经可以通过<a href="http://docker1.nd.com:5050打开mesos页面" target="_blank" rel="noopener">http://docker1.nd.com:5050打开mesos页面</a></p><h2 id="配置mesos-slave"><a href="#配置mesos-slave" class="headerlink" title="配置mesos-slave"></a>配置mesos-slave</h2><p>1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos</span><br></pre></td></tr></table></figure></p><p>2、停用mesos-master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop mesos-master.service</span><br><span class="line">$ systemctl disable mesos-master.service</span><br></pre></td></tr></table></figure></p><p>3、启动mesos-slave<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start mesos-slave</span><br></pre></td></tr></table></figure></p><h1 id="docker配置"><a href="#docker配置" class="headerlink" title="docker配置"></a>docker配置</h1><p>如需要在slave上运行docker，除docker自身安装配置外，还需要做如下设置<br>1、指定使用docker容器化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;docker,mesos&apos; &gt; /etc/mesos-slave/containerizers</span><br></pre></td></tr></table></figure></p><p>2、考虑到拉取容器镜像等的操作，适当增加timeout的时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;5mins&apos; &gt; /etc/mesos-slave/executor_registration_timeout</span><br></pre></td></tr></table></figure></p><p>3、重启mesos-slave以使上面配置生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart mesos-slave</span><br></pre></td></tr></table></figure></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>在测试环境中我们可以关闭防火墙，但在生产环境中，为了安全考虑，还是需要将防火墙开启<br>此时应注意，master需要向agent的所有ip开放5050端口，所有agent需要向master开放5051端口<br>并且为了用户可以访问mesos的前端页面，master需向用户ip开放5050端口，所有agent也需要向用户ip开放5051端口，否则会出现agent信息无法查看，task日志无法查看等问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="运维" scheme="http://wangzx.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
</feed>
