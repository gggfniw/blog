<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王志兴的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangzx.org/"/>
  <updated>2018-05-15T11:56:52.126Z</updated>
  <id>http://wangzx.org/</id>
  
  <author>
    <name>王志兴</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《dubbo源码深度解析》之config配置层</title>
    <link href="http://wangzx.org/2018/05/15/dubbo-config/"/>
    <id>http://wangzx.org/2018/05/15/dubbo-config/</id>
    <published>2018-05-15T11:55:29.000Z</published>
    <updated>2018-05-15T11:56:52.126Z</updated>
    
    <content type="html"><![CDATA[<p>config层是dubbo架构中的第二层，第一层的service即是我们的业务层，因此我们从config层开始看，config层在官网中的解释如下:</p><blockquote><p>配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类<br><strong><a id="more"></a></strong></p></blockquote><h1 id="spring自定义标签"><a href="#spring自定义标签" class="headerlink" title="spring自定义标签"></a>spring自定义标签</h1><p>我们在通过xml文件配置dubbo时，使用了dubbo给我们提供的spring自定义标签，入口类在dubbo-config包下的DubboNamespaceHandler文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false));</span><br><span class="line">        registerBeanDefinitionParser(&quot;annotation&quot;, new DubboBeanDefinitionParser(AnnotationBean.class, true));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在xml中配置的标签，将会转换为如ApplicationConfig、RegistryConfig、ProtocolConfig、ServiceBean等一个个bean，xml到bean的过程，不是重点，我们稍微看下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) &#123;</span><br><span class="line">    RootBeanDefinition beanDefinition = new RootBeanDefinition();</span><br><span class="line">    beanDefinition.setBeanClass(beanClass);</span><br><span class="line">    beanDefinition.setLazyInit(false);</span><br><span class="line">    String id = element.getAttribute(&quot;id&quot;);</span><br><span class="line">    if ((id == null || id.length() == 0) &amp;&amp; required) &#123;</span><br><span class="line">        String generatedBeanName = element.getAttribute(&quot;name&quot;);</span><br><span class="line">        if (generatedBeanName == null || generatedBeanName.length() == 0) &#123;</span><br><span class="line">            if (ProtocolConfig.class.equals(beanClass)) &#123;</span><br><span class="line">                generatedBeanName = &quot;dubbo&quot;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                generatedBeanName = element.getAttribute(&quot;interface&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (generatedBeanName == null || generatedBeanName.length() == 0) &#123;</span><br><span class="line">            generatedBeanName = beanClass.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        id = generatedBeanName;</span><br><span class="line">        int counter = 2;</span><br><span class="line">        while (parserContext.getRegistry().containsBeanDefinition(id)) &#123;</span><br><span class="line">            id = generatedBeanName + (counter++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (id != null &amp;&amp; id.length() &gt; 0) &#123;</span><br><span class="line">        if (parserContext.getRegistry().containsBeanDefinition(id)) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Duplicate spring bean id &quot; + id);</span><br><span class="line">        &#125;</span><br><span class="line">        parserContext.getRegistry().registerBeanDefinition(id, beanDefinition);</span><br><span class="line">        beanDefinition.getPropertyValues().addPropertyValue(&quot;id&quot;, id);</span><br><span class="line">    &#125;</span><br><span class="line">    if (ProtocolConfig.class.equals(beanClass)) &#123;</span><br><span class="line">        for (String name : parserContext.getRegistry().getBeanDefinitionNames()) &#123;</span><br><span class="line">            BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name);</span><br><span class="line">            PropertyValue property = definition.getPropertyValues().getPropertyValue(&quot;protocol&quot;);</span><br><span class="line">            if (property != null) &#123;</span><br><span class="line">                Object value = property.getValue();</span><br><span class="line">                if (value instanceof ProtocolConfig &amp;&amp; id.equals(((ProtocolConfig) value).getName())) &#123;</span><br><span class="line">                    definition.getPropertyValues().addPropertyValue(&quot;protocol&quot;, new RuntimeBeanReference(id));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (ServiceBean.class.equals(beanClass)) &#123;</span><br><span class="line">        String className = element.getAttribute(&quot;class&quot;);</span><br><span class="line">        if (className != null &amp;&amp; className.length() &gt; 0) &#123;</span><br><span class="line">            RootBeanDefinition classDefinition = new RootBeanDefinition();</span><br><span class="line">            classDefinition.setBeanClass(ReflectUtils.forName(className));</span><br><span class="line">            classDefinition.setLazyInit(false);</span><br><span class="line">            parseProperties(element.getChildNodes(), classDefinition);</span><br><span class="line">            beanDefinition.getPropertyValues().addPropertyValue(&quot;ref&quot;, new BeanDefinitionHolder(classDefinition, id + &quot;Impl&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (ProviderConfig.class.equals(beanClass)) &#123;</span><br><span class="line">        parseNested(element, parserContext, ServiceBean.class, true, &quot;service&quot;, &quot;provider&quot;, id, beanDefinition);</span><br><span class="line">    &#125; else if (ConsumerConfig.class.equals(beanClass)) &#123;</span><br><span class="line">        parseNested(element, parserContext, ReferenceBean.class, false, &quot;reference&quot;, &quot;consumer&quot;, id, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; props = new HashSet&lt;String&gt;();</span><br><span class="line">    ManagedMap parameters = null;</span><br><span class="line">    //省略部分代码</span><br><span class="line">    NamedNodeMap attributes = element.getAttributes();</span><br><span class="line">    int len = attributes.getLength();</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        Node node = attributes.item(i);</span><br><span class="line">        String name = node.getLocalName();</span><br><span class="line">        if (!props.contains(name)) &#123;</span><br><span class="line">            if (parameters == null) &#123;</span><br><span class="line">                parameters = new ManagedMap();</span><br><span class="line">            &#125;</span><br><span class="line">            String value = node.getNodeValue();</span><br><span class="line">            parameters.put(name, new TypedStringValue(value, String.class));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (parameters != null) &#123;</span><br><span class="line">        beanDefinition.getPropertyValues().addPropertyValue(&quot;parameters&quot;, parameters);</span><br><span class="line">    &#125;</span><br><span class="line">    return beanDefinition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造BeanDefinition的过程并没有什么特殊，但由于dubbo把所有的解析过程都写在这个方法里，看上去难免杂乱一些，与其看BeanDefinition的解析过程，还不如看最终解析出了什么东西，在此之前先附上xml配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;</span><br><span class="line">       xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span><br><span class="line">http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span><br><span class="line">    &lt;dubbo:application name=&quot;demo-provider&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;</span><br><span class="line">    &lt;dubbo:registry address=&quot;192.168.32.145:2181&quot; protocol=&quot;zookeeper&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span><br><span class="line">    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 声明需要暴露的服务接口 --&gt;</span><br><span class="line">    &lt;bean id=&quot;demoService&quot; class=&quot;com.alibaba.dubbo.demo.provider.DemoServiceImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 和本地bean一样实现服务 --&gt;</span><br><span class="line">    &lt;dubbo:service interface=&quot;com.alibaba.dubbo.demo.DemoService&quot; ref=&quot;demoService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p><p>ApplicationConfig:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;demo-provider&quot;</span><br><span class="line">version = null</span><br><span class="line">owner = null</span><br><span class="line">organization = null</span><br><span class="line">architecture = null</span><br><span class="line">environment = null</span><br><span class="line">compiler = null</span><br><span class="line">logger = null</span><br><span class="line">registries = null</span><br><span class="line">monitor = null</span><br><span class="line">isDefault = null</span><br><span class="line">id = &quot;demo-provider&quot; //自动把id设置为和name一样</span><br></pre></td></tr></table></figure></p><p>RegistryConfig:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">address = &quot;192.168.32.145:2181&quot;</span><br><span class="line">username = null</span><br><span class="line">password = null</span><br><span class="line">port = null</span><br><span class="line">protocol = &quot;zookeeper&quot;</span><br><span class="line">transporter = null</span><br><span class="line">server = null</span><br><span class="line">client = null</span><br><span class="line">cluster = null</span><br><span class="line">group = null</span><br><span class="line">version = null</span><br><span class="line">timeout = null</span><br><span class="line">session = null</span><br><span class="line">file = null</span><br><span class="line">wait = null</span><br><span class="line">check = null</span><br><span class="line">dynamic = null</span><br><span class="line">register = null</span><br><span class="line">subscribe = null</span><br><span class="line">parameters = null</span><br><span class="line">isDefault = null</span><br><span class="line">id = &quot;com.alibaba.dubbo.config.RegistryConfig&quot; //自动设置了id</span><br></pre></td></tr></table></figure></p><p>ProtocolConfig：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;dubbo&quot;</span><br><span class="line">host = null</span><br><span class="line">port = &#123;Integer@1956&#125; &quot;20880&quot;</span><br><span class="line">contextpath = null</span><br><span class="line">threadpool = null</span><br><span class="line">threads = null</span><br><span class="line">iothreads = null</span><br><span class="line">queues = null</span><br><span class="line">accepts = null</span><br><span class="line">codec = null</span><br><span class="line">serialization = null</span><br><span class="line">charset = null</span><br><span class="line">payload = null</span><br><span class="line">buffer = null</span><br><span class="line">heartbeat = null</span><br><span class="line">accesslog = null</span><br><span class="line">transporter = null</span><br><span class="line">exchanger = null</span><br><span class="line">dispatcher = null</span><br><span class="line">networker = null</span><br><span class="line">server = null</span><br><span class="line">client = null</span><br><span class="line">telnet = null</span><br><span class="line">prompt = null</span><br><span class="line">status = null</span><br><span class="line">register = null</span><br><span class="line">parameters = null</span><br><span class="line">isDefault = null</span><br><span class="line">id = &quot;dubbo&quot; //自动把id设置为和name一样</span><br></pre></td></tr></table></figure></p><p>可以看到基本上就和我们在配置文件中看到的一样，当然，这是在最简单的配置下，如果有配置多注册中心，多protocol，配置method等，解析过程就稍微复杂一些。</p><h1 id="ServiceConfig"><a href="#ServiceConfig" class="headerlink" title="ServiceConfig"></a>ServiceConfig</h1><p>代码的入口在ServiceBean这个类中，这里有两个关键方法：afterPropertiesSet()和onApplicationEvent()，在初始化这个Bean的时候会调用afterPropertiesSet()方法，这个方法的主要作用，就是获取ApplicationConfig、RegistryConfig、ProtocolConfig等对象，注入到ServiceBean当中，已供ServiceBean在后续的服务暴露过程中使用。onApplicationEvent()方法会在spring初始化完成后调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void onApplicationEvent(ApplicationEvent event) &#123;</span><br><span class="line">        if (ContextRefreshedEvent.class.getName().equals(event.getClass().getName())) &#123;</span><br><span class="line">            if (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">                if (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(&quot;The service ready on spring started. service: &quot; + getInterface());</span><br><span class="line">                &#125;</span><br><span class="line">                export();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>export()方法在其父类ServiceConfig中，这个方法就做一些简单的检查后跳到doExport()方法，在这个方法中，除了一些检查设置外，还有一个填充默认配置的方法：appendProperties(this)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">protected static void appendProperties(AbstractConfig config) &#123;</span><br><span class="line">        if (config == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String prefix = &quot;dubbo.&quot; + getTagName(config.getClass()) + &quot;.&quot;;</span><br><span class="line">        Method[] methods = config.getClass().getMethods();</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String name = method.getName();</span><br><span class="line">                if (name.length() &gt; 3 &amp;&amp; name.startsWith(&quot;set&quot;) &amp;&amp; Modifier.isPublic(method.getModifiers())</span><br><span class="line">                        &amp;&amp; method.getParameterTypes().length == 1 &amp;&amp; isPrimitive(method.getParameterTypes()[0])) &#123;</span><br><span class="line">                    String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), &quot;-&quot;);</span><br><span class="line"></span><br><span class="line">                    String value = null;</span><br><span class="line">                    if (config.getId() != null &amp;&amp; config.getId().length() &gt; 0) &#123;</span><br><span class="line">                        String pn = prefix + config.getId() + &quot;.&quot; + property;</span><br><span class="line">                        value = System.getProperty(pn);</span><br><span class="line">                        if (!StringUtils.isBlank(value)) &#123;</span><br><span class="line">                            logger.info(&quot;Use System Property &quot; + pn + &quot; to config dubbo&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (value == null || value.length() == 0) &#123;</span><br><span class="line">                        String pn = prefix + property;</span><br><span class="line">                        value = System.getProperty(pn);</span><br><span class="line">                        if (!StringUtils.isBlank(value)) &#123;</span><br><span class="line">                            logger.info(&quot;Use System Property &quot; + pn + &quot; to config dubbo&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (value == null || value.length() == 0) &#123;</span><br><span class="line">                        Method getter;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            getter = config.getClass().getMethod(&quot;get&quot; + name.substring(3), new Class&lt;?&gt;[0]);</span><br><span class="line">                        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                getter = config.getClass().getMethod(&quot;is&quot; + name.substring(3), new Class&lt;?&gt;[0]);</span><br><span class="line">                            &#125; catch (NoSuchMethodException e2) &#123;</span><br><span class="line">                                getter = null;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (getter != null) &#123;</span><br><span class="line">                            if (getter.invoke(config, new Object[0]) == null) &#123;</span><br><span class="line">                                if (config.getId() != null &amp;&amp; config.getId().length() &gt; 0) &#123;</span><br><span class="line">                                    value = ConfigUtils.getProperty(prefix + config.getId() + &quot;.&quot; + property);</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (value == null || value.length() == 0) &#123;</span><br><span class="line">                                    value = ConfigUtils.getProperty(prefix + property);</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (value == null || value.length() == 0) &#123;</span><br><span class="line">                                    String legacyKey = legacyProperties.get(prefix + property);</span><br><span class="line">                                    if (legacyKey != null &amp;&amp; legacyKey.length() &gt; 0) &#123;</span><br><span class="line">                                        value = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey));</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (value != null &amp;&amp; value.length() &gt; 0) &#123;</span><br><span class="line">                        method.invoke(config, new Object[]&#123;convertPrimitive(method.getParameterTypes()[0], value)&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的主要作用，是从系统的环境变量、dubbo.properties中获取配置，注入到ApplicationConfig、RegistryConfig、ProtocolConfig等对象中，这也是dubbo默认参数的实现方式，可以将一些公共的配置，写在dubbo.properties中，dubbo会帮我们注入，由于我们没有使用dubbo.properties配置，因此这一轮检查和注入过后，配置没有发生变化，之后就到了正在开始暴露服务：doExportUrls():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void doExportUrls() &#123;</span><br><span class="line">        List&lt;URL&gt; registryURLs = loadRegistries(true);</span><br><span class="line">        for (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">            doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法首先进行了url的组装：loadRegistries(boolean provider)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;URL&gt; loadRegistries(boolean provider) &#123;</span><br><span class="line">        checkRegistry();</span><br><span class="line">        List&lt;URL&gt; registryList = new ArrayList&lt;URL&gt;();</span><br><span class="line">        if (registries != null &amp;&amp; registries.size() &gt; 0) &#123;</span><br><span class="line">            for (RegistryConfig config : registries) &#123;</span><br><span class="line">                String address = config.getAddress();</span><br><span class="line">                if (address == null || address.length() == 0) &#123;</span><br><span class="line">                    address = Constants.ANYHOST_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                String sysaddress = System.getProperty(&quot;dubbo.registry.address&quot;);</span><br><span class="line">                if (sysaddress != null &amp;&amp; sysaddress.length() &gt; 0) &#123;</span><br><span class="line">                    address = sysaddress;</span><br><span class="line">                &#125;</span><br><span class="line">                if (address != null &amp;&amp; address.length() &gt; 0</span><br><span class="line">                        &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123;</span><br><span class="line">                    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">                    appendParameters(map, application);</span><br><span class="line">                    appendParameters(map, config);</span><br><span class="line">                    map.put(&quot;path&quot;, RegistryService.class.getName());</span><br><span class="line">                    map.put(&quot;dubbo&quot;, Version.getVersion());</span><br><span class="line">                    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                    if (ConfigUtils.getPid() &gt; 0) &#123;</span><br><span class="line">                        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!map.containsKey(&quot;protocol&quot;)) &#123;</span><br><span class="line">                        if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(&quot;remote&quot;)) &#123;</span><br><span class="line">                            map.put(&quot;protocol&quot;, &quot;remote&quot;);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            map.put(&quot;protocol&quot;, &quot;dubbo&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map);</span><br><span class="line">                    for (URL url : urls) &#123;</span><br><span class="line">                        url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());</span><br><span class="line">                        url = url.setProtocol(Constants.REGISTRY_PROTOCOL);</span><br><span class="line">                        if ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true))</span><br><span class="line">                                || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, true))) &#123;</span><br><span class="line">                            registryList.add(url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return registryList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法分为2部分，第一部分组装map和address，第二部分根据map和address生成url，在第一部分中有个比较重要的方法：appendParameters()：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">protected static void appendParameters(Map&lt;String, String&gt; parameters, Object config, String prefix) &#123;</span><br><span class="line">        if (config == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Method[] methods = config.getClass().getMethods();</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String name = method.getName();</span><br><span class="line">                if ((name.startsWith(&quot;get&quot;) || name.startsWith(&quot;is&quot;))</span><br><span class="line">                        &amp;&amp; !&quot;getClass&quot;.equals(name)</span><br><span class="line">                        &amp;&amp; Modifier.isPublic(method.getModifiers())</span><br><span class="line">                        &amp;&amp; method.getParameterTypes().length == 0</span><br><span class="line">                        &amp;&amp; isPrimitive(method.getReturnType())) &#123;</span><br><span class="line">                    Parameter parameter = method.getAnnotation(Parameter.class);</span><br><span class="line">                    if (method.getReturnType() == Object.class || parameter != null &amp;&amp; parameter.excluded()) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    int i = name.startsWith(&quot;get&quot;) ? 3 : 2;</span><br><span class="line">                    String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), &quot;.&quot;);</span><br><span class="line">                    String key;</span><br><span class="line">                    if (parameter != null &amp;&amp; parameter.key() != null &amp;&amp; parameter.key().length() &gt; 0) &#123;</span><br><span class="line">                        key = parameter.key();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        key = prop;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Object value = method.invoke(config, new Object[0]);</span><br><span class="line">                    String str = String.valueOf(value).trim();</span><br><span class="line">                    if (value != null &amp;&amp; str.length() &gt; 0) &#123;</span><br><span class="line">                        if (parameter != null &amp;&amp; parameter.escaped()) &#123;</span><br><span class="line">                            str = URL.encode(str);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (parameter != null &amp;&amp; parameter.append()) &#123;</span><br><span class="line">                            String pre = (String) parameters.get(Constants.DEFAULT_KEY + &quot;.&quot; + key);</span><br><span class="line">                            if (pre != null &amp;&amp; pre.length() &gt; 0) &#123;</span><br><span class="line">                                str = pre + &quot;,&quot; + str;</span><br><span class="line">                            &#125;</span><br><span class="line">                            pre = (String) parameters.get(key);</span><br><span class="line">                            if (pre != null &amp;&amp; pre.length() &gt; 0) &#123;</span><br><span class="line">                                str = pre + &quot;,&quot; + str;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (prefix != null &amp;&amp; prefix.length() &gt; 0) &#123;</span><br><span class="line">                            key = prefix + &quot;.&quot; + key;</span><br><span class="line">                        &#125;</span><br><span class="line">                        parameters.put(key, str);</span><br><span class="line">                    &#125; else if (parameter != null &amp;&amp; parameter.required()) &#123;</span><br><span class="line">                        throw new IllegalStateException(config.getClass().getSimpleName() + &quot;.&quot; + key + &quot; == null&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (&quot;getParameters&quot;.equals(name)</span><br><span class="line">                        &amp;&amp; Modifier.isPublic(method.getModifiers())</span><br><span class="line">                        &amp;&amp; method.getParameterTypes().length == 0</span><br><span class="line">                        &amp;&amp; method.getReturnType() == Map.class) &#123;</span><br><span class="line">                    Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) method.invoke(config, new Object[0]);</span><br><span class="line">                    if (map != null &amp;&amp; map.size() &gt; 0) &#123;</span><br><span class="line">                        String pre = (prefix != null &amp;&amp; prefix.length() &gt; 0 ? prefix + &quot;.&quot; : &quot;&quot;);</span><br><span class="line">                        for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">                            parameters.put(pre + entry.getKey().replace(&apos;-&apos;, &apos;.&apos;), entry.getValue());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new IllegalStateException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的作用如下：遍历传进来的config对象的所有方法，如果是get或is开头，就调用该方法，如果返回值不为空，就存入map中，存入的key跟该方法是否有@Parameter注解有关，如果有，则以这个注解指定的key作为key值。</p><p>最终收集到的map如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 = &#123;HashMap$Entry@1722&#125; &quot;timestamp&quot; -&gt; &quot;1526381630841&quot;</span><br><span class="line">1 = &#123;HashMap$Entry@1723&#125; &quot;dubbo&quot; -&gt; &quot;2.0.0&quot;</span><br><span class="line">2 = &#123;HashMap$Entry@1724&#125; &quot;protocol&quot; -&gt; &quot;zookeeper&quot;</span><br><span class="line">3 = &#123;HashMap$Entry@1725&#125; &quot;application&quot; -&gt; &quot;demo-provider&quot;</span><br><span class="line">4 = &#123;HashMap$Entry@1726&#125; &quot;path&quot; -&gt; &quot;com.alibaba.dubbo.registry.RegistryService&quot;</span><br><span class="line">5 = &#123;HashMap$Entry@1727&#125; &quot;pid&quot; -&gt; &quot;1448&quot;</span><br></pre></td></tr></table></figure></p><p>然后调用UrlUtils.parseURLs(address, map)方法组装url，这个方法就是一些拼装逻辑，与其去看它如何拼装，不如看下最终拼装的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper://192.168.32.145:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.0&amp;pid=1448&amp;registry=zookeeper&amp;timestamp=1526381630841</span><br></pre></td></tr></table></figure><p>url拼装完成后，调用doExportUrlsFor1Protocol(protocolConfig, registryURLs)方法，这个方法是Config层的最后一个方法，这个方法过后将转到Registry层,由于这个方法太长，因此这里分为为2个部分进行说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123;</span><br><span class="line">        //省略代码</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">        if (anyhost) &#123;</span><br><span class="line">            map.put(Constants.ANYHOST_KEY, &quot;true&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">        map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());</span><br><span class="line">        map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        if (ConfigUtils.getPid() &gt; 0) &#123;</span><br><span class="line">            map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">        &#125;</span><br><span class="line">        appendParameters(map, application);</span><br><span class="line">        appendParameters(map, module);</span><br><span class="line">        appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">        appendParameters(map, protocolConfig);</span><br><span class="line">        appendParameters(map, this);</span><br><span class="line">        if (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">            map.put(&quot;generic&quot;, generic);</span><br><span class="line">            map.put(&quot;methods&quot;, Constants.ANY_VALUE);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">            if (revision != null &amp;&amp; revision.length() &gt; 0) &#123;</span><br><span class="line">                map.put(&quot;revision&quot;, revision);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">            if (methods.length == 0) &#123;</span><br><span class="line">                logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName());</span><br><span class="line">                map.put(&quot;methods&quot;, Constants.ANY_VALUE);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                map.put(&quot;methods&quot;, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">            if (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">                map.put(&quot;token&quot;, UUID.randomUUID().toString());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                map.put(&quot;token&quot;, token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;injvm&quot;.equals(protocolConfig.getName())) &#123;</span><br><span class="line">            protocolConfig.setRegister(false);</span><br><span class="line">            map.put(&quot;notify&quot;, &quot;false&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //省略第二部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的作用跟上面的方法一样，从各个config中，获取信息组装到map中，最后的结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 = &#123;HashMap$Entry@2469&#125; &quot;methods&quot; -&gt; &quot;sayHello&quot;</span><br><span class="line">1 = &#123;HashMap$Entry@2204&#125; &quot;generic&quot; -&gt; &quot;false&quot;</span><br><span class="line">2 = &#123;HashMap$Entry@2205&#125; &quot;timestamp&quot; -&gt; &quot;1526382333491&quot;</span><br><span class="line">3 = &#123;HashMap$Entry@2206&#125; &quot;dubbo&quot; -&gt; &quot;2.0.0&quot;</span><br><span class="line">4 = &#123;HashMap$Entry@2207&#125; &quot;application&quot; -&gt; &quot;demo-provider&quot;</span><br><span class="line">5 = &#123;HashMap$Entry@2208&#125; &quot;side&quot; -&gt; &quot;provider&quot;</span><br><span class="line">6 = &#123;HashMap$Entry@2209&#125; &quot;pid&quot; -&gt; &quot;1448&quot;</span><br><span class="line">7 = &#123;HashMap$Entry@2210&#125; &quot;interface&quot; -&gt; &quot;com.alibaba.dubbo.demo.DemoService&quot;</span><br><span class="line">8 = &#123;HashMap$Entry@2211&#125; &quot;anyhost&quot; -&gt; &quot;true&quot;</span><br></pre></td></tr></table></figure></p><p>第二部分代码，根据这个map，组装url，然后进行export：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123;</span><br><span class="line">        //省略第一部分代码</span><br><span class="line">        // 导出服务</span><br><span class="line">        String contextPath = protocolConfig.getContextpath();</span><br><span class="line">        if ((contextPath == null || contextPath.length() == 0) &amp;&amp; provider != null) &#123;</span><br><span class="line">            contextPath = provider.getContextpath();</span><br><span class="line">        &#125;</span><br><span class="line">        URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? &quot;&quot; : contextPath + &quot;/&quot;) + path, map);</span><br><span class="line"></span><br><span class="line">        if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">            url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                    .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line">        //配置为none不暴露</span><br><span class="line">        if (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line"></span><br><span class="line">            //配置不是remote的情况下做本地暴露 (配置为remote，则表示只暴露远程服务)</span><br><span class="line">            if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                exportLocal(url);</span><br><span class="line">            &#125;</span><br><span class="line">            //如果配置不是local则暴露为远程服务.(配置为local，则表示只暴露本地服务)</span><br><span class="line">            if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">                if (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() + &quot; to url &quot; + url);</span><br><span class="line">                &#125;</span><br><span class="line">                if (registryURLs != null &amp;&amp; registryURLs.size() &gt; 0</span><br><span class="line">                        &amp;&amp; url.getParameter(&quot;register&quot;, true)) &#123;</span><br><span class="line">                    for (URL registryURL : registryURLs) &#123;</span><br><span class="line">                        url = url.addParameterIfAbsent(&quot;dynamic&quot;, registryURL.getParameter(&quot;dynamic&quot;));</span><br><span class="line">                        URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line">                        if (monitorUrl != null) &#123;</span><br><span class="line">                            url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(&quot;Register dubbo service &quot; + interfaceClass.getName() + &quot; url &quot; + url + &quot; to registry &quot; + registryURL);</span><br><span class="line">                        &#125;</span><br><span class="line">                        Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line"></span><br><span class="line">                        Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br><span class="line">                        exporters.add(exporter);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line"></span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(invoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.urls.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先进行了一次url组装，组装结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo://192.168.252.169:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=1448&amp;side=provider&amp;timestamp=1526382333491</span><br></pre></td></tr></table></figure></p><p>然后判断url中的scope属性的值，如果是remote，则值进行远程暴露，如果是local，则只进行本地暴露，本地暴露和远程暴露的逻辑差不多，首先是获取一个Invoker，然后进行export，export完成后存入List<exporter<?>&gt; exporters这个对象中，这里的Invoker，是dubbo中贯穿全文的对象，我们将在新的篇幅中来说明这个对象。</exporter<?></p><h1 id="ReferenceConfig"><a href="#ReferenceConfig" class="headerlink" title="ReferenceConfig"></a>ReferenceConfig</h1><p>ReferenceConfig的入口在ReferenceBean的getObject()方法中，这个方法返回的即是com.alibaba.dubbo.demo.DemoService这个接口的代理对象，跟ServiceBean相同的是，ReferenceBean也进行过afterPropertiesSet()方法，进行config注入，我们来看下getObject的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">private void init() &#123;</span><br><span class="line">        // 获取消费者全局配置</span><br><span class="line">        checkDefault();</span><br><span class="line">        appendProperties(this);</span><br><span class="line">        checkApplication();</span><br><span class="line">        checkStubAndMock(interfaceClass);</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; attributes = new HashMap&lt;Object, Object&gt;();</span><br><span class="line">        map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);</span><br><span class="line">        map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());</span><br><span class="line">        map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">        if (ConfigUtils.getPid() &gt; 0) &#123;</span><br><span class="line">            map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">        &#125;</span><br><span class="line">        if (!isGeneric()) &#123;</span><br><span class="line">            String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">            if (revision != null &amp;&amp; revision.length() &gt; 0) &#123;</span><br><span class="line">                map.put(&quot;revision&quot;, revision);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">            if (methods.length == 0) &#123;</span><br><span class="line">                logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName());</span><br><span class="line">                map.put(&quot;methods&quot;, Constants.ANY_VALUE);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                map.put(&quot;methods&quot;, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(Constants.INTERFACE_KEY, interfaceName);</span><br><span class="line">        appendParameters(map, application);</span><br><span class="line">        appendParameters(map, module);</span><br><span class="line">        appendParameters(map, consumer, Constants.DEFAULT_KEY);</span><br><span class="line">        appendParameters(map, this);</span><br><span class="line">        String prifix = StringUtils.getServiceKey(map);</span><br><span class="line">        if (methods != null &amp;&amp; methods.size() &gt; 0) &#123;</span><br><span class="line">            for (MethodConfig method : methods) &#123;</span><br><span class="line">                appendParameters(map, method, method.getName());</span><br><span class="line">                String retryKey = method.getName() + &quot;.retry&quot;;</span><br><span class="line">                if (map.containsKey(retryKey)) &#123;</span><br><span class="line">                    String retryValue = map.remove(retryKey);</span><br><span class="line">                    if (&quot;false&quot;.equals(retryValue)) &#123;</span><br><span class="line">                        map.put(method.getName() + &quot;.retries&quot;, &quot;0&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                appendAttributes(attributes, method, prifix + &quot;.&quot; + method.getName());</span><br><span class="line">                checkAndConvertImplicitConfig(method, map, attributes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //attributes通过系统context进行存储.</span><br><span class="line">        StaticContext.getSystemContext().putAll(attributes);</span><br><span class="line">        ref = createProxy(map);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个方法跟ServiceConfig中的非常相似，都是通过appendParameters()方法获取各个config的值，存入到map中，最终map的值如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 = &#123;HashMap$Entry@1819&#125; &quot;methods&quot; -&gt; &quot;sayHello&quot;</span><br><span class="line">1 = &#123;HashMap$Entry@1820&#125; &quot;timestamp&quot; -&gt; &quot;1526384412044&quot;</span><br><span class="line">2 = &#123;HashMap$Entry@1821&#125; &quot;dubbo&quot; -&gt; &quot;2.0.0&quot;</span><br><span class="line">3 = &#123;HashMap$Entry@1822&#125; &quot;application&quot; -&gt; &quot;demo-consumer&quot;</span><br><span class="line">4 = &#123;HashMap$Entry@1823&#125; &quot;check&quot; -&gt; &quot;false&quot;</span><br><span class="line">5 = &#123;HashMap$Entry@1824&#125; &quot;side&quot; -&gt; &quot;consumer&quot;</span><br><span class="line">6 = &#123;HashMap$Entry@1825&#125; &quot;pid&quot; -&gt; &quot;6564&quot;</span><br><span class="line">7 = &#123;HashMap$Entry@1826&#125; &quot;interface&quot; -&gt; &quot;com.alibaba.dubbo.demo.DemoService&quot;</span><br></pre></td></tr></table></figure></p><p>然后根据这个map，创建代理对象：createProxy(map)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private T createProxy(Map&lt;String, String&gt; map) &#123;</span><br><span class="line">    //省略代码</span><br><span class="line">    List&lt;URL&gt; us = loadRegistries(false);</span><br><span class="line">    if (us != null &amp;&amp; us.size() &gt; 0) &#123;</span><br><span class="line">        for (URL u : us) &#123;</span><br><span class="line">            URL monitorUrl = loadMonitor(u);</span><br><span class="line">            if (monitorUrl != null) &#123;</span><br><span class="line">                map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">            &#125;</span><br><span class="line">            urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    invoker = refprotocol.refer(interfaceClass, urls.get(0));</span><br><span class="line">    //省略代码</span><br><span class="line">    return (T) proxyFactory.getProxy(invoker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先进行了一次url拼装，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry://192.168.32.145:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-consumer&amp;dubbo=2.0.0&amp;pid=7780&amp;refer=application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D7780%26side%3Dconsumer%26timestamp%3D1526384969049&amp;registry=zookeeper&amp;timestamp=1526384970818</span><br></pre></td></tr></table></figure></p><p>其中，关键的部分在refer=后面的部分，经过url解码后得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application=demo-consumer&amp;check=false&amp;dubbo=2.0.0&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=7780&amp;side=consumer&amp;timestamp=1526384969049&amp;registry=zookeeper&amp;timestamp=1526384970818</span><br></pre></td></tr></table></figure></p><p>这里包含了所需要的对象的各个信息，Protocol层将根据这个信息，返回对应的invoker，获取到invoker之后，就可以通过Proxy层获取到代理对象，获取代理对象的内容将在下一节Proxy层中讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;config层是dubbo架构中的第二层，第一层的service即是我们的业务层，因此我们从config层开始看，config层在官网中的解释如下:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类&lt;br&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>《dubbo源码深度解析》之dubbo扩展点加载机制</title>
    <link href="http://wangzx.org/2018/05/10/dubbo-spi/"/>
    <id>http://wangzx.org/2018/05/10/dubbo-spi/</id>
    <published>2018-05-10T07:22:15.000Z</published>
    <updated>2018-05-10T07:26:47.092Z</updated>
    
    <content type="html"><![CDATA[<p>dubbo的扩展点加载机制是dubbo的内核，是贯穿整个dubbo的设计思想，在dubbo的官方文档中，也是将扩展点加载机制放在第一篇幅，要想看懂dubbo的源码，首先要看懂dubbo的扩展点加载机制。本章会从java spi的例子开始，到dubbo spi的例子，然后到分析源码，帮助读者看懂dubbo的扩展点加载机制。</p><p><strong><a id="more"></a></strong></p><h1 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h1><h2 id="java-spi"><a href="#java-spi" class="headerlink" title="java spi"></a>java spi</h2><h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Operate &#123;</span><br><span class="line">    double count(double c1,double c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类1"><a href="#实现类1" class="headerlink" title="实现类1"></a>实现类1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import com.example.java_spi.spi.Operate;</span><br><span class="line"></span><br><span class="line">public class AddOperate implements Operate &#123;</span><br><span class="line"></span><br><span class="line">    public double count(double c1,double c2) &#123;</span><br><span class="line">        return c1 + c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类2"><a href="#实现类2" class="headerlink" title="实现类2"></a>实现类2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import com.example.java_spi.spi.Operate;</span><br><span class="line"></span><br><span class="line">public class DelOperate implements Operate &#123;</span><br><span class="line">    public double count(double c1,double c2) &#123;</span><br><span class="line">        return c1 - c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="META-INF文件"><a href="#META-INF文件" class="headerlink" title="META-INF文件"></a>META-INF文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.example.java_spi.impl.AddOperate</span><br><span class="line">com.example.java_spi.impl.DelOperate</span><br></pre></td></tr></table></figure><p>文件路径：META-INF/services/com.example.java_spi.spi.Operate</p><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import com.example.java_spi.spi.Operate;</span><br><span class="line">import java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ServiceLoader&lt;Operate&gt; loaders = ServiceLoader.load(Operate.class);</span><br><span class="line">        for (Operate d : loaders) &#123;</span><br><span class="line">            double res = d.count(2,1);</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3.0</span><br><span class="line">1.0</span><br></pre></td></tr></table></figure><p>可以看到java spi会加载所有的扩展点，且功能比较简单，没有apo ioc等功能</p><h2 id="dubbo-spi"><a href="#dubbo-spi" class="headerlink" title="dubbo spi"></a>dubbo spi</h2><h3 id="接口类-1"><a href="#接口类-1" class="headerlink" title="接口类"></a>接口类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.alibaba.dubbo.common.extension.Adaptive;</span><br><span class="line">import com.alibaba.dubbo.common.extension.SPI;</span><br><span class="line"></span><br><span class="line">@SPI</span><br><span class="line">public interface Operate &#123;</span><br><span class="line">    @Adaptive</span><br><span class="line">    double count(URL url,double c1,double c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类1-1"><a href="#实现类1-1" class="headerlink" title="实现类1"></a>实现类1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.example.dubbo_spi.spi.Operate;</span><br><span class="line"></span><br><span class="line">public class AddOperate implements Operate &#123;</span><br><span class="line"></span><br><span class="line">    public double count(URL url,double c1,double c2) &#123;</span><br><span class="line">        return c1 + c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类2-1"><a href="#实现类2-1" class="headerlink" title="实现类2"></a>实现类2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.example.dubbo_spi.spi.Operate;</span><br><span class="line"></span><br><span class="line">public class DelOperate implements Operate &#123;</span><br><span class="line">    public double count(URL url,double c1,double c2) &#123;</span><br><span class="line">        return c1 - c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="META-INF文件-1"><a href="#META-INF文件-1" class="headerlink" title="META-INF文件"></a>META-INF文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add=com.example.dubbo_spi.impl.AddOperate</span><br><span class="line">del=com.example.dubbo_spi.impl.DelOperate</span><br></pre></td></tr></table></figure><p>文件路径：META-INF/dubbo/com.example.dubbo_spi.spi.Operate</p><h3 id="测试类-1"><a href="#测试类-1" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">import com.example.dubbo_spi.spi.Operate;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Main</span><br><span class="line">&#123;</span><br><span class="line">    public static void main( String[] args )</span><br><span class="line">    &#123;</span><br><span class="line">        Operate p = ExtensionLoader.getExtensionLoader(Operate.class).getAdaptiveExtension();</span><br><span class="line">        Map paramMap = new HashMap();</span><br><span class="line">        paramMap.put(&quot;operate&quot;,&quot;add&quot;);</span><br><span class="line">        URL url = new URL(&quot;&quot;,&quot;&quot;,20880,paramMap);</span><br><span class="line">        double res = p.count(url,2,1);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.0</span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>这个是dubbo spi最简单的一个例子，但也可以看出要比java 的spi要复杂的多。</p><p>首先从接口类看，类上要加一个注解：@SPI，否则会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Extension type(interface com.example.dubbo_spi.spi.Operate) is not extension, because WITHOUT @SPI Annotation!</span><br></pre></td></tr></table></figure></p><p>我们会在后面的源码解析中，分析出这些报错的原因及代码位置。</p><p>第二、接口方法至少一个要有@Adaptive注解，否则会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: fail to create adaptive instance: java.lang.IllegalStateException: Can not create adaptive extenstion interface com.example.dubbo_spi.spi.Operate, cause: No adaptive method on extension com.example.dubbo_spi.spi.Operate, refuse to create the adaptive class!</span><br></pre></td></tr></table></figure></p><p>第三、注明@Adaptive的方法的参数中，必须要有URL类型的参数，或者参数的属性中包含URL类型的属性，否则会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: fail to create adaptive instance: java.lang.IllegalStateException: Can not create adaptive extenstion interface com.example.dubbo_spi.spi.Operate, cause: fail to create adative class for interface com.example.dubbo_spi.spi.Operate: not found url parameter or url attribute in parameters of method count</span><br></pre></td></tr></table></figure></p><p>第四、META-INF文件中要指定key，如add=com.xxx.AddOperate,不指定不会报错，但会生成一个默认的key，比如AddOperate的默认key就是add，这个key，将会在url中用到。</p><p>第五、测试类中的URL对象要有paramMap，并且这个map中要包含一个key，就是接口类的方法中，有注明@Adaptive的方法，这个注解有个属性，如果指定，这这里的url的key，就是指定的这个，如果不指定，则这里url的key就是接口类的类名（驼峰转”.”,如SayHello的默认key是“say.hello”），本案例中没有指定，因此这里的key，应该是operate，因此需指定operate及其值，否则会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalStateException: Fail to get extension(com.example.dubbo_spi.spi.Operate) name from url() use keys([operate])</span><br></pre></td></tr></table></figure></p><p>到这里会难免有疑问，dubbo为什么要指定这么多奇奇怪怪的规则，我们来看测试类中Operate p的实际对象，通过源码分析可以取到代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.example.dubbo_spi.spi;</span><br><span class="line">        import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">public class Operate$Adpative implements com.example.dubbo_spi.spi.Operate &#123;</span><br><span class="line">    public double count(com.alibaba.dubbo.common.URL arg0, double arg1, double arg2) &#123;</span><br><span class="line">        if (arg0 == null) throw new IllegalArgumentException(&quot;url == null&quot;);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(&quot;operate&quot;);</span><br><span class="line">        if(extName == null) throw new IllegalStateException(&quot;Fail to get extension(com.example.dubbo_spi.spi.Operate) name from url(&quot; + url.toString() + &quot;) use keys([operate])&quot;);</span><br><span class="line">        com.example.dubbo_spi.spi.Operate extension = (com.example.dubbo_spi.spi.Operate)ExtensionLoader.getExtensionLoader(com.example.dubbo_spi.spi.Operate.class).getExtension(extName);</span><br><span class="line">        return extension.count(arg0, arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主要代码是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader.getExtensionLoader(com.example.dubbo_spi.spi.Operate.class).getExtension(extName);</span><br></pre></td></tr></table></figure></p><p>这里的extName就是add，通过这行代码取到的对象就是AddOperate的实例，到这里完成了最简单的dubbo spi的调用。</p><h3 id="dubbo-spi之aop"><a href="#dubbo-spi之aop" class="headerlink" title="dubbo spi之aop"></a>dubbo spi之aop</h3><p>dubbo spi可以实现类似spring的aop功能，我们需要先创建一个OperateWrapper类，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.example.dubbo_spi.spi.Operate;</span><br><span class="line"></span><br><span class="line">public class OperateWrapper implements Operate &#123;</span><br><span class="line"></span><br><span class="line">    private Operate operate;</span><br><span class="line"></span><br><span class="line">    public OperateWrapper(Operate operate) &#123;</span><br><span class="line">        this.operate = operate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double count(URL url,double c1,double c2) &#123;</span><br><span class="line">        System.out.println(&quot;==before==&quot;);</span><br><span class="line">        double result = this.operate.count(url,c1,c2);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        System.out.println(&quot;==after==&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==before==</span><br><span class="line">3.0</span><br><span class="line">==after==</span><br></pre></td></tr></table></figure></p><p>OperateWrapper也需要实现Operate接口，并且在构造方法中，需要有Operate这个接口参数，这样的类，dubbo的扩展点加载机制会认为它是一个代理类，用于实现aop的功能，这种包装类可以有多个，会按照在META-INF中的顺序排下来</p><h3 id="dubbo-spi之ioc"><a href="#dubbo-spi之ioc" class="headerlink" title="dubbo spi之ioc"></a>dubbo spi之ioc</h3><p>首先我们需要如法炮制创建一个SayHello接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.alibaba.dubbo.common.extension.Adaptive;</span><br><span class="line">import com.alibaba.dubbo.common.extension.SPI;</span><br><span class="line"></span><br><span class="line">@SPI</span><br><span class="line">public interface SayHello &#123;</span><br><span class="line">    @Adaptive</span><br><span class="line">    void say(URL url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后再创建一个实现类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.example.dubbo_spi.spi.SayHello;</span><br><span class="line"></span><br><span class="line">public class ChineseSayHello implements SayHello &#123;</span><br><span class="line">    public void say(URL url) &#123;</span><br><span class="line">        System.out.println(&quot;你好！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加META-INF文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chinese=com.example.dubbo_spi.impl.ChineseSayHello</span><br></pre></td></tr></table></figure></p><p>然后修改AddOperate代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import com.alibaba.dubbo.common.URL;</span><br><span class="line">import com.example.dubbo_spi.spi.Operate;</span><br><span class="line">import com.example.dubbo_spi.spi.SayHello;</span><br><span class="line"></span><br><span class="line">public class AddOperate implements Operate &#123;</span><br><span class="line"></span><br><span class="line">    private SayHello sayHello;</span><br><span class="line"></span><br><span class="line">    public SayHello getSayHello() &#123;</span><br><span class="line">        return sayHello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSayHello(SayHello sayHello) &#123;</span><br><span class="line">        this.sayHello = sayHello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double count(URL url, double c1, double c2) &#123;</span><br><span class="line">        sayHello.say(url);</span><br><span class="line">        return c1 + c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后在测试类的paramMap中加上say.hello的key和value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paramMap.put(&quot;say.hello&quot;,&quot;chinese&quot;);</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">==before==</span><br><span class="line">你好！</span><br><span class="line">3.0</span><br><span class="line">==after==</span><br></pre></td></tr></table></figure></p><p>这里的关键代码，在ExtensionLoader的injectExtension方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private T injectExtension(T instance) &#123;</span><br><span class="line">        for (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">            if (method.getName().startsWith(&quot;set&quot;)</span><br><span class="line">                    &amp;&amp; method.getParameterTypes().length == 1</span><br><span class="line">                    &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                Class&lt;?&gt; pt = method.getParameterTypes()[0];</span><br><span class="line">                String property = method.getName().length() &gt; 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : &quot;&quot;;</span><br><span class="line">                Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                if (object != null) &#123;</span><br><span class="line">                    method.invoke(instance, object);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>代码做了适当精简，主要逻辑是遍历目标类的方法，如果是set开头，如setSayHello，那就去找sayHello有没有这个对象，如果有，就通过set方法注入，问题是怎么找sayHello这个对象？答案是通过objectFactory的getExtension方法来找，这是个关键对象，后面会再提到，这里插播一个知识点，dubbo的自动注入，需要提供属性的set方法，否则无法注入，spring通过xml配置的属性，同样要有set方法，否则也无法注入，但spring通过@Autowired配置的属性，可以没有set方法，那spring是怎么实现的呢？答案是通过setAccessible()方法改变属性的访问标志，从而达到修改属性的目的，即注入。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>代码入口在：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExtensionLoader.getExtensionLoader(Operate.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure></p><p>进入getExtensionLoader方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) &#123;</span><br><span class="line">        ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        if (loader == null) &#123;</span><br><span class="line">            EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">            loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">        &#125;</span><br><span class="line">        return loader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里有个关键对象：</p><blockquote><p>ConcurrentMap<class<?>, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS;</class<?></p></blockquote><p>这是所有ExtensionLoader的缓存对象，获取ExtensionLoader时，先从缓存对象中取，如果没有，再new一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private ExtensionLoader(Class&lt;?&gt; type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">        objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里又有一个关键对象：</p><blockquote><p>ExtensionFactory objectFactory;</p></blockquote><p>objectFactory只有一个作用，就是在自动注入的时候用于寻找扩展对象，由于objectFactory的初始化过程就是本章内容，内容重复，因此略过，new完后存入EXTENSION_LOADERS缓存对象，getExtensionLoader的过程结束。</p><p>紧接着进入getAdaptiveExtension()的过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public T getAdaptiveExtension() &#123;</span><br><span class="line">        Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = createAdaptiveExtension();</span><br><span class="line">            cachedAdaptiveInstance.set(instance);</span><br><span class="line">        &#125;</span><br><span class="line">        return (T) instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里有个关键对象：</p><blockquote><p>Holder<object> cachedAdaptiveInstance</object></p></blockquote><p>先从这个缓存对象中取，如果没有，开始createAdaptiveExtension：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private T createAdaptiveExtension() &#123;</span><br><span class="line">    return injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有两个关键的方法，1是getAdaptiveExtensionClass，2是injectExtension，顾名思义，1方法是获得AdaptiveExtensionClass的Class对象，2方法是进行注入。先来看getAdaptiveExtensionClass方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        if (cachedAdaptiveClass != null) &#123;</span><br><span class="line">            return cachedAdaptiveClass;</span><br><span class="line">        &#125;</span><br><span class="line">        return cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先进行了getExtensionClasses方法，即获得该接口的所有扩展对象，即在META-INF所罗列出的所有的实现类，在这实现类中，如果包含有Adaptive对象，则第三行的cachedAdaptiveClass就不为空，先来看getExtensionClasses方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">        if (classes == null) &#123;</span><br><span class="line">            synchronized (cachedClasses) &#123;</span><br><span class="line">                classes = cachedClasses.get();</span><br><span class="line">                if (classes == null) &#123;</span><br><span class="line">                    //关键代码</span><br><span class="line">                    classes = loadExtensionClasses();</span><br><span class="line">                    cachedClasses.set(classes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return classes;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里有个关键对象：</p><blockquote><p>Holder<map<string, class<?="">&gt;&gt; cachedClasses</map<string,></p></blockquote><p>用于存储该接口的所有扩展对象的Class对象，做一些缓存校验后进入loadExtensionClasses方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = new HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">        loadFile(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br><span class="line">        loadFile(extensionClasses, DUBBO_DIRECTORY);</span><br><span class="line">        loadFile(extensionClasses, SERVICES_DIRECTORY);</span><br><span class="line">        return extensionClasses;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里的extensionClasses在加载完所有的扩展对象后，就会返回存赋值给刚刚的cachedClasses对象，可以看到dubbo会从三个第三加载扩展对象：</p><ul><li>META-INF/dubbo/internal/</li><li>META-INF/dubbo/</li><li>META-INF/services/<br>先进入loadFile方法查看具体怎么加载：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private void loadFile(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir) &#123;</span><br><span class="line">        String fileName = dir + type.getName();</span><br><span class="line">        //省略读取文件代码</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(line, true, classLoader);</span><br><span class="line">        if (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">            if (cachedAdaptiveClass == null) &#123;</span><br><span class="line">                cachedAdaptiveClass = clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                clazz.getConstructor(type);</span><br><span class="line">                Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">                if (wrappers == null) &#123;</span><br><span class="line">                    cachedWrapperClasses = new ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">                    wrappers = cachedWrapperClasses;</span><br><span class="line">                &#125;</span><br><span class="line">                wrappers.add(clazz);</span><br><span class="line">            &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                clazz.getConstructor();</span><br><span class="line">                //省略name为空情况的代码</span><br><span class="line">                String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">                if (names != null &amp;&amp; names.length &gt; 0) &#123;</span><br><span class="line">                    Activate activate = clazz.getAnnotation(Activate.class);</span><br><span class="line">                    if (activate != null) &#123;</span><br><span class="line">                        cachedActivates.put(names[0], activate);</span><br><span class="line">                    &#125;</span><br><span class="line">                    for (String n : names) &#123;</span><br><span class="line">                        if (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">                            cachedNames.put(clazz, n);</span><br><span class="line">                        &#125;</span><br><span class="line">                        Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">                        if (c == null) &#123;</span><br><span class="line">                            extensionClasses.put(n, clazz);</span><br><span class="line">                        &#125; else if (c != clazz) &#123;</span><br><span class="line">                            throw new IllegalStateException(&quot;Duplicate extension &quot; + type.getName() + &quot; name &quot; + n + &quot; on &quot; + c.getName() + &quot; and &quot; + clazz.getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>代码省略了循环读取META-INF文件的代码，每读取到一行后，就会进行解析，解析的过程有三种情况：</p><ul><li>这个扩展类有@Adaptive注解</li><li>这个扩展类的构造方法包含这个接口</li><li>其他</li></ul><p>对于第一种情况，会把这个扩展对象缓存进cachedAdaptiveClass这个对象，这个对象即是Adaptive对象，意思是如果扩展类中已经有了Adaptive对象，那就不用自动生成，直接用这个，否则需要动态生成一个Adaptive对象。</p><p>对于第二种情况，会把这个扩展对象缓存进cachedWrapperClasses这个对象，这个对象是个set，可以存放多个，这种情况的意思是这个扩展类是个包装对象，用于实现aop</p><p>第三种情况，会缓存进extensionClasses，这个对象稍后会赋值给cachedClasses对象，cachedClasses也是个关键对象，在后续getExtension(String name)方法中，就是在这个对象中寻找。</p><p>加载完成后，代码回到getAdaptiveExtensionClass方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        if (cachedAdaptiveClass != null) &#123;</span><br><span class="line">            return cachedAdaptiveClass;</span><br><span class="line">        &#125;</span><br><span class="line">        return cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>由于我们这个例子，没有一个扩展对象有@Adaptive注解，也就是说没有自己实现的Adaptive类，因此cachedAdaptiveClass这个对象为空，需要进行动态创建，动态创建的过程在很多框架代码中都有，比如jdk动态代理、cglib动态代理等，我们来看具体代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">        String code = createAdaptiveExtensionClassCode();</span><br><span class="line">        ClassLoader classLoader = findClassLoader();</span><br><span class="line">        com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">        return compiler.compile(code, classLoader);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>createAdaptiveExtensionClassCode的代码都是逻辑代码，最后产生的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.example.dubbo_spi.spi;</span><br><span class="line">        import com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line">public class Operate$Adpative implements com.example.dubbo_spi.spi.Operate &#123;</span><br><span class="line">    public double count(com.alibaba.dubbo.common.URL arg0, double arg1, double arg2) &#123;</span><br><span class="line">        if (arg0 == null) throw new IllegalArgumentException(&quot;url == null&quot;);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(&quot;operate&quot;);</span><br><span class="line">        if(extName == null) throw new IllegalStateException(&quot;Fail to get extension(com.example.dubbo_spi.spi.Operate) name from url(&quot; + url.toString() + &quot;) use keys([operate])&quot;);</span><br><span class="line">        com.example.dubbo_spi.spi.Operate extension = (com.example.dubbo_spi.spi.Operate)ExtensionLoader.getExtensionLoader(com.example.dubbo_spi.spi.Operate.class).getExtension(extName);</span><br><span class="line">        return extension.count(arg0, arg1, arg2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>紧接着通过扩展点获取到具体的Compiler，这里为JavassistCompiler，将这段代码通过JavassistCompiler编译成Class，编译完成后，代码返回到createAdaptiveExtension方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private T createAdaptiveExtension() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Can not create adaptive extenstion &quot; + type + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>然后开始自动注入，即injectExtension方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private T injectExtension(T instance) &#123;</span><br><span class="line">        for (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">            if (method.getName().startsWith(&quot;set&quot;)</span><br><span class="line">                    &amp;&amp; method.getParameterTypes().length == 1</span><br><span class="line">                    &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                Class&lt;?&gt; pt = method.getParameterTypes()[0];</span><br><span class="line">                try &#123;</span><br><span class="line">                    String property = method.getName().length() &gt; 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : &quot;&quot;;</span><br><span class="line">                    Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                    if (object != null) &#123;</span><br><span class="line">                        method.invoke(instance, object);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    logger.error(&quot;fail to inject via method &quot; + method.getName()</span><br><span class="line">                            + &quot; of interface &quot; + type.getName() + &quot;: &quot; + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>主要的逻辑，是遍历这个Class的方法，如果以set开头，就去查找有没有这个set方法所需要的对象，比如有个setSayHello方法，那么就去查找有没有sayHello这个对象，查询方法就是通过objectFactory.getExtension(pt, property)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) &#123;</span><br><span class="line">        for (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            T extension = factory.getExtension(type, name);</span><br><span class="line">            if (extension != null) &#123;</span><br><span class="line">                return extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里的逻辑也很简单，遍历factories，即遍历所有的扩展点工厂，在每个工厂中寻找对象，这里有两个扩展点工厂：</p><ul><li>SpiExtensionFactory</li><li>SpringExtensionFactory</li></ul><p>代码分别如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) &#123;</span><br><span class="line">        if (type.isInterface() &amp;&amp; type.isAnnotationPresent(SPI.class)) &#123;</span><br><span class="line">            ExtensionLoader&lt;T&gt; loader = ExtensionLoader.getExtensionLoader(type);</span><br><span class="line">            if (loader.getSupportedExtensions().size() &gt; 0) &#123;</span><br><span class="line">                return loader.getAdaptiveExtension();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getExtension(Class&lt;T&gt; type, String name) &#123;</span><br><span class="line">        for (ApplicationContext context : contexts) &#123;</span><br><span class="line">            if (context.containsBean(name)) &#123;</span><br><span class="line">                Object bean = context.getBean(name);</span><br><span class="line">                if (type.isInstance(bean)) &#123;</span><br><span class="line">                    return (T) bean;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果这些扩展点工厂返回的对象不为空，就可以进行注入，至此，完成了dubbo spi的代码，完！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dubbo的扩展点加载机制是dubbo的内核，是贯穿整个dubbo的设计思想，在dubbo的官方文档中，也是将扩展点加载机制放在第一篇幅，要想看懂dubbo的源码，首先要看懂dubbo的扩展点加载机制。本章会从java spi的例子开始，到dubbo spi的例子，然后到分析源码，帮助读者看懂dubbo的扩展点加载机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>cglib动态代理解析</title>
    <link href="http://wangzx.org/2018/05/02/cglib-proxy/"/>
    <id>http://wangzx.org/2018/05/02/cglib-proxy/</id>
    <published>2018-05-02T13:25:21.000Z</published>
    <updated>2018-05-02T13:25:53.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="目标类"><a href="#目标类" class="headerlink" title="目标类"></a>目标类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HelloService &#123;</span><br><span class="line">    </span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;=== hello ===&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a id="more"></a></strong></p><h3 id="拦截器类"><a href="#拦截器类" class="headerlink" title="拦截器类"></a>拦截器类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">public class MyMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    public Object intercept(Object obj, Method method, Object[] args,MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;=== before ===&quot;);</span><br><span class="line">        Object object = proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(&quot;=== after ===&quot;);</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line"></span><br><span class="line">public class MyProxy&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public T getProxy(Class&lt;T&gt; tClass)&#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        enhancer.setSuperclass(tClass);</span><br><span class="line">        enhancer.setCallback(new MyMethodInterceptor());</span><br><span class="line">        return (T) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        MyProxy&lt;HelloService&gt; myProxy = new MyProxy();</span><br><span class="line">        HelloService helloService = myProxy.getProxy(HelloService.class);</span><br><span class="line">        helloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== before ===</span><br><span class="line">=== hello ===</span><br><span class="line">=== after ===</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>不同于jdk动态代理，cglib采用了继承目标类的方式来实现动态代理，因此cglib无法代理final类型的方法，相比比jdk动态代理，产生代理类，需要接口Class对象以及实现类的实例而言，cglib所需要的“原材料”更少，只需要目标类的Class对象即可实现动态代理。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>代码入口就在MyProxy类的enhancer.create()方法，很明显这个方法产生出来的就是目标类的子类，但我们的代码中并没有存在目标类的子类，cglib如何new出来？这里的原理与jdk动态代理类似，都是动态产生字节码技术，不过不同于jdk动态代理直接写二进制文件，cglib底层采用asm框架来产生字节码文件，效率上笔者认为是比jdk动态代理要慢一点，但这不是关键，因为一个代理类的产生，只会经过一次这个步骤，而后成千上万次的方法调用，才是效率的关键。</p><p>来看enhancer.create()的具体步骤，经过createHelper()–&gt;super.create(key)–&gt;data.get(this)–&gt;generatedClasses.get(gen)–&gt;createEntry(key, cacheKey, v)–&gt;loader.apply(key)–&gt;gen.generate(ClassLoaderData.this)–&gt;super.generate(data)–&gt;strategy.generate(this)–&gt;transform(cg).generateClass(cw)后到达产生二进制文件的核心Enhancer类的generateClass(ClassVisitor v)方法。</p><p>这个方法采用asm动态生成字节码文件，具体如何生成，笔者认为没有必要去看具体的逻辑过程，繁琐且没有营养，我们熟悉asm的话也可以写的出来。反而是这个方法，到底生成了什么东西，值得我们关注。</p><h2 id="动态代理类源码"><a href="#动态代理类源码" class="headerlink" title="动态代理类源码"></a>动态代理类源码</h2><p>我们可以将上一步中取到的byte数组，写入到文件，通过反编译工具查看源码，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import net.sf.cglib.core.ReflectUtils;</span><br><span class="line">import net.sf.cglib.proxy.Callback;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line">//关键点，继承目标类</span><br><span class="line">public class HelloService$$EnhancerByCGLIB$$a89dc216 extends HelloService &#123;</span><br><span class="line">    private boolean CGLIB$BOUND;</span><br><span class="line">    private static ThreadLocal CGLIB$THREAD_CALLBACKS;</span><br><span class="line">    private MethodInterceptor CGLIB$CALLBACK_0;</span><br><span class="line">    private static MethodProxy CGLIB$sayHello$0$Proxy;</span><br><span class="line">    private static Object[] CGLIB$emptyArgs;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            CGLIB$STATICHOOK2();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void CGLIB$STATICHOOK2() throws ClassNotFoundException &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS = new ThreadLocal();</span><br><span class="line">        CGLIB$emptyArgs = new Object[0];</span><br><span class="line">        Class var0 = Class.forName(&quot;com.example.demo.java_demo.cglib.HelloService$$EnhancerByCGLIB$$a89dc216&quot;);</span><br><span class="line">        Class var1;</span><br><span class="line">        Method[] var10000 = ReflectUtils.findMethods(new String[]&#123;&quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;, &quot;hashCode&quot;, &quot;()I&quot;, &quot;clone&quot;, &quot;()Ljava/lang/Object;&quot;&#125;, (var1 = Class.forName(&quot;java.lang.Object&quot;)).getDeclaredMethods());</span><br><span class="line">        //关键代码，产生MethodProxy</span><br><span class="line">        CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //拦截器类将会调用此方法</span><br><span class="line">    final void CGLIB$sayHello$0() &#123;</span><br><span class="line">        super.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //关键方法</span><br><span class="line">    public final void sayHello()  &#123;</span><br><span class="line">        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        if(this.CGLIB$CALLBACK_0 == null) &#123;</span><br><span class="line">            CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">            var10000 = this.CGLIB$CALLBACK_0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(var10000 != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //关键方法</span><br><span class="line">                var10000.intercept(this, null, CGLIB$emptyArgs, CGLIB$sayHello$0$Proxy);</span><br><span class="line">            &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                throwable.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.sayHello();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public HelloService$$EnhancerByCGLIB$$a89dc216() &#123;</span><br><span class="line">        CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //通过这个方法注入拦截器类</span><br><span class="line">    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS.set(var0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //设置拦截器类</span><br><span class="line">    private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">        HelloService$$EnhancerByCGLIB$$a89dc216 var1 = (HelloService$$EnhancerByCGLIB$$a89dc216)var0;</span><br><span class="line">        if(!var1.CGLIB$BOUND) &#123;</span><br><span class="line">            var1.CGLIB$BOUND = true;</span><br><span class="line">            Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">            if(var10000 == null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">            &#125;</span><br><span class="line">            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个源码已经做了大量的精简，但看上去仍然比jdk动态代理生成的动态代理类要复杂的多，有了这个动态代理类，我们就可以修改测试类中的代码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import net.sf.cglib.proxy.Callback;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //设置拦截器</span><br><span class="line">        HelloService$$EnhancerByCGLIB$$a89dc216.CGLIB$SET_THREAD_CALLBACKS( new Callback[]&#123; new MyMethodInterceptor() &#125; );</span><br><span class="line">        //创建实例</span><br><span class="line">        HelloService helloService = new HelloService$$EnhancerByCGLIB$$a89dc216();</span><br><span class="line">        //调用方法</span><br><span class="line">        helloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先来看第一步设置拦截器，传入的拦截器将在稍后被设置到成员变量CGLIB$CALLBACK_0中，这个属性会在方法调用时发挥作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123;</span><br><span class="line">        CGLIB$THREAD_CALLBACKS.set(var0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123;</span><br><span class="line">        HelloService$$EnhancerByCGLIB$$a89dc216 var1 = (HelloService$$EnhancerByCGLIB$$a89dc216)var0;</span><br><span class="line">        if(!var1.CGLIB$BOUND) &#123;</span><br><span class="line">            var1.CGLIB$BOUND = true;</span><br><span class="line">            Object var10000 = CGLIB$THREAD_CALLBACKS.get();</span><br><span class="line">            if(var10000 == null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">            &#125;</span><br><span class="line">            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第二步创建实例，这里有一行非常关键的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;);</span><br></pre></td></tr></table></figure></p><p>这个代码可以先忽略，等到方法执行时再看</p><p>第三步方法调用，即调用动态代理类的sayHello()方法，进而调用拦截器类的intercept方法，传入的4个参数分别为：1、动态代理类的对象本身 2、通过反射获得的method对象 3、方法参数 4、方法代理对象（关键）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var10000.intercept(this, null, CGLIB$emptyArgs, CGLIB$sayHello$0$Proxy);</span><br></pre></td></tr></table></figure></p><p>代码跳到拦截器类的intercept方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public Object intercept(Object obj, Method method, Object[] args,MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">    System.out.println(&quot;=== before ===&quot;);</span><br><span class="line">    Object object = proxy.invokeSuper(obj, args);</span><br><span class="line">    System.out.println(&quot;=== after ===&quot;);</span><br><span class="line">    return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在jdk动态代理中，也有类似的方法，但在jdk动态代理在执行目标方法时，是通过反射调用，我们知道反射调用比直接调用，效率上是要低的多，而cglib实现了自己的一套反射调用，查看MethodProxy类的init方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void init()&#123;</span><br><span class="line">       CreateInfo ci = createInfo;</span><br><span class="line">       FastClassInfo fci = new FastClassInfo();</span><br><span class="line">       fci.f1 = helper(ci, ci.c1);</span><br><span class="line">       fci.f2 = helper(ci, ci.c2);</span><br><span class="line">       fci.i1 = fci.f1.getIndex(sig1);</span><br><span class="line">       fci.i2 = fci.f2.getIndex(sig2);</span><br><span class="line">       fastClassInfo = fci;</span><br><span class="line">       createInfo = null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这里的c1，c2，sig1，sig2，即在动态代理类中传入的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;);</span><br></pre></td></tr></table></figure><p>这个方法会产生FastClassInfo对象，这个对象有4个属性，f1，f2，i1，i2，其中最主要的是f2和i2，将在稍后的调用中使用到，为了更清晰明了，我们先来看后面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return fci.f2.invoke(fci.i2, obj, args);</span><br></pre></td></tr></table></figure></p><p>这行代码就是进行了代理类的方法调用，如果此时按F5进入方法，会发现代码跳到了刚刚的动态代理类的CGLIB$sayHello$0()方法，即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void CGLIB$sayHello$0() &#123;</span><br><span class="line">        super.sayHello();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>但f2的invoke方法，为何会调用到动态代理类的CGLIB$sayHello$0方法？这里就要看f2是如何产生的，回头看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fci.f2 = helper(ci, ci.c2);</span><br></pre></td></tr></table></figure></p><p>helper()方法会产生一个FastClass对象，这个FastClass对象也是通过动态字节码技术产生的，产生流程跟产生动态代理类一致，通过反编译可以获得源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import com.example.demo.java_demo.cglib.HelloService..EnhancerByCGLIB..a89dc216;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import net.sf.cglib.core.Signature;</span><br><span class="line">import net.sf.cglib.proxy.Callback;</span><br><span class="line">import net.sf.cglib.reflect.FastClass;</span><br><span class="line"></span><br><span class="line">public class HelloService$$EnhancerByCGLIB$$a89dc216$$FastClassByCGLIB$$7d6c4fc4 extends FastClass &#123;</span><br><span class="line">    public HelloService$$EnhancerByCGLIB$$a89dc216$$FastClassByCGLIB$$7d6c4fc4(Class var1) &#123;</span><br><span class="line">        super(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getIndex(Signature var1) &#123;</span><br><span class="line">        String var10000 = var1.toString();</span><br><span class="line">        switch(var10000.hashCode()) &#123;</span><br><span class="line">        case -2055565910:</span><br><span class="line">            if(var10000.equals(&quot;CGLIB$SET_THREAD_CALLBACKS([Lnet/sf/cglib/proxy/Callback;)V&quot;)) &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case -1457505897:</span><br><span class="line">            if(var10000.equals(&quot;CGLIB$STATICHOOK2()V&quot;)) &#123;</span><br><span class="line">                return 2;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 291273791:</span><br><span class="line">            if(var10000.equals(&quot;CGLIB$sayHello$0()V&quot;)) &#123;</span><br><span class="line">                return 3;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case 1535311470:</span><br><span class="line">            if(var10000.equals(&quot;sayHello()V&quot;)) &#123;</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException &#123;</span><br><span class="line">        a89dc216 var10000 = (a89dc216)var2;</span><br><span class="line">        int var10001 = var1;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            switch(var10001) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                var10000.sayHello();</span><br><span class="line">                return null;</span><br><span class="line">            case 1:</span><br><span class="line">                a89dc216.CGLIB$SET_THREAD_CALLBACKS((Callback[])var3[0]);</span><br><span class="line">                return null;</span><br><span class="line">            case 2:</span><br><span class="line">                a89dc216.CGLIB$STATICHOOK2();</span><br><span class="line">                return null;</span><br><span class="line">            case 3:</span><br><span class="line">                var10000.CGLIB$sayHello$0();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable var4) &#123;</span><br><span class="line">            throw new InvocationTargetException(var4);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码同样做了精简，到这里流程差不多已经走完了，在进行f2的invoke调用时，会传入i1，i1即是通过f2的getinde方法获得的，这里的值为3，在进行invoker调用时，可以看到最终调用的是动态代理类的CGLIB$sayHello$0()方法，CGLIB$sayHello$0()方法的方法体在刚刚已经展示过，就一行代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void CGLIB$sayHello$0() &#123;</span><br><span class="line">        super.sayHello();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>至此，完成了cglib动态调用的过程<br>完！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单的例子&quot;&gt;&lt;a href=&quot;#简单的例子&quot; class=&quot;headerlink&quot; title=&quot;简单的例子&quot;&gt;&lt;/a&gt;简单的例子&lt;/h1&gt;&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;h3 id=&quot;目标类&quot;&gt;&lt;a href=&quot;#目标类&quot; class=&quot;headerlink&quot; title=&quot;目标类&quot;&gt;&lt;/a&gt;目标类&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class HelloService &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void sayHello() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&amp;quot;=== hello ===&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>jdk动态代理解析</title>
    <link href="http://wangzx.org/2018/04/28/jdk-proxy/"/>
    <id>http://wangzx.org/2018/04/28/jdk-proxy/</id>
    <published>2018-04-28T07:43:02.000Z</published>
    <updated>2018-04-28T09:58:57.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloService &#123;</span><br><span class="line">    void sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a id="more"></a></strong></p><h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HelloServiceImpl implements HelloService &#123;</span><br><span class="line"></span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class MyProxy &lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    private Class interfaceClass;</span><br><span class="line"></span><br><span class="line">    public MyProxy(Object target,Class interfaceClass) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.target = target;</span><br><span class="line">        this.interfaceClass = interfaceClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getProxy() &#123;</span><br><span class="line">        return (T)Proxy.newProxyInstance(interfaceClass.getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), new InvocationHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                        System.out.println(&quot;=== begin ===&quot;);</span><br><span class="line">                        Object result = method.invoke(target,args);</span><br><span class="line">                        System.out.println(&quot;=== end ===&quot;);</span><br><span class="line">                        return result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws Throwable &#123;</span><br><span class="line">        new Main().testProxy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testProxy() throws Throwable &#123;</span><br><span class="line">        HelloService userService = new HelloServiceImpl();</span><br><span class="line">        MyProxy&lt;HelloService&gt; myProxy = new MyProxy(userService,HelloService.class);</span><br><span class="line">        HelloService proxy = myProxy.getProxy();</span><br><span class="line">        proxy.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== begin ===</span><br><span class="line">hello</span><br><span class="line">=== end ===</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>在讲核心代码前先插播一个内容：ClassLoader，可以看到在匿名内部类中，有个interfaceClass.getClassLoader()的操作，interfaceClass是个Class对象，在new MyProxy是传入，唯一的作用就是获得这个对象的ClassLoader，这是由于ClassLoader的机制导致的，由不同ClassLoader加载的类，即便已经实现了目标接口的方法，也不会被认为是这个目标接口的子类，因此需要用同一个ClassLoader，才能使最终生成的代理对象，能够被强制转换成接口对象，更详细的内容请参考双亲委派模型。</p><p>接下来开始讲核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure></p><p>这行代码将会产生一个代理类，这个类实现了HelloService的所有方法，在方法体重，调用第三个参数h，这个h即为我们上面代码中的匿名内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new InvocationHandler() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;=== begin ===&quot;);</span><br><span class="line">        Object result = method.invoke(target,args);</span><br><span class="line">        System.out.println(&quot;=== end ===&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>先来看newProxyInstance()这个方法，以下源码摘自jdk1.8，源码做了大量精简，仅保留核心代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)throws IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        //获取代理类的Class对象</span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">        //获取代理类的构造方法</span><br><span class="line">        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        //生成实例</span><br><span class="line">        return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>getProxyClass0()方法也就是动态代理核心，经过各种缓存机制判断后，我们可以找到真正干活的那个方法，即ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags)，这个方法中，又调用了ProxyGenerator类的generateClassFile()方法，这个方法就是产生Class二进制文件的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private byte[] generateClassFile() &#123;</span><br><span class="line">        this.addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">        this.addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">        this.addProxyMethod(toStringMethod, Object.class);</span><br><span class="line">        //...省略代码</span><br><span class="line">        ByteArrayOutputStream var13 = new ByteArrayOutputStream();</span><br><span class="line">        DataOutputStream var14 = new DataOutputStream(var13);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var14.writeInt(-889275714);</span><br><span class="line">            var14.writeShort(0);</span><br><span class="line">            var14.writeShort(49);</span><br><span class="line">            this.cp.write(var14);</span><br><span class="line">            var14.writeShort(this.accessFlags);</span><br><span class="line">            var14.writeShort(this.cp.getClass(dotToSlash(this.className)));</span><br><span class="line">            var14.writeShort(this.cp.getClass(&quot;java/lang/reflect/Proxy&quot;));</span><br><span class="line">            var14.writeShort(this.interfaces.length);</span><br><span class="line">            //...省略代码</span><br><span class="line">            return var13.toByteArray();</span><br><span class="line">        &#125; catch (IOException var9) &#123;</span><br><span class="line">            throw new InternalError(&quot;unexpected I/O Exception&quot;, var9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法充斥着大量的逻辑性代码，没有什么值得看的地方，倒是这种生成Class二进制文件的方式是个亮点，笔者在看dubbo源码时，dubbo也会产生类似的动态代理类，但dubbo的方式是先生成java代码，就是 public class XXX这样，然后通过javassist变成Class文件，但jdk动态代理直接省去了生成java代码这一步，直接写二进制文件，显然这能提高效率，这里可以作为面试的一个点。</p><p>顺便介绍下Class文件的结构，java的Class文件是严格按照顺序来书写，各个属性之间没有间隔（如<bean>之类称之为间隔），通过预定义好的顺序写入和读取Class文件，以保证能够正确的读写，从上面的代码也能看出来</bean></p><p>第一行：writeInt(-889275714) -889275714转成十六进制即为CAFEBABY，熟悉Class文件结构的同学都知道这是Java Class文件的标记，任何Class文件都是以这个开头。</p><p>第二行：writeShort(0)，即两个字节的0，转为十六进制是00 00，这两个字节目前没有意义，是Class文件中罕见的没有意义的字符</p><p>第三行：writeShort(49)，49是jdk的版本，即jdk1.5，即生成的Class文件，能被jdk1.5以上的虚拟机运行</p><p>第四行：cp.write(var14)，写入常量池，常量池包括字面量和符号引用，字面量即文本字符串，声明为final的常量，符号引用即类和接口的全限定名，方法、字段的名称和描述符等，在上面的逻辑步骤中已经解析出了所有需要的常量池</p><p>第五行：writeShort(this.accessFlags);accessFlags即类的访问标志，这里的值是17，十六进制为11，查表可知这代表 final 和 public两种访问标志。</p><p>第六行：常量池写完，后面的所有操作都是写常量池中的编号，而不会再写入具体的名称</p><p>Class文件的结构严谨而复杂，有兴趣的同学可以阅读周志明编写的深入理解java虚拟机这一书</p><p>我们可以手动调用ProxyGenerator.generateProxyClass(“$Proxy0”, HelloServiceImpl.class.getInterfaces())这个方法，得到二进制数据，将它写入磁盘，然后用反编译工具看下到底写了什么代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">package com.sun.proxy;</span><br><span class="line"></span><br><span class="line">import com.example.demo.java_demo.jdk_proxy.HelloService;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">public final class $Proxy0 extends Proxy</span><br><span class="line">  implements HelloService</span><br><span class="line">&#123;</span><br><span class="line">  private static Method m1;</span><br><span class="line">  private static Method m3;</span><br><span class="line">  private static Method m2;</span><br><span class="line">  private static Method m0;</span><br><span class="line"></span><br><span class="line">  public $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    super(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final boolean equals(Object paramObject)</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void sayHello()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      this.h.invoke(this, m3, null);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final String toString()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return (String)this.h.invoke(this, m2, null);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final int hashCode()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return ((Integer)this.h.invoke(this, m0, null)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class="line">      m3 = Class.forName(&quot;com.example.demo.java_demo.jdk_proxy.HelloService&quot;).getMethod(&quot;sayHello&quot;, new Class[0]);</span><br><span class="line">      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键的sayHello方法，其实也是调用了this.h.invoke(this, m2, null);这个h，即我们上面写的那个匿名内部类。</p><p>完！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单的例子&quot;&gt;&lt;a href=&quot;#简单的例子&quot; class=&quot;headerlink&quot; title=&quot;简单的例子&quot;&gt;&lt;/a&gt;简单的例子&lt;/h1&gt;&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;h3 id=&quot;接口类&quot;&gt;&lt;a href=&quot;#接口类&quot; class=&quot;headerlink&quot; title=&quot;接口类&quot;&gt;&lt;/a&gt;接口类&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public interface HelloService &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void sayHello();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java内存结构与垃圾回收</title>
    <link href="http://wangzx.org/2018/02/24/jvm/"/>
    <id>http://wangzx.org/2018/02/24/jvm/</id>
    <published>2018-02-24T11:12:56.000Z</published>
    <updated>2018-02-24T11:55:08.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="堆内存（线程共享）"><a href="#堆内存（线程共享）" class="headerlink" title="堆内存（线程共享）"></a>堆内存（线程共享）</h2><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新创建的对象放入新生代，由于新生代的对象，大部分是朝生夕死，为了更好的垃圾回收，大多数垃圾收集器都采用复制算法，但由于最初的复制算法，将内存一分为二，浪费了50%的内存，因此后来将新生代内存划分为1块Eden区域和两块Survivor区域，默认的比例为8：1：1</p><h4 id="Eden"><a href="#Eden" class="headerlink" title="Eden"></a>Eden</h4><p>新创建的对象优先放入Eden区域</p><p><strong><a id="more"></a></strong></p><h4 id="Suvider"><a href="#Suvider" class="headerlink" title="Suvider"></a>Suvider</h4><p>Survivor区域有两块，进行一次垃圾回收后，Eden中存活的对象，被复制到Survivor区域中</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>长期存活的对象放入老年代</p><h2 id="方法区（线程共享）"><a href="#方法区（线程共享）" class="headerlink" title="方法区（线程共享）"></a>方法区（线程共享）</h2><p>用于存储已被加载的类信息，常量，静态变量，即使编译器编译后的代码数据等</p><h2 id="虚拟机栈（线程独享）"><a href="#虚拟机栈（线程独享）" class="headerlink" title="虚拟机栈（线程独享）"></a>虚拟机栈（线程独享）</h2><p>每个方法执行时，都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，栈帧伴随着方法的执行而入栈，随着方法的结束而出栈</p><h2 id="本地方法栈（线程独享）"><a href="#本地方法栈（线程独享）" class="headerlink" title="本地方法栈（线程独享）"></a>本地方法栈（线程独享）</h2><p>功能类似于虚拟机栈，只是这部分内存由native方法使用</p><h2 id="程序计数器（线程独享）"><a href="#程序计数器（线程独享）" class="headerlink" title="程序计数器（线程独享）"></a>程序计数器（线程独享）</h2><p>用于记录方法执行的行号，如果执行native方法，则无法记录行号，这是内存中唯一一块不会出现OOM的区域</p><h1 id="如何判断对象为垃圾对象"><a href="#如何判断对象为垃圾对象" class="headerlink" title="如何判断对象为垃圾对象"></a>如何判断对象为垃圾对象</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>添加一个引用计数器，当对象被引用时+1，解除引用时-1，当值为0时，即为垃圾对象，但由于这种算法，无法回收相互引用的对象，因此很少jvm采用这种算法</p><h2 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h2><p>从GCRoot向下搜索，所走过的路径，称之为引用链，都为有用的对象，否则即为垃圾对象</p><h3 id="可作为GCroot的节点："><a href="#可作为GCroot的节点：" class="headerlink" title="可作为GCroot的节点："></a>可作为GCroot的节点：</h3><p>全局性的引用（常量或静态类的引用）与执行上下文（栈帧中的本地变量表）</p><h1 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h1><h2 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>当对象被确认为垃圾对象之后，就会被标记为垃圾对象，标记的位置，在对象的header中，标记清除算法的两个缺点：1、效率不高 2、空间问题，不连续，后续创建大对象时寻址困难</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将堆内存分为两块区域，当创建对象时，仅仅使用其中一块区域，当进行垃圾回收时，不再是清除那些被标记为垃圾的对象，而是将没有被标记为垃圾的对象，复制到另一块内存区域，然后将原来那块区域清空，这样很好的解决了标记-清除算法的空间问题，但同时引入了一个新问题，就是内存的浪费，将一块内存分为相等的两块内存，意味着浪费了50%的空间，为此，IBM公司的一个专项研究表明，新生代内存中，98%的对象都是朝生夕死，因此不需要按照1：1来分配内存，而是将内存划分为1块较大的Eden空间和两块较小的Survivor空间，具体的比例为8：1：1，在垃圾回收时，Eden区域和其中一块Surivor区域中还存活的对象，一次性被复制到另一块Surivivor空间上，然后清理掉Eden和刚刚那块Surivivor空间，如果遇到大对象，Surivivor空间不够放时，将进行空间分配担保，将对象放入老年代</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制算法更适合新生代，但对于老年代，对象存活率比较高，无法采用复制算法，因此有人想出标记-整理算法，整个过程也分为两步，标记和整理，标记过程与标记清楚算法无异，但是标记完成后并没有马上清除，而是将所有存活的对象向内存的其中一端移动，然后再清理掉另一端的内存</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前主流的垃圾收集器都采用此算法，但这种算法并没有特别的思想，只是针对不同的区域，进行不同的算法，比如新生代采用复制算法，老年代采用标记-清除或标记-整理算法</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>最早的垃圾收集器，使用单线程收集垃圾，收集效率低下，无法利用多核Cpu的资源，但是现在Client模式的jvm，仍然默认使用这个收集器。</p><h3 id="Parnew"><a href="#Parnew" class="headerlink" title="Parnew"></a>Parnew</h3><p>是Serial的多线程版本，能充分利用多核cpu的资源，另一个重要的原因是能与CMS收集器配合使用</p><h3 id="Cms"><a href="#Cms" class="headerlink" title="Cms"></a>Cms</h3><p>并发标记清除垃圾收集器，能使GC产生的停顿时间减小到最小，除了枚举根节点，会产生GC停顿之外，其他的都能并发执行</p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>是当今收集器最前沿的成果之一</p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="回收过程分析"><a href="#回收过程分析" class="headerlink" title="回收过程分析"></a>回收过程分析</h2><h3 id="打印垃圾回收报告"><a href="#打印垃圾回收报告" class="headerlink" title="打印垃圾回收报告"></a>打印垃圾回收报告</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VM参数： -XX:+PrintGCDetails -verbose:gc -XX:+UseSerialGC</span><br></pre></td></tr></table></figure><ul><li><h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 69085K-&gt;8704K(78656K), 0.0203408 secs] 69085K-&gt;64309K(253440K), 0.0203707 secs] [Times: user=0.02 sys=0.02, real=0.02 secs]</span><br></pre></td></tr></table></figure></li></ul><h4 id="DefNew"><a href="#DefNew" class="headerlink" title="DefNew"></a>DefNew</h4><p>新生代区域名称，由垃圾收集器指定，如使用Serial收集器时，新生代的名字叫DefNew，采用Parallel收集器时，新生代的名称为PSYoungGen</p><h4 id="69085K-gt-8704K-78656K"><a href="#69085K-gt-8704K-78656K" class="headerlink" title="69085K-&gt;8704K(78656K)"></a>69085K-&gt;8704K(78656K)</h4><p>69085K代表本区域GC前的内存大小，8704K代表本区域GC后的内存大小，(78656K)代表本区域总内存大小</p><h4 id="69085K-gt-64309K-253440K"><a href="#69085K-gt-64309K-253440K" class="headerlink" title="69085K-&gt;64309K(253440K)"></a>69085K-&gt;64309K(253440K)</h4><p>69085K代表堆内存GC前的内存大小，64309K代表堆内存GC后的内存大小，(253440K)代表堆内存的总大小</p><h2 id="GC停顿"><a href="#GC停顿" class="headerlink" title="GC停顿"></a>GC停顿</h2><p>在枚举根节点时，不能出现对象的引用关系还在不断发生变化的情况，因此造成GC进行时，必须停止所有的线程，Sun将这件事称之为“Stop The World”，即使在号称几乎不会发生停顿的CMS（并发标记收集）收集器中，枚举根节点时也必须要停顿</p><h1 id="内存的创建"><a href="#内存的创建" class="headerlink" title="内存的创建"></a>内存的创建</h1><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h3 id="优先分配到eden"><a href="#优先分配到eden" class="headerlink" title="优先分配到eden"></a>优先分配到eden</h3><p>Eden区域新生代中的一块区域，也是垃圾收集器最常光顾的地方，新创建对象默认放置这个区域。</p><h3 id="大对象直接分配到老年代"><a href="#大对象直接分配到老年代" class="headerlink" title="大对象直接分配到老年代"></a>大对象直接分配到老年代</h3><p>由于在Eden区域中，一般使用复制算法进行垃圾清理，并且次数非常频繁，大对象在频繁但复制过程中性能低下，因此放到老年代中，gc次数相对较少，并且也并不使用复制算法，以提高性能。大对象的标准会根据内存环境自动计算得出，也可以使用-XX:PretenureSizeThreshold=10M,指定大于10Mb的对象叫大对象。</p><h3 id="长期存活到对象分配到老年代"><a href="#长期存活到对象分配到老年代" class="headerlink" title="长期存活到对象分配到老年代"></a>长期存活到对象分配到老年代</h3><p>每一次的垃圾回收之后，都会给对象的年龄+1，当年龄达到某个值当时候，即称之为长期存活，进入老年代。我们可以使用-XX:MaxTenuringThreshshold=10,指定age达到10的时候进入老年代，默认值为15</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><p>并非所有对象都需要到达MaxTenuringThreshshold指定的分代年龄之后才会进入老年代，但Survivor区域中，所有相同年龄的对象内存总和，大于Survivor的一半，即会进入老年代，不受MaxTenuringThreshshold的限制</p><h3 id="逃逸分析与栈上分配"><a href="#逃逸分析与栈上分配" class="headerlink" title="逃逸分析与栈上分配"></a>逃逸分析与栈上分配</h3><p>当对象仅在方法体内部使用时，由于方法当调用会创建栈帧，当调用结束就会出栈，因此将仅供该方法使用的对象，放在栈内存中，随着方法的出入栈而出入栈，而不用垃圾回收机制进行干预，可大大提高性能</p><h1 id="虚拟机工具"><a href="#虚拟机工具" class="headerlink" title="虚拟机工具"></a>虚拟机工具</h1><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>是一个命令行工具，全称是java process status，<br>常用的命令如下：</p><p>jps -l 可以显示java进程执行的主类</p><p>jps -m 可以显示程序执行所接收的参数，即main方法中的args参数</p><p>jps -v 可以显示虚拟机执行所接收的参数，如-Xms8m</p><h1 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h1><h2 id="Xmx"><a href="#Xmx" class="headerlink" title="-Xmx"></a>-Xmx</h2><p>最大堆容量</p><h2 id="Xms"><a href="#Xms" class="headerlink" title="-Xms"></a>-Xms</h2><p>最小堆容量</p><h2 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h2><p>栈内存大小，注意是单个线程的栈内存大小</p><h2 id="Xmn"><a href="#Xmn" class="headerlink" title="-Xmn"></a>-Xmn</h2><p>新生代内存大小</p><h2 id="XX-SurvivorRatio-8"><a href="#XX-SurvivorRatio-8" class="headerlink" title="-XX:SurvivorRatio=8"></a>-XX:SurvivorRatio=8</h2><p>新生代中，Eden区域与其中一个Surivivor区的大小比例是8：1</p><h2 id="XX-PertenureSizeThreshold"><a href="#XX-PertenureSizeThreshold" class="headerlink" title="-XX:PertenureSizeThreshold"></a>-XX:PertenureSizeThreshold</h2><p>大对象的定义，超过这个值的称之为大对象，直接放入老年代，避免在新生代中来回复制造成性能问题</p><h2 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h2><p>对象分代年龄分界线，超过这个值进入老年代，默认为15</p><h2 id="XX-MaxPermSize"><a href="#XX-MaxPermSize" class="headerlink" title="-XX:MaxPermSize"></a>-XX:MaxPermSize</h2><p>最大方法区(非堆)容量</p><h2 id="XX-MaxDirectMemorySize"><a href="#XX-MaxDirectMemorySize" class="headerlink" title="-XX:MaxDirectMemorySize"></a>-XX:MaxDirectMemorySize</h2><p>最大直接内存，如果不指定，默认与最大堆内存一致</p><h2 id="XX-PrintGCDetail"><a href="#XX-PrintGCDetail" class="headerlink" title="-XX:+PrintGCDetail"></a>-XX:+PrintGCDetail</h2><p>打印GC日志</p><h2 id="XX-PrintTenuringDistribution"><a href="#XX-PrintTenuringDistribution" class="headerlink" title="-XX:+PrintTenuringDistribution"></a>-XX:+PrintTenuringDistribution</h2><p>打印对象分代年龄</p><h2 id="HeapDumpOnOutOfMemoryError"><a href="#HeapDumpOnOutOfMemoryError" class="headerlink" title="HeapDumpOnOutOfMemoryError"></a>HeapDumpOnOutOfMemoryError</h2><p>当内存溢出时打印堆栈信息</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内存结构&quot;&gt;&lt;a href=&quot;#内存结构&quot; class=&quot;headerlink&quot; title=&quot;内存结构&quot;&gt;&lt;/a&gt;内存结构&lt;/h1&gt;&lt;h2 id=&quot;堆内存（线程共享）&quot;&gt;&lt;a href=&quot;#堆内存（线程共享）&quot; class=&quot;headerlink&quot; title=&quot;堆内存（线程共享）&quot;&gt;&lt;/a&gt;堆内存（线程共享）&lt;/h2&gt;&lt;h3 id=&quot;新生代&quot;&gt;&lt;a href=&quot;#新生代&quot; class=&quot;headerlink&quot; title=&quot;新生代&quot;&gt;&lt;/a&gt;新生代&lt;/h3&gt;&lt;p&gt;新创建的对象放入新生代，由于新生代的对象，大部分是朝生夕死，为了更好的垃圾回收，大多数垃圾收集器都采用复制算法，但由于最初的复制算法，将内存一分为二，浪费了50%的内存，因此后来将新生代内存划分为1块Eden区域和两块Survivor区域，默认的比例为8：1：1&lt;/p&gt;
&lt;h4 id=&quot;Eden&quot;&gt;&lt;a href=&quot;#Eden&quot; class=&quot;headerlink&quot; title=&quot;Eden&quot;&gt;&lt;/a&gt;Eden&lt;/h4&gt;&lt;p&gt;新创建的对象优先放入Eden区域&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://wangzx.org/categories/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>centos7搭建saltstack</title>
    <link href="http://wangzx.org/2018/02/07/salt-install/"/>
    <id>http://wangzx.org/2018/02/07/salt-install/</id>
    <published>2018-02-07T06:25:36.000Z</published>
    <updated>2018-02-09T02:29:13.226Z</updated>
    
    <content type="html"><![CDATA[<p>Salt，一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯。</p><p>salt底层采用动态的连接总线, 使其可以用于编配, 远程执行, 配置管理等等.</p><p><strong><a id="more"></a></strong></p><p>本次搭建使用centos7.1，共搭建1台master，2台minion，ip分配如下：</p><table><thead><tr><th style="text-align:left">服务器ip</th><th style="text-align:left">hostname</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">192.168.32.140</td><td style="text-align:left">salt-master</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.141</td><td style="text-align:left">salt-minion1</td><td style="text-align:left">minion</td></tr><tr><td style="text-align:left">192.168.32.142</td><td style="text-align:left">salt-minion2</td><td style="text-align:left">minion</td></tr></tbody></table><h1 id="服务器基础设置"><a href="#服务器基础设置" class="headerlink" title="服务器基础设置"></a>服务器基础设置</h1><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld</span><br><span class="line">$ systemctl disable firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ setenforce 0</span><br><span class="line">$ vi /etc/selinux/config</span><br></pre></td></tr></table></figure><p>将第6行修改为SELINUX=permissive<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># This file controls the state of SELinux on the system.</span><br><span class="line"># SELINUX= can take one of these three values:</span><br><span class="line">#     enforcing - SELinux security policy is enforced.</span><br><span class="line">#     permissive - SELinux prints warnings instead of enforcing.</span><br><span class="line">#     disabled - No SELinux policy is loaded.</span><br><span class="line">SELINUX=permissive</span><br><span class="line"># SELINUXTYPE= can take one of three two values:</span><br><span class="line">#     targeted - Targeted processes are protected,</span><br><span class="line">#     minimum - Modification of targeted policy. Only selected processes are protected.</span><br><span class="line">#     mls - Multi Level Security protection.</span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure></p><h2 id="设置hostname"><a href="#设置hostname" class="headerlink" title="设置hostname"></a>设置hostname</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hostnamectl set-hostname salt-master</span><br></pre></td></tr></table></figure><h2 id="修改host文件"><a href="#修改host文件" class="headerlink" title="修改host文件"></a>修改host文件</h2><p>修改/etc/hosts文件为如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.32.140 salt-master</span><br><span class="line">192.168.32.141 salt-minion1</span><br><span class="line">192.168.32.142 salt-minion2</span><br></pre></td></tr></table></figure></p><p>使用scp命令复制到其他2台服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp /etc/hosts root@salt-minion1:/etc/hosts</span><br></pre></td></tr></table></figure></p><h1 id="环境准备，依赖解决"><a href="#环境准备，依赖解决" class="headerlink" title="环境准备，依赖解决"></a>环境准备，依赖解决</h1><p>分别为三台机器添加阿里云epel源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup</span><br><span class="line">$ mv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup</span><br><span class="line">$ wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br></pre></td></tr></table></figure></p><p>解决依赖关系，不然会报python依赖错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum clean expire-cache</span><br><span class="line">$ yum upgrade</span><br><span class="line">$ yum -y install epel-release</span><br><span class="line">$ yum install zeromq3 m2crypto python-crypto python-jinja2 python-msgpack python-yaml python-zmq -y</span><br></pre></td></tr></table></figure><h1 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h1><h2 id="salt-master安装"><a href="#salt-master安装" class="headerlink" title="salt-master安装"></a>salt-master安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y salt-master</span><br></pre></td></tr></table></figure><h2 id="salt-minion安装"><a href="#salt-minion安装" class="headerlink" title="salt-minion安装"></a>salt-minion安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y salt-minion</span><br></pre></td></tr></table></figure><h1 id="配置-amp-启动"><a href="#配置-amp-启动" class="headerlink" title="配置&amp;启动"></a>配置&amp;启动</h1><h2 id="master配置"><a href="#master配置" class="headerlink" title="master配置"></a>master配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/salt/master</span><br></pre></td></tr></table></figure><p>修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#master消息发布端口 Default: 4505</span><br><span class="line">publish_port: 4505</span><br><span class="line">#工作线程数，应答和接受minion Default: 5</span><br><span class="line">worker_threads: 100</span><br><span class="line">#客户端与服务端通信的端口 Default: 4506</span><br><span class="line">ret_port: 4506</span><br><span class="line">#自动接受所有客户端</span><br><span class="line">auto_accept: True</span><br><span class="line">#启动salt-master</span><br></pre></td></tr></table></figure></p><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start salt-master</span><br></pre></td></tr></table></figure></p><h2 id="minion配置"><a href="#minion配置" class="headerlink" title="minion配置"></a>minion配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/salt/minion</span><br></pre></td></tr></table></figure><p>修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># master IP或域名</span><br><span class="line">master: salt-master</span><br><span class="line"># 客户端与服务端通信的端口。 Default: 4506</span><br><span class="line">master_port: 4506</span><br><span class="line"># id minion的唯一标示。Default: hostname</span><br><span class="line">id: salt-minion1</span><br></pre></td></tr></table></figure><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start salt-minion</span><br></pre></td></tr></table></figure></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="查看master的key列表"><a href="#查看master的key列表" class="headerlink" title="查看master的key列表"></a>查看master的key列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# salt-key -L</span><br><span class="line">Accepted Keys:（接受的key）</span><br><span class="line">salt-minion1</span><br><span class="line">salt-minion2</span><br><span class="line">Denied Keys:（否认的key）</span><br><span class="line">Unaccepted Keys:（未接受的key）</span><br><span class="line">Rejected Keys:（拒绝的key）</span><br></pre></td></tr></table></figure><h2 id="salt-key常用参数说明："><a href="#salt-key常用参数说明：" class="headerlink" title="salt-key常用参数说明："></a>salt-key常用参数说明：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-L 列出当前所有认证，包括Accepted Keys、Denied Keys、Unaccepted Keys、Rejected Keys</span><br><span class="line">-a 添加某个或某些个未接受(Unaccepted Keys)认证</span><br><span class="line">-A 添加所有未接受(Unaccepted Keys)认证</span><br><span class="line">-d 删除某个或某些个已接受(Accepted Keys)认证</span><br><span class="line">-D 删除所有已接受(Accepted Keys)认证</span><br><span class="line">-y 使用该参数可免去证书操作的交互，除非对minion端很信任，一般不建议使用</span><br><span class="line">-h 帮助</span><br></pre></td></tr></table></figure><h2 id="test-ping"><a href="#test-ping" class="headerlink" title="test.ping"></a>test.ping</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ salt &apos;*&apos; test.ping</span><br><span class="line">salt-minion1:</span><br><span class="line">True</span><br><span class="line">salt-minion2:</span><br><span class="line">True</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Salt，一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯。&lt;/p&gt;
&lt;p&gt;salt底层采用动态的连接总线, 使其可以用于编配, 远程执行, 配置管理等等.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="运维" scheme="http://wangzx.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>centos7搭建mesos集群</title>
    <link href="http://wangzx.org/2018/01/09/mesos-install/"/>
    <id>http://wangzx.org/2018/01/09/mesos-install/</id>
    <published>2018-01-09T11:08:36.000Z</published>
    <updated>2018-02-09T02:32:37.856Z</updated>
    
    <content type="html"><![CDATA[<p>Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。</p><p><strong><a id="more"></a></strong></p><p>本次搭建使用centos7.1，共搭建3台master，3台slave，ip分配如下：</p><table><thead><tr><th style="text-align:left">服务器ip</th><th style="text-align:left">hostname</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">192.168.32.131</td><td style="text-align:left">docker1.nd.com</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.132</td><td style="text-align:left">docker2.nd.com</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.133</td><td style="text-align:left">docker3.nd.com</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.134</td><td style="text-align:left">docker4.nd.com</td><td style="text-align:left">slave</td></tr><tr><td style="text-align:left">192.168.32.135</td><td style="text-align:left">docker5.nd.com</td><td style="text-align:left">slave</td></tr><tr><td style="text-align:left">192.168.32.136</td><td style="text-align:left">docker6.nd.com</td><td style="text-align:left">slave</td></tr></tbody></table><h1 id="服务器基础设置"><a href="#服务器基础设置" class="headerlink" title="服务器基础设置"></a>服务器基础设置</h1><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld</span><br><span class="line">$ systemctl disable firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ setenforce 0</span><br><span class="line">$ vi /etc/selinux/config</span><br></pre></td></tr></table></figure><p>将第6行修改为SELINUX=permissive<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># This file controls the state of SELinux on the system.</span><br><span class="line"># SELINUX= can take one of these three values:</span><br><span class="line">#     enforcing - SELinux security policy is enforced.</span><br><span class="line">#     permissive - SELinux prints warnings instead of enforcing.</span><br><span class="line">#     disabled - No SELinux policy is loaded.</span><br><span class="line">SELINUX=permissive</span><br><span class="line"># SELINUXTYPE= can take one of three two values:</span><br><span class="line">#     targeted - Targeted processes are protected,</span><br><span class="line">#     minimum - Modification of targeted policy. Only selected processes are protected.</span><br><span class="line">#     mls - Multi Level Security protection.</span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure></p><h2 id="设置hostname"><a href="#设置hostname" class="headerlink" title="设置hostname"></a>设置hostname</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hostnamectl set-hostname docker1.nd.com</span><br></pre></td></tr></table></figure><h2 id="修改host文件"><a href="#修改host文件" class="headerlink" title="修改host文件"></a>修改host文件</h2><p>修改/etc/hosts文件为如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">192.168.32.131 docker1.nd.com</span><br><span class="line">192.168.32.132 docker2.nd.com</span><br><span class="line">192.168.32.133 docker3.nd.com</span><br><span class="line">192.168.32.134 docker4.nd.com</span><br><span class="line">192.168.32.135 docker5.nd.com</span><br><span class="line">192.168.32.136 docker6.nd.com</span><br></pre></td></tr></table></figure></p><p>使用scp命令复制到其他5台服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp /etc/hosts root@docker2.nd.com:/etc/hosts</span><br></pre></td></tr></table></figure></p><h1 id="安装mesos、zookeeper包"><a href="#安装mesos、zookeeper包" class="headerlink" title="安装mesos、zookeeper包"></a>安装mesos、zookeeper包</h1><p> 1、分别在6台服务器上执行如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -Uvh http://repos.mesosphere.io/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm</span><br><span class="line">$ rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-mesosphere</span><br></pre></td></tr></table></figure></p><p>2、进入3台master服务器安装mesos、marathon和zookeeper<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install mesos marathon mesosphere-zookeeper -y</span><br></pre></td></tr></table></figure></p><p>3、进入3台slave服务器安装mesos<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install mesos -y</span><br></pre></td></tr></table></figure></p><h1 id="配置mesos、zookeeper"><a href="#配置mesos、zookeeper" class="headerlink" title="配置mesos、zookeeper"></a>配置mesos、zookeeper</h1><h2 id="配置zookeeper"><a href="#配置zookeeper" class="headerlink" title="配置zookeeper"></a>配置zookeeper</h2><p>1、修改/var/lib/zookeeper/myid文件，三台master服务器，分别设置为1、2、3<br>2、修改/etc/zookeeper/conf/zoo.cfg文件，在文件末尾添加以下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=192.168.32.131:2888:3888</span><br><span class="line">server.2=192.168.32.132:2888:3888</span><br><span class="line">server.3=192.168.32.133:2888:3888</span><br></pre></td></tr></table></figure></p><p>3、启动zookeeper服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start zookeeper</span><br></pre></td></tr></table></figure></p><p>4、查看zookeeper服务是否已启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl is-active zookeeper</span><br></pre></td></tr></table></figure><h2 id="配置mesos-master"><a href="#配置mesos-master" class="headerlink" title="配置mesos-master"></a>配置mesos-master</h2><p>1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos</span><br></pre></td></tr></table></figure></p><p>2、设置/etc/mesos-master/quorum文件中quorum的值，这个值要大于master数量的1/2，我们这里设置为2<br>3、停用mesos-slave<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop mesos-slave.service</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl disable mesos-slave.service</span><br></pre></td></tr></table></figure><p>4、启动mesos-master marathon<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start mesos-master</span><br><span class="line">$ marathon --master zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos</span><br></pre></td></tr></table></figure></p><p>正常情况下此时已经可以通过<a href="http://docker1.nd.com:5050打开mesos页面" target="_blank" rel="noopener">http://docker1.nd.com:5050打开mesos页面</a></p><h2 id="配置mesos-slave"><a href="#配置mesos-slave" class="headerlink" title="配置mesos-slave"></a>配置mesos-slave</h2><p>1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos</span><br></pre></td></tr></table></figure></p><p>2、停用mesos-master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop mesos-master.service</span><br><span class="line">$ systemctl disable mesos-master.service</span><br></pre></td></tr></table></figure></p><p>3、启动mesos-slave<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start mesos-slave</span><br></pre></td></tr></table></figure></p><h1 id="docker配置"><a href="#docker配置" class="headerlink" title="docker配置"></a>docker配置</h1><p>如需要在slave上运行docker，除docker自身安装配置外，还需要做如下设置<br>1、指定使用docker容器化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;docker,mesos&apos; &gt; /etc/mesos-slave/containerizers</span><br></pre></td></tr></table></figure></p><p>2、考虑到拉取容器镜像等的操作，适当增加timeout的时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;5mins&apos; &gt; /etc/mesos-slave/executor_registration_timeout</span><br></pre></td></tr></table></figure></p><p>3、重启mesos-slave以使上面配置生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart mesos-slave</span><br></pre></td></tr></table></figure></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>在测试环境中我们可以关闭防火墙，但在生产环境中，为了安全考虑，还是需要将防火墙开启<br>此时应注意，master需要向agent的所有ip开放5050端口，所有agent需要向master开放5051端口<br>并且为了用户可以访问mesos的前端页面，master需向用户ip开放5050端口，所有agent也需要向用户ip开放5051端口，否则会出现agent信息无法查看，task日志无法查看等问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="运维" scheme="http://wangzx.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
</feed>
