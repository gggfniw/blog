<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王志兴的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangzx.org/"/>
  <updated>2018-04-28T07:44:45.554Z</updated>
  <id>http://wangzx.org/</id>
  
  <author>
    <name>王志兴</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jdk动态代理解析</title>
    <link href="http://wangzx.org/2018/04/28/jdk-proxy/"/>
    <id>http://wangzx.org/2018/04/28/jdk-proxy/</id>
    <published>2018-04-28T07:43:02.000Z</published>
    <updated>2018-04-28T07:44:45.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface HelloService &#123;</span><br><span class="line">    void sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><a id="more"></a></strong></p><h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class HelloServiceImpl implements HelloService &#123;</span><br><span class="line"></span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class MyProxy &lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    private Class interfaceClass;</span><br><span class="line"></span><br><span class="line">    public MyProxy(Object target,Class interfaceClass) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.target = target;</span><br><span class="line">        this.interfaceClass = interfaceClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getProxy() &#123;</span><br><span class="line">        return (T)Proxy.newProxyInstance(interfaceClass.getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(), new InvocationHandler() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                        System.out.println(&quot;=== begin ===&quot;);</span><br><span class="line">                        Object result = method.invoke(target,args);</span><br><span class="line">                        System.out.println(&quot;=== end ===&quot;);</span><br><span class="line">                        return result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws Throwable &#123;</span><br><span class="line">        new Main().testProxy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testProxy() throws Throwable &#123;</span><br><span class="line">        HelloService userService = new HelloServiceImpl();</span><br><span class="line">        MyProxy&lt;HelloService&gt; myProxy = new MyProxy(userService,HelloService.class);</span><br><span class="line">        HelloService proxy = myProxy.getProxy();</span><br><span class="line">        proxy.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=== begin ===</span><br><span class="line">hello</span><br><span class="line">=== end ===</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>核心代码是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span><br></pre></td></tr></table></figure></p><p>这行代码将会产生一个代理类，这个类实现了HelloService的所有方法，在方法体重，调用第三个参数h，这个h即为我们上面代码中的匿名内部类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new InvocationHandler() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;=== begin ===&quot;);</span><br><span class="line">        Object result = method.invoke(target,args);</span><br><span class="line">        System.out.println(&quot;=== end ===&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>先来看newProxyInstance()这个方法，以下源码摘自jdk1.8，源码做了大量精简，仅保留核心代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)throws IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        //获取代理类的Class对象</span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">        //获取代理类的构造方法</span><br><span class="line">        final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        //生成实例</span><br><span class="line">        return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>getProxyClass0()方法也就是动态代理核心，经过各种缓存机制判断后，我们可以找到真正干活的那个方法，即ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags)，这个方法中，又调用了ProxyGenerator类的generateClassFile()方法，这个方法就是产生Class二进制文件的地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private byte[] generateClassFile() &#123;</span><br><span class="line">        this.addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">        this.addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">        this.addProxyMethod(toStringMethod, Object.class);</span><br><span class="line">        //...省略代码</span><br><span class="line">        ByteArrayOutputStream var13 = new ByteArrayOutputStream();</span><br><span class="line">        DataOutputStream var14 = new DataOutputStream(var13);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            var14.writeInt(-889275714);</span><br><span class="line">            var14.writeShort(0);</span><br><span class="line">            var14.writeShort(49);</span><br><span class="line">            this.cp.write(var14);</span><br><span class="line">            var14.writeShort(this.accessFlags);</span><br><span class="line">            var14.writeShort(this.cp.getClass(dotToSlash(this.className)));</span><br><span class="line">            var14.writeShort(this.cp.getClass(&quot;java/lang/reflect/Proxy&quot;));</span><br><span class="line">            var14.writeShort(this.interfaces.length);</span><br><span class="line">            //...省略代码</span><br><span class="line">            return var13.toByteArray();</span><br><span class="line">        &#125; catch (IOException var9) &#123;</span><br><span class="line">            throw new InternalError(&quot;unexpected I/O Exception&quot;, var9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法充斥着大量的逻辑性代码，没有什么值得看的地方，倒是这种生成Class二进制文件的方式是个亮点，笔者在看dubbo源码时，dubbo也会产生类似的动态代理类，但dubbo的方式是先生成java代码，就是 public class XXX这样，然后通过javassist变成Class文件，但jdk动态代理直接省去了生成java代码这一步，直接写二进制文件，显然这能提高效率，这里可以作为面试的一个点。</p><p>顺便介绍下Class文件的结构，从上面的代码也能看出来</p><p>第一行：writeInt(-889275714) -889275714转成二进制即为CAFEBABY，熟悉Class文件结构的朋友都知道这是Java Class文件的标记，任何Class文件都是以这个开头。</p><p>第二行：writeShort(0)，即两个字节的0，转为十六进制是00 00，这两个字节目前没有意义，是Class文件中罕见的没有意义的字符</p><p>第三行：writeShort(49)，49是jdk的魔数，即jdk的版本，49是jdk1.5，即生成的Class文件，能被jdk1.5以上的虚拟机运行</p><p>第四行：cp.write(var14)，写入常量池，常量池包括字面量和符号引用，字面量即文本字符串，声明为final的常量，符号引用即类和接口的全限定名，方法、字段的名称和描述符等，在上面的逻辑步骤中已经解析出了所有需要的常量池</p><p>第五行：writeShort(this.accessFlags);accessFlags即类的访问标志，这里的值是17，十六进制为11，查表可知这代表 final 和 public两种访问标志。</p><p>第六行：常量池写完，后面的所有操作都是写常量池中的编号，而不会再写入具体的名称</p><p>Class文件的结构严谨而复杂，有兴趣的同学可以阅读周志明编写的深入理解java虚拟机这一书</p><p>我们可以手动调用ProxyGenerator.generateProxyClass(“$Proxy0”, HelloService.class.getInterfaces())这个方法，得到二进制数据，将它写入磁盘，然后用反编译工具看下到底写了什么代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">package com.sun.proxy;</span><br><span class="line"></span><br><span class="line">import com.example.demo.java_demo.jdk_proxy.HelloService;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line">public final class $Proxy0 extends Proxy</span><br><span class="line">  implements HelloService</span><br><span class="line">&#123;</span><br><span class="line">  private static Method m1;</span><br><span class="line">  private static Method m3;</span><br><span class="line">  private static Method m2;</span><br><span class="line">  private static Method m0;</span><br><span class="line"></span><br><span class="line">  public $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    super(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final boolean equals(Object paramObject)</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final void sayHello()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      this.h.invoke(this, m3, null);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final String toString()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return (String)this.h.invoke(this, m2, null);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public final int hashCode()</span><br><span class="line">    throws </span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      return ((Integer)this.h.invoke(this, m0, null)).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      throw localError;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class="line">      m3 = Class.forName(&quot;com.example.demo.java_demo.jdk_proxy.HelloService&quot;).getMethod(&quot;sayHello&quot;, new Class[0]);</span><br><span class="line">      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键的sayHello方法，其实也是调用了this.h.invoke(this, m2, null);这个h，即我们上面写的那个匿名内部类。</p><p>完！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简单的例子&quot;&gt;&lt;a href=&quot;#简单的例子&quot; class=&quot;headerlink&quot; title=&quot;简单的例子&quot;&gt;&lt;/a&gt;简单的例子&lt;/h1&gt;&lt;h2 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h2&gt;&lt;h3 id=&quot;接口类&quot;&gt;&lt;a href=&quot;#接口类&quot; class=&quot;headerlink&quot; title=&quot;接口类&quot;&gt;&lt;/a&gt;接口类&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public interface HelloService &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    void sayHello();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="java" scheme="http://wangzx.org/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>java内存结构与垃圾回收</title>
    <link href="http://wangzx.org/2018/02/24/jvm/"/>
    <id>http://wangzx.org/2018/02/24/jvm/</id>
    <published>2018-02-24T11:12:56.000Z</published>
    <updated>2018-02-24T11:55:08.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><h2 id="堆内存（线程共享）"><a href="#堆内存（线程共享）" class="headerlink" title="堆内存（线程共享）"></a>堆内存（线程共享）</h2><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新创建的对象放入新生代，由于新生代的对象，大部分是朝生夕死，为了更好的垃圾回收，大多数垃圾收集器都采用复制算法，但由于最初的复制算法，将内存一分为二，浪费了50%的内存，因此后来将新生代内存划分为1块Eden区域和两块Survivor区域，默认的比例为8：1：1</p><h4 id="Eden"><a href="#Eden" class="headerlink" title="Eden"></a>Eden</h4><p>新创建的对象优先放入Eden区域</p><p><strong><a id="more"></a></strong></p><h4 id="Suvider"><a href="#Suvider" class="headerlink" title="Suvider"></a>Suvider</h4><p>Survivor区域有两块，进行一次垃圾回收后，Eden中存活的对象，被复制到Survivor区域中</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>长期存活的对象放入老年代</p><h2 id="方法区（线程共享）"><a href="#方法区（线程共享）" class="headerlink" title="方法区（线程共享）"></a>方法区（线程共享）</h2><p>用于存储已被加载的类信息，常量，静态变量，即使编译器编译后的代码数据等</p><h2 id="虚拟机栈（线程独享）"><a href="#虚拟机栈（线程独享）" class="headerlink" title="虚拟机栈（线程独享）"></a>虚拟机栈（线程独享）</h2><p>每个方法执行时，都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，栈帧伴随着方法的执行而入栈，随着方法的结束而出栈</p><h2 id="本地方法栈（线程独享）"><a href="#本地方法栈（线程独享）" class="headerlink" title="本地方法栈（线程独享）"></a>本地方法栈（线程独享）</h2><p>功能类似于虚拟机栈，只是这部分内存由native方法使用</p><h2 id="程序计数器（线程独享）"><a href="#程序计数器（线程独享）" class="headerlink" title="程序计数器（线程独享）"></a>程序计数器（线程独享）</h2><p>用于记录方法执行的行号，如果执行native方法，则无法记录行号，这是内存中唯一一块不会出现OOM的区域</p><h1 id="如何判断对象为垃圾对象"><a href="#如何判断对象为垃圾对象" class="headerlink" title="如何判断对象为垃圾对象"></a>如何判断对象为垃圾对象</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>添加一个引用计数器，当对象被引用时+1，解除引用时-1，当值为0时，即为垃圾对象，但由于这种算法，无法回收相互引用的对象，因此很少jvm采用这种算法</p><h2 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h2><p>从GCRoot向下搜索，所走过的路径，称之为引用链，都为有用的对象，否则即为垃圾对象</p><h3 id="可作为GCroot的节点："><a href="#可作为GCroot的节点：" class="headerlink" title="可作为GCroot的节点："></a>可作为GCroot的节点：</h3><p>全局性的引用（常量或静态类的引用）与执行上下文（栈帧中的本地变量表）</p><h1 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a>如何回收</h1><h2 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>当对象被确认为垃圾对象之后，就会被标记为垃圾对象，标记的位置，在对象的header中，标记清除算法的两个缺点：1、效率不高 2、空间问题，不连续，后续创建大对象时寻址困难</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将堆内存分为两块区域，当创建对象时，仅仅使用其中一块区域，当进行垃圾回收时，不再是清除那些被标记为垃圾的对象，而是将没有被标记为垃圾的对象，复制到另一块内存区域，然后将原来那块区域清空，这样很好的解决了标记-清除算法的空间问题，但同时引入了一个新问题，就是内存的浪费，将一块内存分为相等的两块内存，意味着浪费了50%的空间，为此，IBM公司的一个专项研究表明，新生代内存中，98%的对象都是朝生夕死，因此不需要按照1：1来分配内存，而是将内存划分为1块较大的Eden空间和两块较小的Survivor空间，具体的比例为8：1：1，在垃圾回收时，Eden区域和其中一块Surivor区域中还存活的对象，一次性被复制到另一块Surivivor空间上，然后清理掉Eden和刚刚那块Surivivor空间，如果遇到大对象，Surivivor空间不够放时，将进行空间分配担保，将对象放入老年代</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制算法更适合新生代，但对于老年代，对象存活率比较高，无法采用复制算法，因此有人想出标记-整理算法，整个过程也分为两步，标记和整理，标记过程与标记清楚算法无异，但是标记完成后并没有马上清除，而是将所有存活的对象向内存的其中一端移动，然后再清理掉另一端的内存</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前主流的垃圾收集器都采用此算法，但这种算法并没有特别的思想，只是针对不同的区域，进行不同的算法，比如新生代采用复制算法，老年代采用标记-清除或标记-整理算法</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>最早的垃圾收集器，使用单线程收集垃圾，收集效率低下，无法利用多核Cpu的资源，但是现在Client模式的jvm，仍然默认使用这个收集器。</p><h3 id="Parnew"><a href="#Parnew" class="headerlink" title="Parnew"></a>Parnew</h3><p>是Serial的多线程版本，能充分利用多核cpu的资源，另一个重要的原因是能与CMS收集器配合使用</p><h3 id="Cms"><a href="#Cms" class="headerlink" title="Cms"></a>Cms</h3><p>并发标记清除垃圾收集器，能使GC产生的停顿时间减小到最小，除了枚举根节点，会产生GC停顿之外，其他的都能并发执行</p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>是当今收集器最前沿的成果之一</p><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="回收过程分析"><a href="#回收过程分析" class="headerlink" title="回收过程分析"></a>回收过程分析</h2><h3 id="打印垃圾回收报告"><a href="#打印垃圾回收报告" class="headerlink" title="打印垃圾回收报告"></a>打印垃圾回收报告</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VM参数： -XX:+PrintGCDetails -verbose:gc -XX:+UseSerialGC</span><br></pre></td></tr></table></figure><ul><li><h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 69085K-&gt;8704K(78656K), 0.0203408 secs] 69085K-&gt;64309K(253440K), 0.0203707 secs] [Times: user=0.02 sys=0.02, real=0.02 secs]</span><br></pre></td></tr></table></figure></li></ul><h4 id="DefNew"><a href="#DefNew" class="headerlink" title="DefNew"></a>DefNew</h4><p>新生代区域名称，由垃圾收集器指定，如使用Serial收集器时，新生代的名字叫DefNew，采用Parallel收集器时，新生代的名称为PSYoungGen</p><h4 id="69085K-gt-8704K-78656K"><a href="#69085K-gt-8704K-78656K" class="headerlink" title="69085K-&gt;8704K(78656K)"></a>69085K-&gt;8704K(78656K)</h4><p>69085K代表本区域GC前的内存大小，8704K代表本区域GC后的内存大小，(78656K)代表本区域总内存大小</p><h4 id="69085K-gt-64309K-253440K"><a href="#69085K-gt-64309K-253440K" class="headerlink" title="69085K-&gt;64309K(253440K)"></a>69085K-&gt;64309K(253440K)</h4><p>69085K代表堆内存GC前的内存大小，64309K代表堆内存GC后的内存大小，(253440K)代表堆内存的总大小</p><h2 id="GC停顿"><a href="#GC停顿" class="headerlink" title="GC停顿"></a>GC停顿</h2><p>在枚举根节点时，不能出现对象的引用关系还在不断发生变化的情况，因此造成GC进行时，必须停止所有的线程，Sun将这件事称之为“Stop The World”，即使在号称几乎不会发生停顿的CMS（并发标记收集）收集器中，枚举根节点时也必须要停顿</p><h1 id="内存的创建"><a href="#内存的创建" class="headerlink" title="内存的创建"></a>内存的创建</h1><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><h3 id="优先分配到eden"><a href="#优先分配到eden" class="headerlink" title="优先分配到eden"></a>优先分配到eden</h3><p>Eden区域新生代中的一块区域，也是垃圾收集器最常光顾的地方，新创建对象默认放置这个区域。</p><h3 id="大对象直接分配到老年代"><a href="#大对象直接分配到老年代" class="headerlink" title="大对象直接分配到老年代"></a>大对象直接分配到老年代</h3><p>由于在Eden区域中，一般使用复制算法进行垃圾清理，并且次数非常频繁，大对象在频繁但复制过程中性能低下，因此放到老年代中，gc次数相对较少，并且也并不使用复制算法，以提高性能。大对象的标准会根据内存环境自动计算得出，也可以使用-XX:PretenureSizeThreshold=10M,指定大于10Mb的对象叫大对象。</p><h3 id="长期存活到对象分配到老年代"><a href="#长期存活到对象分配到老年代" class="headerlink" title="长期存活到对象分配到老年代"></a>长期存活到对象分配到老年代</h3><p>每一次的垃圾回收之后，都会给对象的年龄+1，当年龄达到某个值当时候，即称之为长期存活，进入老年代。我们可以使用-XX:MaxTenuringThreshshold=10,指定age达到10的时候进入老年代，默认值为15</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><h3 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h3><p>并非所有对象都需要到达MaxTenuringThreshshold指定的分代年龄之后才会进入老年代，但Survivor区域中，所有相同年龄的对象内存总和，大于Survivor的一半，即会进入老年代，不受MaxTenuringThreshshold的限制</p><h3 id="逃逸分析与栈上分配"><a href="#逃逸分析与栈上分配" class="headerlink" title="逃逸分析与栈上分配"></a>逃逸分析与栈上分配</h3><p>当对象仅在方法体内部使用时，由于方法当调用会创建栈帧，当调用结束就会出栈，因此将仅供该方法使用的对象，放在栈内存中，随着方法的出入栈而出入栈，而不用垃圾回收机制进行干预，可大大提高性能</p><h1 id="虚拟机工具"><a href="#虚拟机工具" class="headerlink" title="虚拟机工具"></a>虚拟机工具</h1><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p>是一个命令行工具，全称是java process status，<br>常用的命令如下：</p><p>jps -l 可以显示java进程执行的主类</p><p>jps -m 可以显示程序执行所接收的参数，即main方法中的args参数</p><p>jps -v 可以显示虚拟机执行所接收的参数，如-Xms8m</p><h1 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h1><h2 id="Xmx"><a href="#Xmx" class="headerlink" title="-Xmx"></a>-Xmx</h2><p>最大堆容量</p><h2 id="Xms"><a href="#Xms" class="headerlink" title="-Xms"></a>-Xms</h2><p>最小堆容量</p><h2 id="Xss"><a href="#Xss" class="headerlink" title="-Xss"></a>-Xss</h2><p>栈内存大小，注意是单个线程的栈内存大小</p><h2 id="Xmn"><a href="#Xmn" class="headerlink" title="-Xmn"></a>-Xmn</h2><p>新生代内存大小</p><h2 id="XX-SurvivorRatio-8"><a href="#XX-SurvivorRatio-8" class="headerlink" title="-XX:SurvivorRatio=8"></a>-XX:SurvivorRatio=8</h2><p>新生代中，Eden区域与其中一个Surivivor区的大小比例是8：1</p><h2 id="XX-PertenureSizeThreshold"><a href="#XX-PertenureSizeThreshold" class="headerlink" title="-XX:PertenureSizeThreshold"></a>-XX:PertenureSizeThreshold</h2><p>大对象的定义，超过这个值的称之为大对象，直接放入老年代，避免在新生代中来回复制造成性能问题</p><h2 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h2><p>对象分代年龄分界线，超过这个值进入老年代，默认为15</p><h2 id="XX-MaxPermSize"><a href="#XX-MaxPermSize" class="headerlink" title="-XX:MaxPermSize"></a>-XX:MaxPermSize</h2><p>最大方法区(非堆)容量</p><h2 id="XX-MaxDirectMemorySize"><a href="#XX-MaxDirectMemorySize" class="headerlink" title="-XX:MaxDirectMemorySize"></a>-XX:MaxDirectMemorySize</h2><p>最大直接内存，如果不指定，默认与最大堆内存一致</p><h2 id="XX-PrintGCDetail"><a href="#XX-PrintGCDetail" class="headerlink" title="-XX:+PrintGCDetail"></a>-XX:+PrintGCDetail</h2><p>打印GC日志</p><h2 id="XX-PrintTenuringDistribution"><a href="#XX-PrintTenuringDistribution" class="headerlink" title="-XX:+PrintTenuringDistribution"></a>-XX:+PrintTenuringDistribution</h2><p>打印对象分代年龄</p><h2 id="HeapDumpOnOutOfMemoryError"><a href="#HeapDumpOnOutOfMemoryError" class="headerlink" title="HeapDumpOnOutOfMemoryError"></a>HeapDumpOnOutOfMemoryError</h2><p>当内存溢出时打印堆栈信息</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内存结构&quot;&gt;&lt;a href=&quot;#内存结构&quot; class=&quot;headerlink&quot; title=&quot;内存结构&quot;&gt;&lt;/a&gt;内存结构&lt;/h1&gt;&lt;h2 id=&quot;堆内存（线程共享）&quot;&gt;&lt;a href=&quot;#堆内存（线程共享）&quot; class=&quot;headerlink&quot; title=&quot;堆内存（线程共享）&quot;&gt;&lt;/a&gt;堆内存（线程共享）&lt;/h2&gt;&lt;h3 id=&quot;新生代&quot;&gt;&lt;a href=&quot;#新生代&quot; class=&quot;headerlink&quot; title=&quot;新生代&quot;&gt;&lt;/a&gt;新生代&lt;/h3&gt;&lt;p&gt;新创建的对象放入新生代，由于新生代的对象，大部分是朝生夕死，为了更好的垃圾回收，大多数垃圾收集器都采用复制算法，但由于最初的复制算法，将内存一分为二，浪费了50%的内存，因此后来将新生代内存划分为1块Eden区域和两块Survivor区域，默认的比例为8：1：1&lt;/p&gt;
&lt;h4 id=&quot;Eden&quot;&gt;&lt;a href=&quot;#Eden&quot; class=&quot;headerlink&quot; title=&quot;Eden&quot;&gt;&lt;/a&gt;Eden&lt;/h4&gt;&lt;p&gt;新创建的对象优先放入Eden区域&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="jvm" scheme="http://wangzx.org/categories/jvm/"/>
    
    
  </entry>
  
  <entry>
    <title>centos7搭建saltstack</title>
    <link href="http://wangzx.org/2018/02/07/salt-install/"/>
    <id>http://wangzx.org/2018/02/07/salt-install/</id>
    <published>2018-02-07T06:25:36.000Z</published>
    <updated>2018-02-09T02:29:13.226Z</updated>
    
    <content type="html"><![CDATA[<p>Salt，一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯。</p><p>salt底层采用动态的连接总线, 使其可以用于编配, 远程执行, 配置管理等等.</p><p><strong><a id="more"></a></strong></p><p>本次搭建使用centos7.1，共搭建1台master，2台minion，ip分配如下：</p><table><thead><tr><th style="text-align:left">服务器ip</th><th style="text-align:left">hostname</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">192.168.32.140</td><td style="text-align:left">salt-master</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.141</td><td style="text-align:left">salt-minion1</td><td style="text-align:left">minion</td></tr><tr><td style="text-align:left">192.168.32.142</td><td style="text-align:left">salt-minion2</td><td style="text-align:left">minion</td></tr></tbody></table><h1 id="服务器基础设置"><a href="#服务器基础设置" class="headerlink" title="服务器基础设置"></a>服务器基础设置</h1><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld</span><br><span class="line">$ systemctl disable firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ setenforce 0</span><br><span class="line">$ vi /etc/selinux/config</span><br></pre></td></tr></table></figure><p>将第6行修改为SELINUX=permissive<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># This file controls the state of SELinux on the system.</span><br><span class="line"># SELINUX= can take one of these three values:</span><br><span class="line">#     enforcing - SELinux security policy is enforced.</span><br><span class="line">#     permissive - SELinux prints warnings instead of enforcing.</span><br><span class="line">#     disabled - No SELinux policy is loaded.</span><br><span class="line">SELINUX=permissive</span><br><span class="line"># SELINUXTYPE= can take one of three two values:</span><br><span class="line">#     targeted - Targeted processes are protected,</span><br><span class="line">#     minimum - Modification of targeted policy. Only selected processes are protected.</span><br><span class="line">#     mls - Multi Level Security protection.</span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure></p><h2 id="设置hostname"><a href="#设置hostname" class="headerlink" title="设置hostname"></a>设置hostname</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hostnamectl set-hostname salt-master</span><br></pre></td></tr></table></figure><h2 id="修改host文件"><a href="#修改host文件" class="headerlink" title="修改host文件"></a>修改host文件</h2><p>修改/etc/hosts文件为如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.32.140 salt-master</span><br><span class="line">192.168.32.141 salt-minion1</span><br><span class="line">192.168.32.142 salt-minion2</span><br></pre></td></tr></table></figure></p><p>使用scp命令复制到其他2台服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp /etc/hosts root@salt-minion1:/etc/hosts</span><br></pre></td></tr></table></figure></p><h1 id="环境准备，依赖解决"><a href="#环境准备，依赖解决" class="headerlink" title="环境准备，依赖解决"></a>环境准备，依赖解决</h1><p>分别为三台机器添加阿里云epel源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup</span><br><span class="line">$ mv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup</span><br><span class="line">$ wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br></pre></td></tr></table></figure></p><p>解决依赖关系，不然会报python依赖错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ yum clean expire-cache</span><br><span class="line">$ yum upgrade</span><br><span class="line">$ yum -y install epel-release</span><br><span class="line">$ yum install zeromq3 m2crypto python-crypto python-jinja2 python-msgpack python-yaml python-zmq -y</span><br></pre></td></tr></table></figure><h1 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h1><h2 id="salt-master安装"><a href="#salt-master安装" class="headerlink" title="salt-master安装"></a>salt-master安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y salt-master</span><br></pre></td></tr></table></figure><h2 id="salt-minion安装"><a href="#salt-minion安装" class="headerlink" title="salt-minion安装"></a>salt-minion安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y salt-minion</span><br></pre></td></tr></table></figure><h1 id="配置-amp-启动"><a href="#配置-amp-启动" class="headerlink" title="配置&amp;启动"></a>配置&amp;启动</h1><h2 id="master配置"><a href="#master配置" class="headerlink" title="master配置"></a>master配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/salt/master</span><br></pre></td></tr></table></figure><p>修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#master消息发布端口 Default: 4505</span><br><span class="line">publish_port: 4505</span><br><span class="line">#工作线程数，应答和接受minion Default: 5</span><br><span class="line">worker_threads: 100</span><br><span class="line">#客户端与服务端通信的端口 Default: 4506</span><br><span class="line">ret_port: 4506</span><br><span class="line">#自动接受所有客户端</span><br><span class="line">auto_accept: True</span><br><span class="line">#启动salt-master</span><br></pre></td></tr></table></figure></p><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start salt-master</span><br></pre></td></tr></table></figure></p><h2 id="minion配置"><a href="#minion配置" class="headerlink" title="minion配置"></a>minion配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/salt/minion</span><br></pre></td></tr></table></figure><p>修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># master IP或域名</span><br><span class="line">master: salt-master</span><br><span class="line"># 客户端与服务端通信的端口。 Default: 4506</span><br><span class="line">master_port: 4506</span><br><span class="line"># id minion的唯一标示。Default: hostname</span><br><span class="line">id: salt-minion1</span><br></pre></td></tr></table></figure><p>启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start salt-minion</span><br></pre></td></tr></table></figure></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="查看master的key列表"><a href="#查看master的key列表" class="headerlink" title="查看master的key列表"></a>查看master的key列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# salt-key -L</span><br><span class="line">Accepted Keys:（接受的key）</span><br><span class="line">salt-minion1</span><br><span class="line">salt-minion2</span><br><span class="line">Denied Keys:（否认的key）</span><br><span class="line">Unaccepted Keys:（未接受的key）</span><br><span class="line">Rejected Keys:（拒绝的key）</span><br></pre></td></tr></table></figure><h2 id="salt-key常用参数说明："><a href="#salt-key常用参数说明：" class="headerlink" title="salt-key常用参数说明："></a>salt-key常用参数说明：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-L 列出当前所有认证，包括Accepted Keys、Denied Keys、Unaccepted Keys、Rejected Keys</span><br><span class="line">-a 添加某个或某些个未接受(Unaccepted Keys)认证</span><br><span class="line">-A 添加所有未接受(Unaccepted Keys)认证</span><br><span class="line">-d 删除某个或某些个已接受(Accepted Keys)认证</span><br><span class="line">-D 删除所有已接受(Accepted Keys)认证</span><br><span class="line">-y 使用该参数可免去证书操作的交互，除非对minion端很信任，一般不建议使用</span><br><span class="line">-h 帮助</span><br></pre></td></tr></table></figure><h2 id="test-ping"><a href="#test-ping" class="headerlink" title="test.ping"></a>test.ping</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ salt &apos;*&apos; test.ping</span><br><span class="line">salt-minion1:</span><br><span class="line">True</span><br><span class="line">salt-minion2:</span><br><span class="line">True</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Salt，一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯。&lt;/p&gt;
&lt;p&gt;salt底层采用动态的连接总线, 使其可以用于编配, 远程执行, 配置管理等等.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="运维" scheme="http://wangzx.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
  <entry>
    <title>centos7搭建mesos集群</title>
    <link href="http://wangzx.org/2018/01/09/mesos-install/"/>
    <id>http://wangzx.org/2018/01/09/mesos-install/</id>
    <published>2018-01-09T11:08:36.000Z</published>
    <updated>2018-02-09T02:32:37.856Z</updated>
    
    <content type="html"><![CDATA[<p>Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。</p><p><strong><a id="more"></a></strong></p><p>本次搭建使用centos7.1，共搭建3台master，3台slave，ip分配如下：</p><table><thead><tr><th style="text-align:left">服务器ip</th><th style="text-align:left">hostname</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">192.168.32.131</td><td style="text-align:left">docker1.nd.com</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.132</td><td style="text-align:left">docker2.nd.com</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.133</td><td style="text-align:left">docker3.nd.com</td><td style="text-align:left">master</td></tr><tr><td style="text-align:left">192.168.32.134</td><td style="text-align:left">docker4.nd.com</td><td style="text-align:left">slave</td></tr><tr><td style="text-align:left">192.168.32.135</td><td style="text-align:left">docker5.nd.com</td><td style="text-align:left">slave</td></tr><tr><td style="text-align:left">192.168.32.136</td><td style="text-align:left">docker6.nd.com</td><td style="text-align:left">slave</td></tr></tbody></table><h1 id="服务器基础设置"><a href="#服务器基础设置" class="headerlink" title="服务器基础设置"></a>服务器基础设置</h1><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop firewalld</span><br><span class="line">$ systemctl disable firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ setenforce 0</span><br><span class="line">$ vi /etc/selinux/config</span><br></pre></td></tr></table></figure><p>将第6行修改为SELINUX=permissive<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># This file controls the state of SELinux on the system.</span><br><span class="line"># SELINUX= can take one of these three values:</span><br><span class="line">#     enforcing - SELinux security policy is enforced.</span><br><span class="line">#     permissive - SELinux prints warnings instead of enforcing.</span><br><span class="line">#     disabled - No SELinux policy is loaded.</span><br><span class="line">SELINUX=permissive</span><br><span class="line"># SELINUXTYPE= can take one of three two values:</span><br><span class="line">#     targeted - Targeted processes are protected,</span><br><span class="line">#     minimum - Modification of targeted policy. Only selected processes are protected.</span><br><span class="line">#     mls - Multi Level Security protection.</span><br><span class="line">SELINUXTYPE=targeted</span><br></pre></td></tr></table></figure></p><h2 id="设置hostname"><a href="#设置hostname" class="headerlink" title="设置hostname"></a>设置hostname</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hostnamectl set-hostname docker1.nd.com</span><br></pre></td></tr></table></figure><h2 id="修改host文件"><a href="#修改host文件" class="headerlink" title="修改host文件"></a>修改host文件</h2><p>修改/etc/hosts文件为如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">192.168.32.131 docker1.nd.com</span><br><span class="line">192.168.32.132 docker2.nd.com</span><br><span class="line">192.168.32.133 docker3.nd.com</span><br><span class="line">192.168.32.134 docker4.nd.com</span><br><span class="line">192.168.32.135 docker5.nd.com</span><br><span class="line">192.168.32.136 docker6.nd.com</span><br></pre></td></tr></table></figure></p><p>使用scp命令复制到其他5台服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp /etc/hosts root@docker2.nd.com:/etc/hosts</span><br></pre></td></tr></table></figure></p><h1 id="安装mesos、zookeeper包"><a href="#安装mesos、zookeeper包" class="headerlink" title="安装mesos、zookeeper包"></a>安装mesos、zookeeper包</h1><p> 1、分别在6台服务器上执行如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -Uvh http://repos.mesosphere.io/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm</span><br><span class="line">$ rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-mesosphere</span><br></pre></td></tr></table></figure></p><p>2、进入3台master服务器安装mesos、marathon和zookeeper<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install mesos marathon mesosphere-zookeeper -y</span><br></pre></td></tr></table></figure></p><p>3、进入3台slave服务器安装mesos<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install mesos -y</span><br></pre></td></tr></table></figure></p><h1 id="配置mesos、zookeeper"><a href="#配置mesos、zookeeper" class="headerlink" title="配置mesos、zookeeper"></a>配置mesos、zookeeper</h1><h2 id="配置zookeeper"><a href="#配置zookeeper" class="headerlink" title="配置zookeeper"></a>配置zookeeper</h2><p>1、修改/var/lib/zookeeper/myid文件，三台master服务器，分别设置为1、2、3<br>2、修改/etc/zookeeper/conf/zoo.cfg文件，在文件末尾添加以下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.1=192.168.32.131:2888:3888</span><br><span class="line">server.2=192.168.32.132:2888:3888</span><br><span class="line">server.3=192.168.32.133:2888:3888</span><br></pre></td></tr></table></figure></p><p>3、启动zookeeper服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start zookeeper</span><br></pre></td></tr></table></figure></p><p>4、查看zookeeper服务是否已启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl is-active zookeeper</span><br></pre></td></tr></table></figure><h2 id="配置mesos-master"><a href="#配置mesos-master" class="headerlink" title="配置mesos-master"></a>配置mesos-master</h2><p>1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos</span><br></pre></td></tr></table></figure></p><p>2、设置/etc/mesos-master/quorum文件中quorum的值，这个值要大于master数量的1/2，我们这里设置为2<br>3、停用mesos-slave<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop mesos-slave.service</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl disable mesos-slave.service</span><br></pre></td></tr></table></figure><p>4、启动mesos-master marathon<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start mesos-master</span><br><span class="line">$ marathon --master zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos</span><br></pre></td></tr></table></figure></p><p>正常情况下此时已经可以通过<a href="http://docker1.nd.com:5050打开mesos页面" target="_blank" rel="noopener">http://docker1.nd.com:5050打开mesos页面</a></p><h2 id="配置mesos-slave"><a href="#配置mesos-slave" class="headerlink" title="配置mesos-slave"></a>配置mesos-slave</h2><p>1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos</span><br></pre></td></tr></table></figure></p><p>2、停用mesos-master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl stop mesos-master.service</span><br><span class="line">$ systemctl disable mesos-master.service</span><br></pre></td></tr></table></figure></p><p>3、启动mesos-slave<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start mesos-slave</span><br></pre></td></tr></table></figure></p><h1 id="docker配置"><a href="#docker配置" class="headerlink" title="docker配置"></a>docker配置</h1><p>如需要在slave上运行docker，除docker自身安装配置外，还需要做如下设置<br>1、指定使用docker容器化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;docker,mesos&apos; &gt; /etc/mesos-slave/containerizers</span><br></pre></td></tr></table></figure></p><p>2、考虑到拉取容器镜像等的操作，适当增加timeout的时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;5mins&apos; &gt; /etc/mesos-slave/executor_registration_timeout</span><br></pre></td></tr></table></figure></p><p>3、重启mesos-slave以使上面配置生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart mesos-slave</span><br></pre></td></tr></table></figure></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>在测试环境中我们可以关闭防火墙，但在生产环境中，为了安全考虑，还是需要将防火墙开启<br>此时应注意，master需要向agent的所有ip开放5050端口，所有agent需要向master开放5051端口<br>并且为了用户可以访问mesos的前端页面，master需向用户ip开放5050端口，所有agent也需要向用户ip开放5051端口，否则会出现agent信息无法查看，task日志无法查看等问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
    
    </summary>
    
      <category term="运维" scheme="http://wangzx.org/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
  </entry>
  
</feed>
