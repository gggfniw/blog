<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java内存结构与垃圾回收]]></title>
    <url>%2F2018%2F02%2F24%2Fjvm%2F</url>
    <content type="text"><![CDATA[内存结构堆内存（线程共享） 新生代新创建的对象放入新生代，由于新生代的对象，大部分是朝生夕死，为了更好的垃圾回收，大多数垃圾收集器都采用复制算法，但由于最初的复制算法，将内存一分为二，浪费了50%的内存，因此后来将新生代内存划分为1块Eden区域和两块Survivor区域，默认的比例为8：1：1 Eden新创建的对象优先放入Eden区域 SuviderSurvivor区域有两块，进行一次垃圾回收后，Eden中存活的对象，被复制到Survivor区域中 老年代长期存活的对象放入老年代 方法区（线程共享）用于存储已被加载的类信息，常量，静态变量，即使编译器编译后的代码数据等 虚拟机栈（线程独享）每个方法执行时，都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，栈帧伴随着方法的执行而入栈，随着方法的结束而出栈 本地方法栈（线程独享）功能类似于虚拟机栈，只是这部分内存由native方法使用 程序计数器（线程独享）用于记录方法执行的行号，如果执行native方法，则无法记录行号，这是内存中唯一一块不会出现OOM的区域 如何判断对象为垃圾对象1、引用计数法添加一个引用计数器，当对象被引用时+1，解除引用时-1，当值为0时，即为垃圾对象，但由于这种算法，无法回收相互引用的对象，因此很少jvm采用这种算法 2、可达性分析法从GCRoot向下搜索，所走过的路径，称之为引用链，都为有用的对象，否则即为垃圾对象 可作为GCroot的节点：全局性的引用（常量或静态类的引用）与执行上下文（栈帧中的本地变量表） GC停顿在枚举根节点时，不能出现对象的引用关系还在不断发生变化的情况，因此造成GC进行时，必须停止所有的线程，Sun将这件事称之为“Stop The World”，即使在号称几乎不会发生停顿的CMS（并发标记收集）收集器中，枚举根节点时也必须要停顿 如何回收1、回收策略 标记-清除算法当对象被确认为垃圾对象之后，就会被标记为垃圾对象，标记的位置，在对象的header中，标记清除算法的两个缺点：1、效率不高 2、空间问题，不连续，后续创建大对象时寻址困难 复制算法将堆内存分为两块区域，当创建对象时，仅仅使用其中一块区域，当进行垃圾回收时，不再是清除那些被标记为垃圾的对象，而是将没有被标记为垃圾的对象，复制到另一块内存区域，然后将原来那块区域清空，这样很好的解决了标记-清除算法的空间问题，但同时引入了一个新问题，就是内存的浪费，将一块内存分为相等的两块内存，意味着浪费了50%的空间，为此，IBM公司的一个专项研究表明，新生代内存中，98%的对象都是朝生夕死，因此不需要按照1：1来分配内存，而是将内存划分为1块较大的Eden空间和两块较小的Survivor空间，具体的比例为8：1：1，在垃圾回收时，Eden区域和其中一块Surivor区域中还存活的对象，一次性被复制到另一块Surivivor空间上，然后清理掉Eden和刚刚那块Surivivor空间，如果遇到大对象，Surivivor空间不够放时，将进行空间分配担保，将对象放入老年代 标记-整理算法复制算法更适合新生代，但对于老年代，对象存活率比较高，无法采用复制算法，因此有人想出标记-整理算法，整个过程也分为两步，标记和整理，标记过程与标记清楚算法无异，但是标记完成后并没有马上清除，而是将所有存活的对象向内存的其中一端移动，然后再清理掉另一端的内存 分代收集算法当前主流的垃圾收集器都采用此算法，但这种算法并没有特别的思想，只是针对不同的区域，进行不同的算法，比如新生代采用复制算法，老年代采用标记-清除或标记-整理算法2、垃圾收集器 Serial最早的垃圾收集器，使用单线程收集垃圾，收集效率低下，无法利用多核Cpu的资源，但是现在Client模式的jvm，仍然默认使用这个收集器。 Parnew是Serial的多线程版本，能充分利用多核cpu的资源，另一个重要的原因是能与CMS收集器配合使用 Cms并发标记清除垃圾收集器，能使GC产生的停顿时间减小到最小，除了枚举根节点，会产生GC停顿之外，其他的都能并发执行 G1是当今收集器最前沿的成果之一 垃圾回收1、回收过程分析 打印垃圾回收报告1VM参数： -XX:+PrintGCDetails -verbose:gc -XX:+UseSerialGC GC日志分析1[GC (Allocation Failure) [DefNew: 69085K-&gt;8704K(78656K), 0.0203408 secs] 69085K-&gt;64309K(253440K), 0.0203707 secs] [Times: user=0.02 sys=0.02, real=0.02 secs] DefNew新生代区域名称，由垃圾收集器指定，如使用Serial收集器时，新生代的名字叫DefNew，采用Parallel收集器时，新生代的名称为PSYoungGen 69085K-&gt;8704K(78656K)69085K代表本区域GC前的内存大小，8704K代表本区域GC后的内存大小，(78656K)代表本区域总内存大小 69085K-&gt;64309K(253440K)69085K代表堆内存GC前的内存大小，64309K代表堆内存GC后的内存大小，(253440K)代表堆内存的总大小内存的创建内存分配策略 优先分配到edenEden区域新生代中的一块区域，也是垃圾收集器最常光顾的地方，新创建对象默认放置这个区域。 大对象直接分配到老年代由于在Eden区域中，一般使用复制算法进行垃圾清理，并且次数非常频繁，大对象在频繁但复制过程中性能低下，因此放到老年代中，gc次数相对较少，并且也并不使用复制算法，以提高性能。 问题：什么叫大对象答：大对象的标准会根据内存环境自动计算得出，也可以使用-XX:PretenureSizeThreshold=10M,指定大于10Mb的对象叫大对象。 长期存活到对象分配到老年代每一次的垃圾回收之后，都会给对象的年龄+1，当年龄达到某个值当时候，即称之为长期存活，进入老年代。我们可以使用-XX:MaxTenuringThreshshold=10,指定age达到10的时候进入老年代，默认值为15 空间分配担保 动态对象年龄判断并非所有对象都需要到达MaxTenuringThreshshold指定的分代年龄之后才会进入老年代，但Survivor区域中，所有相同年龄的对象内存总和，大于Survivor的一半，即会进入老年代，不受MaxTenuringThreshshold的限制 逃逸分析与栈上分配当对象仅在方法体内部使用时，由于方法当调用会创建栈帧，当调用结束就会出栈，因此将仅供该方法使用的对象，放在栈内存中，随着方法的出入栈而出入栈，而不用垃圾回收机制进行干预，可大大提高性能 虚拟机工具jps是一个命令行工具，全称是java process status，常用的命令如下： jps -l 可以显示java进程执行的主类 jps -m 可以显示程序执行所接收的参数，即main方法中的args参数 jps -v 可以显示虚拟机执行所接收的参数，如-Xms8m 常用参数-Xmx最大堆容量 -Xms最小堆容量 -Xss栈内存大小，注意是单个线程的栈内存大小 -Xmn新生代内存大小 -XX:SurvivorRatio=8新生代中，Eden区域与其中一个Surivivor区的大小比例是8：1 -XX:PertenureSizeThreshold大对象的定义，超过这个值的称之为大对象，直接放入老年代，避免在新生代中来回复制造成性能问题 -XX:MaxTenuringThreshold对象分代年龄分界线，超过这个值进入老年代，默认为15 -XX:MaxPermSize最大方法区(非堆)容量 -XX:MaxDirectMemorySize最大直接内存，如果不指定，默认与最大堆内存一致 -XX:+PrintGCDetail打印GC日志 -XX:+PrintTenuringDistribution打印对象分代年龄 HeapDumpOnOutOfMemoryError当内存溢出时打印堆栈信息]]></content>
      <categories>
        <category>jvm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos7搭建saltstack]]></title>
    <url>%2F2018%2F02%2F07%2Fsalt-install%2F</url>
    <content type="text"><![CDATA[Salt，一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯。 salt底层采用动态的连接总线, 使其可以用于编配, 远程执行, 配置管理等等. 本次搭建使用centos7.1，共搭建1台master，2台minion，ip分配如下： 服务器ip hostname 说明 192.168.32.140 salt-master master 192.168.32.141 salt-minion1 minion 192.168.32.142 salt-minion2 minion 服务器基础设置关闭防火墙12$ systemctl stop firewalld$ systemctl disable firewalld 关闭selinux12$ setenforce 0$ vi /etc/selinux/config 将第6行修改为SELINUX=permissive1234567891011# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=permissive# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected.# mls - Multi Level Security protection.SELINUXTYPE=targeted 设置hostname1$ hostnamectl set-hostname salt-master 修改host文件修改/etc/hosts文件为如下内容123192.168.32.140 salt-master192.168.32.141 salt-minion1192.168.32.142 salt-minion2 使用scp命令复制到其他2台服务器1$ scp /etc/hosts root@salt-minion1:/etc/hosts 环境准备，依赖解决分别为三台机器添加阿里云epel源123$ mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup$ mv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup$ wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 解决依赖关系，不然会报python依赖错误 1234$ yum clean expire-cache$ yum upgrade$ yum -y install epel-release$ yum install zeromq3 m2crypto python-crypto python-jinja2 python-msgpack python-yaml python-zmq -y 开始安装salt-master安装1$ yum install -y salt-master salt-minion安装1$ yum install -y salt-minion 配置&amp;启动master配置1$ vim /etc/salt/master 修改如下：123456789#master消息发布端口 Default: 4505publish_port: 4505#工作线程数，应答和接受minion Default: 5worker_threads: 100#客户端与服务端通信的端口 Default: 4506ret_port: 4506#自动接受所有客户端auto_accept: True#启动salt-master 启动：1$ systemctl start salt-master minion配置1$ vim /etc/salt/minion 修改如下： 123456# master IP或域名master: salt-master# 客户端与服务端通信的端口。 Default: 4506master_port: 4506# id minion的唯一标示。Default: hostnameid: salt-minion1 启动：1$ systemctl start salt-minion 测试查看master的key列表1234567[root@localhost ~]# salt-key -LAccepted Keys:（接受的key）salt-minion1salt-minion2Denied Keys:（否认的key）Unaccepted Keys:（未接受的key）Rejected Keys:（拒绝的key） salt-key常用参数说明：1234567-L 列出当前所有认证，包括Accepted Keys、Denied Keys、Unaccepted Keys、Rejected Keys-a 添加某个或某些个未接受(Unaccepted Keys)认证-A 添加所有未接受(Unaccepted Keys)认证-d 删除某个或某些个已接受(Accepted Keys)认证-D 删除所有已接受(Accepted Keys)认证-y 使用该参数可免去证书操作的交互，除非对minion端很信任，一般不建议使用-h 帮助 test.ping12345$ salt &apos;*&apos; test.pingsalt-minion1:Truesalt-minion2:True]]></content>
      <categories>
        <category>运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos7搭建mesos集群]]></title>
    <url>%2F2018%2F01%2F09%2Fmesos-install%2F</url>
    <content type="text"><![CDATA[Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。 本次搭建使用centos7.1，共搭建3台master，3台slave，ip分配如下： 服务器ip hostname 说明 192.168.32.131 docker1.nd.com master 192.168.32.132 docker2.nd.com master 192.168.32.133 docker3.nd.com master 192.168.32.134 docker4.nd.com slave 192.168.32.135 docker5.nd.com slave 192.168.32.136 docker6.nd.com slave 服务器基础设置关闭防火墙12$ systemctl stop firewalld$ systemctl disable firewalld 关闭selinux12$ setenforce 0$ vi /etc/selinux/config 将第6行修改为SELINUX=permissive1234567891011# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=permissive# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected.# mls - Multi Level Security protection.SELINUXTYPE=targeted 设置hostname1$ hostnamectl set-hostname docker1.nd.com 修改host文件修改/etc/hosts文件为如下内容123456192.168.32.131 docker1.nd.com192.168.32.132 docker2.nd.com192.168.32.133 docker3.nd.com192.168.32.134 docker4.nd.com192.168.32.135 docker5.nd.com192.168.32.136 docker6.nd.com 使用scp命令复制到其他5台服务器1$ scp /etc/hosts root@docker2.nd.com:/etc/hosts 安装mesos、zookeeper包 1、分别在6台服务器上执行如下命令12$ rpm -Uvh http://repos.mesosphere.io/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm$ rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-mesosphere 2、进入3台master服务器安装mesos、marathon和zookeeper1$ yum install mesos marathon mesosphere-zookeeper -y 3、进入3台slave服务器安装mesos1$ yum install mesos -y 配置mesos、zookeeper配置zookeeper1、修改/var/lib/zookeeper/myid文件，三台master服务器，分别设置为1、2、32、修改/etc/zookeeper/conf/zoo.cfg文件，在文件末尾添加以下配置123server.1=192.168.32.131:2888:3888server.2=192.168.32.132:2888:3888server.3=192.168.32.133:2888:3888 3、启动zookeeper服务1$ systemctl start zookeeper 4、查看zookeeper服务是否已启动 1$ systemctl is-active zookeeper 配置mesos-master1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容1zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos 2、设置/etc/mesos-master/quorum文件中quorum的值，这个值要大于master数量的1/2，我们这里设置为23、停用mesos-slave1$ systemctl stop mesos-slave.service 1$ systemctl disable mesos-slave.service 4、启动mesos-master marathon12$ systemctl start mesos-master$ marathon --master zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos 正常情况下此时已经可以通过http://docker1.nd.com:5050打开mesos页面 配置mesos-slave1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容1zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos 2、停用mesos-master12$ systemctl stop mesos-master.service$ systemctl disable mesos-master.service 3、启动mesos-slave1$ systemctl start mesos-slave docker配置如需要在slave上运行docker，除docker自身安装配置外，还需要做如下设置1、指定使用docker容器化1$ echo &apos;docker,mesos&apos; &gt; /etc/mesos-slave/containerizers 2、考虑到拉取容器镜像等的操作，适当增加timeout的时间1$ echo &apos;5mins&apos; &gt; /etc/mesos-slave/executor_registration_timeout 3、重启mesos-slave以使上面配置生效1$ systemctl restart mesos-slave 注意事项在测试环境中我们可以关闭防火墙，但在生产环境中，为了安全考虑，还是需要将防火墙开启此时应注意，master需要向agent的所有ip开放5050端口，所有agent需要向master开放5051端口并且为了用户可以访问mesos的前端页面，master需向用户ip开放5050端口，所有agent也需要向用户ip开放5051端口，否则会出现agent信息无法查看，task日志无法查看等问题]]></content>
      <categories>
        <category>运维</category>
      </categories>
  </entry>
</search>
