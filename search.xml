<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《dubbo源码深度解析》之serialize 数据序列化层]]></title>
    <url>%2F2018%2F05%2F18%2Fdubbo-serialize%20%2F</url>
    <content type="text"><![CDATA[serialize 数据序列化层：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool Serialization12345678910111213141516171819202122232425262728293031323334353637383940@SPI(&quot;hessian2&quot;)public interface Serialization &#123; /** * get content type id * * @return content type id */ byte getContentTypeId(); /** * get content type * * @return content type */ String getContentType(); /** * create serializer * * @param url * @param output * @return serializer * @throws IOException */ @Adaptive ObjectOutput serialize(URL url, OutputStream output) throws IOException; /** * create deserializer * * @param url * @param input * @return deserializer * @throws IOException */ @Adaptive ObjectInput deserialize(URL url, InputStream input) throws IOException;&#125; Serialization即序列号接口，其中最重要的两个方法是serialize和deserialize，分别是序列化和反序列化，这两个方法会在netty服务端返回方法执行结果和netty客户端接收返回结果的时候调用，先来看下实现类有多少：1234567CompactedJavaSerialization (com.alibaba.dubbo.common.serialize.support.java) DubboSerialization (com.alibaba.dubbo.common.serialize.support.dubbo) FastJsonSerialization (com.alibaba.dubbo.common.serialize.support.json) Hessian2Serialization (com.alibaba.dubbo.common.serialize.support.hessian) JavaSerialization (com.alibaba.dubbo.common.serialize.support.java) JsonSerialization (com.alibaba.dubbo.common.serialize.support.json) NativeJavaSerialization (com.alibaba.dubbo.common.serialize.support.nativejava) 共有7个序列化的实现类，通常这里也是个面试题，会问dubbo有几种序列化的方法，通过SPI注解可以得知，默认的序列化方法是Hessian2Serialization：123456789101112131415161718192021public class Hessian2Serialization implements Serialization &#123; public static final byte ID = 2; public byte getContentTypeId() &#123; return ID; &#125; public String getContentType() &#123; return &quot;x-application/hessian2&quot;; &#125; public ObjectOutput serialize(URL url, OutputStream out) throws IOException &#123; return new Hessian2ObjectOutput(out); &#125; public ObjectInput deserialize(URL url, InputStream is) throws IOException &#123; return new Hessian2ObjectInput(is); &#125;&#125; 观察到这个类有个ID属性：public static final byte ID = 2;再观察其他的实现类，发现每个类都有不同的ID，其实这个是dubbo服务端与客户端约定的序列化方法的编号，这个编号会存放在请求的header中，当客户端需要反序列化时，需要从header中取到这个ID，从而知道服务端是使用了哪种序列化的方式]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《dubbo源码深度解析》之]]></title>
    <url>%2F2018%2F05%2F16%2Fdubbo-%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《dubbo源码深度解析》之transport 网络传输层]]></title>
    <url>%2F2018%2F05%2F15%2Fdubbo-transport%2F</url>
    <content type="text"><![CDATA[transport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec Transporter12345678910111213141516171819202122232425262728@SPI(&quot;netty&quot;)public interface Transporter &#123; /** * Bind a server. * * @param url server url * @param handler * @return server * @throws RemotingException * @see com.alibaba.dubbo.remoting.Transporters#bind(URL, Receiver, ChannelHandler) */ @Adaptive(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;) Server bind(URL url, ChannelHandler handler) throws RemotingException; /** * Connect to a server. * * @param url server url * @param handler * @return client * @throws RemotingException * @see com.alibaba.dubbo.remoting.Transporters#connect(URL, Receiver, ChannelListener) */ @Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;) Client connect(URL url, ChannelHandler handler) throws RemotingException;&#125; 这个接口和Exchange非常像，甚至连接口和接口里面的参数都差不多，其实Exchange本身就是对Transporter进一步的封装，真正干活的，是这个Transporter，我们来看下这个接口的实现类：123GrizzlyTransporter (com.alibaba.dubbo.remoting.transport.grizzly) MinaTransporter (com.alibaba.dubbo.remoting.transport.mina) NettyTransporter (com.alibaba.dubbo.remoting.transport.netty) 可以看到dubbo底层支持Grizzly、Mina、Netty作为网络传输层，默认使用的是netty，我们来看下NettyTransporter的代码：12345678910111213public class NettyTransporter implements Transporter &#123; public static final String NAME = &quot;netty&quot;; public Server bind(URL url, ChannelHandler listener) throws RemotingException &#123; return new NettyServer(url, listener); &#125; public Client connect(URL url, ChannelHandler listener) throws RemotingException &#123; return new NettyClient(url, listener); &#125;&#125; bind先来看bind方法，返回的是一个NettyServer，在这个类中有个非常眼熟的方法：doOpen：123456789101112131415161718192021222324252627282930@Overrideprotected void doOpen() throws Throwable &#123; NettyHelper.setNettyLoggerFactory(); ExecutorService boss = Executors.newCachedThreadPool(new NamedThreadFactory(&quot;NettyServerBoss&quot;, true)); ExecutorService worker = Executors.newCachedThreadPool(new NamedThreadFactory(&quot;NettyServerWorker&quot;, true)); ChannelFactory channelFactory = new NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS)); bootstrap = new ServerBootstrap(channelFactory); final NettyHandler nettyHandler = new NettyHandler(getUrl(), this); channels = nettyHandler.getChannels(); // https://issues.jboss.org/browse/NETTY-365 // https://issues.jboss.org/browse/NETTY-379 // final Timer timer = new HashedWheelTimer(new NamedThreadFactory(&quot;NettyIdleTimer&quot;, true)); bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123; public ChannelPipeline getPipeline() &#123; NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this); ChannelPipeline pipeline = Channels.pipeline(); /*int idleTimeout = getIdleTimeout(); if (idleTimeout &gt; 10000) &#123; pipeline.addLast(&quot;timer&quot;, new IdleStateHandler(timer, idleTimeout / 1000, 0, 0)); &#125;*/ pipeline.addLast(&quot;decoder&quot;, adapter.getDecoder()); pipeline.addLast(&quot;encoder&quot;, adapter.getEncoder()); pipeline.addLast(&quot;handler&quot;, nettyHandler); return pipeline; &#125; &#125;); // bind channel = bootstrap.bind(getBindAddress());&#125; 可以看到这里几乎都是netty的代码，我们先来看下duOpen方法在什么时候被调用，再来看doOpen方法中的几个关键的对象，可以看到NettyServer继承了AbstractServer，在这个父类的构造方法中，调用了doOpen方法：12345678910111213141516171819202122public AbstractServer(URL url, ChannelHandler handler) throws RemotingException &#123; super(url, handler); localAddress = getUrl().toInetSocketAddress(); String host = url.getParameter(Constants.ANYHOST_KEY, false) || NetUtils.isInvalidLocalHost(getUrl().getHost()) ? NetUtils.ANYHOST : getUrl().getHost(); bindAddress = new InetSocketAddress(host, getUrl().getPort()); this.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS); this.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT); try &#123; doOpen(); if (logger.isInfoEnabled()) &#123; logger.info(&quot;Start &quot; + getClass().getSimpleName() + &quot; bind &quot; + getBindAddress() + &quot;, export &quot; + getLocalAddress()); &#125; &#125; catch (Throwable t) &#123; throw new RemotingException(url.toInetSocketAddress(), null, &quot;Failed to bind &quot; + getClass().getSimpleName() + &quot; on &quot; + getLocalAddress() + &quot;, cause: &quot; + t.getMessage(), t); &#125; //fixme replace this with better method DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension(); executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));&#125; 现在再来看doOpen方法中的几个关键对象，第一个就是nettyHandler这个对象，可以看到这个对象是通过new NettyHandler(getUrl(), this)产生的，来看下代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344public class NettyHandler extends SimpleChannelHandler &#123; private final Map&lt;String, Channel&gt; channels = new ConcurrentHashMap&lt;String, Channel&gt;(); // &lt;ip:port, channel&gt; private final URL url; private final ChannelHandler handler; public NettyHandler(URL url, ChannelHandler handler) &#123; if (url == null) &#123; throw new IllegalArgumentException(&quot;url == null&quot;); &#125; if (handler == null) &#123; throw new IllegalArgumentException(&quot;handler == null&quot;); &#125; this.url = url; this.handler = handler; &#125; //省略部分方法 @Override public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123; NettyChannel channel = NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler); try &#123; handler.received(channel, e.getMessage()); &#125; finally &#123; NettyChannel.removeChannelIfDisconnected(ctx.getChannel()); &#125; &#125; @Override public void writeRequested(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123; super.writeRequested(ctx, e); NettyChannel channel = NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler); try &#123; handler.sent(channel, e.getMessage()); &#125; finally &#123; NettyChannel.removeChannelIfDisconnected(ctx.getChannel()); &#125; &#125; //省略部分方法&#125; 这个对象继承SimpleChannelHandler，这里是netty的内容，不再赘述，倒是我们观察到，这个类的每个方法体，都是调用了handler的对应方法进行处理，那这个handler是什么东西呢？其实这个handler就是在DubboProtol中定义的，通过层层的参数传递，传到了NettyServer的父类AbstractPeer中，AbstractPeer也实现了ChannelHandler方法。 第二个关键的对象，是netty的编码器和解码器，dubbo为了避免粘包和拆包问题，自己定义了一套编解码规则，这部分的内容，将在讲解dubbo编解码时说明 connect再来看Transporter的connect方法，还是以NettyTransporter为例，NettyTransporter的connect方法中new了一个NettyClient，NettyClient的doOpen方法几乎也是netty的代码，关键对象也和NettyServer一致，因此这里不再说明，倒是NettyClient在doOpen之后，还进行了一次connect操作，连上netty服务端：123456789101112protected void doConnect() throws Throwable &#123; ChannelFuture future = bootstrap.connect(getConnectAddress()); try &#123; Channel newChannel = future.getChannel(); newChannel.setInterestOps(Channel.OP_READ_WRITE); NettyClient.this.channel = newChannel; &#125; finally &#123; if (!isConnected()) &#123; future.cancel(); &#125; &#125;&#125; 代码做了精简，但最终其实就是将从netty中获取的channel赋值到NettyClient的成员变量channel中，以供后续的消息发送使用，消息发送，也是NettyClient关键的一个部分，也是在讲解Exchange中遗留的问题，在NettyClient的父类AbstractClient中，有个send方法：1234567891011public void send(Object message, boolean sent) throws RemotingException &#123; if (send_reconnect &amp;&amp; !isConnected()) &#123; connect(); &#125; Channel channel = getChannel(); //TODO getChannel返回的状态是否包含null需要改进 if (channel == null || !channel.isConnected()) &#123; throw new RemotingException(this, &quot;message can not send, because channel is closed . url:&quot; + getUrl()); &#125; channel.send(message, sent);&#125; 这里调用了getChannel();方法，其实返回的，就是刚刚讲的channel对象，通过这个对象，可以请求netty发送数据给服务端。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《dubbo源码深度解析》之exchange 信息交换层]]></title>
    <url>%2F2018%2F05%2F11%2Fdubbo-exchange%2F</url>
    <content type="text"><![CDATA[exchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer Exchanger123456789101112131415161718192021222324@SPI(HeaderExchanger.NAME)public interface Exchanger &#123; /** * bind. * * @param url * @param handler * @return message server */ @Adaptive(&#123;Constants.EXCHANGER_KEY&#125;) ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException; /** * connect. * * @param url * @param handler * @return message channel */ @Adaptive(&#123;Constants.EXCHANGER_KEY&#125;) ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException;&#125; Exchanger接口就两个方法，其中bind方法针对服务端，connect方法针对客户端，bind方法和connect方法都有一个参数：ExchangeHandler，我们来看下这个类： ExchangeHandler12345678910111213public interface ExchangeHandler extends ChannelHandler, TelnetHandler &#123; /** * reply. * * @param channel * @param request * @return response * @throws RemotingException */ Object reply(ExchangeChannel channel, Object request) throws RemotingException;&#125; 只有一个方法，在Protocol层的DubboProtocol中有一个内部类实现了这个接口，当时在文中也有强调它的重要性，接着看ChannelHandler ChannelHandler123456789101112131415161718192021222324252627282930313233343536373839404142@SPIpublic interface ChannelHandler &#123; /** * on channel connected. * * @param channel channel. */ void connected(Channel channel) throws RemotingException; /** * on channel disconnected. * * @param channel channel. */ void disconnected(Channel channel) throws RemotingException; /** * on message sent. * * @param channel channel. * @param message message. */ void sent(Channel channel, Object message) throws RemotingException; /** * on message received. * * @param channel channel. * @param message message. */ void received(Channel channel, Object message) throws RemotingException; /** * on exception caught. * * @param channel channel. * @param exception exception. */ void caught(Channel channel, Throwable exception) throws RemotingException;&#125; 乍看之下，这里的接口非常像netty的接口，实际上dubbo也是借鉴了netty的设计思路，这五个接口，将在收到netty消息的时候被调用。 ExchangeClient123public interface ExchangeClient extends Client, ExchangeChannel &#123;&#125; ExchangeClient封装了发送数据的方法，这个接口的父接口比较多，为了不占篇幅，这里不再贴父接口的代码，同学们可以自行查看，其中最重要的两个方法，是send和request。ExchangeClient的实现类比较少，我们来看下HeaderExchangeClient这个实现类的request方法：123public ResponseFuture request(Object request) throws RemotingException &#123; return channel.request(request);&#125; 这里的channel是HeaderExchangeChannel的对象，在HeaderExchangeClient这个类的构造方法中初始化了这个对象，这个类实现了ExchangeChannel接口，因此也有request方法，我们再来看下这个类的request方法：123456789101112131415public ResponseFuture request(Object request, int timeout) throws RemotingException &#123; // create request. Request req = new Request(); req.setVersion(&quot;2.0.0&quot;); req.setTwoWay(true); req.setData(request); DefaultFuture future = new DefaultFuture(channel, req, timeout); try &#123; channel.send(req); &#125; catch (RemotingException e) &#123; future.cancel(); throw e; &#125; return future;&#125; 这里构造了一个Request对象，这个对象中包含了所有与方法调用相关的信息，如方法名、方法参数等，通过channel.send(req)方法发送出去，这里是channel是NettyClient，这也是个非常关键的对象，具体的细节，将在下一节Tranport层进行说明]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《dubbo源码深度解析》之protocol 远程调用层]]></title>
    <url>%2F2018%2F05%2F08%2Fdubbo-protocol%2F</url>
    <content type="text"><![CDATA[protocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter Protocol123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@SPI(&quot;dubbo&quot;)public interface Protocol &#123; /** * 获取缺省端口，当用户没有配置端口时使用。 * * @return 缺省端口 */ int getDefaultPort(); /** * 暴露远程服务：&lt;br&gt; * 1. 协议在接收请求时，应记录请求来源方地址信息：RpcContext.getContext().setRemoteAddress();&lt;br&gt; * 2. export()必须是幂等的，也就是暴露同一个URL的Invoker两次，和暴露一次没有区别。&lt;br&gt; * 3. export()传入的Invoker由框架实现并传入，协议不需要关心。&lt;br&gt; * * @param &lt;T&gt; 服务的类型 * @param invoker 服务的执行体 * @return exporter 暴露服务的引用，用于取消暴露 * @throws RpcException 当暴露服务出错时抛出，比如端口已占用 */ @Adaptive &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException; /** * 引用远程服务：&lt;br&gt; * 1. 当用户调用refer()所返回的Invoker对象的invoke()方法时，协议需相应执行同URL远端export()传入的Invoker对象的invoke()方法。&lt;br&gt; * 2. refer()返回的Invoker由协议实现，协议通常需要在此Invoker中发送远程请求。&lt;br&gt; * 3. 当url中有设置check=false时，连接失败不能抛出异常，并内部自动恢复。&lt;br&gt; * * @param &lt;T&gt; 服务的类型 * @param type 服务的类型 * @param url 远程服务的URL地址 * @return invoker 服务的本地代理 * @throws RpcException 当连接服务提供方失败时抛出 */ @Adaptive &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException; /** * 释放协议：&lt;br&gt; * 1. 取消该协议所有已经暴露和引用的服务。&lt;br&gt; * 2. 释放协议所占用的所有资源，比如连接和端口。&lt;br&gt; * 3. 协议在释放后，依然能暴露和引用新的服务。&lt;br&gt; */ void destroy();&#125; 其中，最主要的两个方法是export和refer，export针对服务端，将Invoker暴露为Exporter，refer方法针对客户端，通过从注册中心获取的url和接口类型，获得到Invoker，通过SPI注解的key可知，默认的实现类是DubboProtocol，先来看下DubboProtocol的export方法：1234567891011public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; URL url = invoker.getUrl(); // export service. String key = serviceKey(url); DubboExporter&lt;T&gt; exporter = new DubboExporter&lt;T&gt;(invoker, key, exporterMap); exporterMap.put(key, exporter); //省略代码 openServer(url); return exporter;&#125; 可以看到暴露的逻辑其实非常简单，从url中抽取出关键参数组装为一个key，如官方demo中的DemoService的key就是com.alibaba.dubbo.demo.DemoService:20880，然后new一个DubboExporter，存入exporterMap中，就完成了暴露，后续在接收到客户端请求时，也是从exporterMap这个对象中查找Exporter，从而进行方法的调用。 但似乎暴露的逻辑没有那么简单，最后还有一行代码：openServer(url);123456789101112131415private void openServer(URL url) &#123; // find server. String key = url.getAddress(); //client 也可以暴露一个只有server可以调用的服务。 boolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true); if (isServer) &#123; ExchangeServer server = serverMap.get(key); if (server == null) &#123; serverMap.put(key, createServer(url)); &#125; else &#123; //server支持reset,配合override功能使用 server.reset(url); &#125; &#125;&#125; 这里有个关键对象serverMap，key是url的地址，如：192.168.252.169:20880，如果serverMap中没有这个key，则调用createServer方法：123456789101112private ExchangeServer createServer(URL url) &#123; //默认开启server关闭时发送readonly事件 url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString()); //默认开启heartbeat url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT)); String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER); url = url.addParameter(Constants.CODEC_KEY, Version.isCompatibleVersion() ? COMPATIBLE_CODEC_NAME : DubboCodec.NAME); ExchangeServer server; server = Exchangers.bind(url, requestHandler); //省略代码 return server;&#125; 其中Exchangers.bind方法将会打开netty端口，这一部分留到Exchangers层进行说明，这里还有一个关键的对象，就是传给Exchangers.bind方法的ExchangeHandler对象，这个对象定义在了DubboProtol类中：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private ExchangeHandler requestHandler = new ExchangeHandlerAdapter() &#123; public Object reply(ExchangeChannel channel, Object message) throws RemotingException &#123; if (message instanceof Invocation) &#123; Invocation inv = (Invocation) message; Invoker&lt;?&gt; invoker = getInvoker(channel, inv); //如果是callback 需要处理高版本调用低版本的问题 if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123; String methodsStr = invoker.getUrl().getParameters().get(&quot;methods&quot;); boolean hasMethod = false; if (methodsStr == null || methodsStr.indexOf(&quot;,&quot;) == -1) &#123; hasMethod = inv.getMethodName().equals(methodsStr); &#125; else &#123; String[] methods = methodsStr.split(&quot;,&quot;); for (String method : methods) &#123; if (inv.getMethodName().equals(method)) &#123; hasMethod = true; break; &#125; &#125; &#125; if (!hasMethod) &#123; logger.warn(new IllegalStateException(&quot;The methodName &quot; + inv.getMethodName() + &quot; not found in callback service interface ,invoke will be ignored. please update the api interface. url is:&quot; + invoker.getUrl()) + &quot; ,invocation is :&quot; + inv); return null; &#125; &#125; RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress()); return invoker.invoke(inv); &#125; throw new RemotingException(channel, &quot;Unsupported request: &quot; + message == null ? null : (message.getClass().getName() + &quot;: &quot; + message) + &quot;, channel: consumer: &quot; + channel.getRemoteAddress() + &quot; --&gt; provider: &quot; + channel.getLocalAddress()); &#125; @Override public void received(Channel channel, Object message) throws RemotingException &#123; if (message instanceof Invocation) &#123; reply((ExchangeChannel) channel, message); &#125; else &#123; super.received(channel, message); &#125; &#125; @Override public void connected(Channel channel) throws RemotingException &#123; invoke(channel, Constants.ON_CONNECT_KEY); &#125; @Override public void disconnected(Channel channel) throws RemotingException &#123; if (logger.isInfoEnabled()) &#123; logger.info(&quot;disconected from &quot; + channel.getRemoteAddress() + &quot;,url:&quot; + channel.getUrl()); &#125; invoke(channel, Constants.ON_DISCONNECT_KEY); &#125; private void invoke(Channel channel, String methodKey) &#123; Invocation invocation = createInvocation(channel, channel.getUrl(), methodKey); if (invocation != null) &#123; try &#123; received(channel, invocation); &#125; catch (Throwable t) &#123; logger.warn(&quot;Failed to invoke event method &quot; + invocation.getMethodName() + &quot;(), cause: &quot; + t.getMessage(), t); &#125; &#125; &#125; private Invocation createInvocation(Channel channel, URL url, String methodKey) &#123; String method = url.getParameter(methodKey); if (method == null || method.length() == 0) &#123; return null; &#125; RpcInvocation invocation = new RpcInvocation(method, new Class&lt;?&gt;[0], new Object[0]); invocation.setAttachment(Constants.PATH_KEY, url.getPath()); invocation.setAttachment(Constants.GROUP_KEY, url.getParameter(Constants.GROUP_KEY)); invocation.setAttachment(Constants.INTERFACE_KEY, url.getParameter(Constants.INTERFACE_KEY)); invocation.setAttachment(Constants.VERSION_KEY, url.getParameter(Constants.VERSION_KEY)); if (url.getParameter(Constants.STUB_EVENT_KEY, false)) &#123; invocation.setAttachment(Constants.STUB_EVENT_KEY, Boolean.TRUE.toString()); &#125; return invocation; &#125; &#125;; 这个对象非常的重要，在后续netty收到客户端发来的请求时，会回调这个对象中的方法，从而进行方法的调用，具体细节将留到后续讲解服务发布、服务调用的流程时来说明。 再来看下refer方法：123456public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; serviceType, URL url) throws RpcException &#123; // create rpc invoker. DubboInvoker&lt;T&gt; invoker = new DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers); invokers.add(invoker); return invoker;&#125; 这个方法本身非常简单，通过接口类型、url即可组装一个DubboInvoker对象，因此这里本身没什么好讲，倒是生成的DubboInvoker这个对象的doInvoke方法值得深究：12345678910111213141516171819@Overrideprotected Result doInvoke(final Invocation invocation) throws Throwable &#123; boolean isAsync = RpcUtils.isAsync(getUrl(), invocation); boolean isOneway = RpcUtils.isOneway(getUrl(), invocation); int timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT); if (isOneway) &#123; boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false); currentClient.send(inv, isSent); RpcContext.getContext().setFuture(null); return new RpcResult(); &#125; else if (isAsync) &#123; ResponseFuture future = currentClient.request(inv, timeout); RpcContext.getContext().setFuture(new FutureAdapter&lt;Object&gt;(future)); return new RpcResult(); &#125; else &#123; RpcContext.getContext().setFuture(null); return (Result) currentClient.request(inv, timeout).get(); &#125;&#125; 这里可以看到三种方法调用的逻辑，分别是：同步调用、异步调用、同步转异步，默认是第三种。但无论是哪种，最终调用的都是ExchangeClient对象的send或request方法，ExchangeClient的具体细节，将在下一节Exchange层进行说明。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《dubbo源码深度解析》之monitor 监控层]]></title>
    <url>%2F2018%2F05%2F05%2Fdubbo-monitor%2F</url>
    <content type="text"><![CDATA[monitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService MonitorService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public interface MonitorService &#123; String APPLICATION = &quot;application&quot;; String INTERFACE = &quot;interface&quot;; String METHOD = &quot;method&quot;; String GROUP = &quot;group&quot;; String VERSION = &quot;version&quot;; String CONSUMER = &quot;consumer&quot;; String PROVIDER = &quot;provider&quot;; String TIMESTAMP = &quot;timestamp&quot;; String SUCCESS = &quot;success&quot;; String FAILURE = &quot;failure&quot;; String INPUT = Constants.INPUT_KEY; String OUTPUT = Constants.OUTPUT_KEY; String ELAPSED = &quot;elapsed&quot;; String CONCURRENT = &quot;concurrent&quot;; String MAX_INPUT = &quot;max.input&quot;; String MAX_OUTPUT = &quot;max.output&quot;; String MAX_ELAPSED = &quot;max.elapsed&quot;; String MAX_CONCURRENT = &quot;max.concurrent&quot;; /** * 监控数据采集. * 1. 支持调用次数统计：count://host/interface?application=foo&amp;method=foo&amp;provider=10.20.153.11:20880&amp;success=12&amp;failure=2&amp;elapsed=135423423 * 1.1 host,application,interface,group,version,method 记录监控来源主机，应用，接口，方法信息。 * 1.2 如果是消费者发送的数据，加上provider地址参数，反之，加上来源consumer地址参数。 * 1.3 success,faulure,elapsed 记录距上次采集，调用的成功次数，失败次数，成功调用总耗时，平均时间将用总耗时除以成功次数。 * * @param statistics */ void collect(URL statistics); /** * 监控数据查询. * 1. 支持按天查询：count://host/interface?application=foo&amp;method=foo&amp;side=provider&amp;view=chart&amp;date=2012-07-03 * 1.1 host,application,interface,group,version,method 查询主机，应用，接口，方法的匹配条件，缺失的条件的表示全部，host用0.0.0.0表示全部。 * 1.2 side=consumer,provider 查询由调用的哪一端采集的数据，缺省为都查询。 * 1.3 缺省为view=summary，返回全天汇总信息，支持view=chart表示返回全天趋势图表图片的URL地址，可以进接嵌入其它系统的页面上展示。 * 1.4 date=2012-07-03 指定查询数据的日期，缺省为当天。 * * @param query * @return statistics */ List&lt;URL&gt; lookup(URL query);&#125; monitor的架构跟其他的有些区别，Monitor是一个独立的监控系统，其本身也是个dubbo服务提供者，我们这里不去探究这个监控系统的源码，但我们可以猜测，那边也有一个类实现了MonitorService，并且那里的collect方法，才是真正实现监控日志收集整理的地方。但我们发现本地也有个collect方法，先看代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445public void collect(URL url) &#123; // 读写统计变量 int success = url.getParameter(MonitorService.SUCCESS, 0); int failure = url.getParameter(MonitorService.FAILURE, 0); int input = url.getParameter(MonitorService.INPUT, 0); int output = url.getParameter(MonitorService.OUTPUT, 0); int elapsed = url.getParameter(MonitorService.ELAPSED, 0); int concurrent = url.getParameter(MonitorService.CONCURRENT, 0); // 初始化原子引用 Statistics statistics = new Statistics(url); AtomicReference&lt;long[]&gt; reference = statisticsMap.get(statistics); if (reference == null) &#123; statisticsMap.putIfAbsent(statistics, new AtomicReference&lt;long[]&gt;()); reference = statisticsMap.get(statistics); &#125; // CompareAndSet并发加入统计数据 long[] current; long[] update = new long[LENGTH]; do &#123; current = reference.get(); if (current == null) &#123; update[0] = success; update[1] = failure; update[2] = input; update[3] = output; update[4] = elapsed; update[5] = concurrent; update[6] = input; update[7] = output; update[8] = elapsed; update[9] = concurrent; &#125; else &#123; update[0] = current[0] + success; update[1] = current[1] + failure; update[2] = current[2] + input; update[3] = current[3] + output; update[4] = current[4] + elapsed; update[5] = (current[5] + concurrent) / 2; update[6] = current[6] &gt; input ? current[6] : input; update[7] = current[7] &gt; output ? current[7] : output; update[8] = current[8] &gt; elapsed ? current[8] : elapsed; update[9] = current[9] &gt; concurrent ? current[9] : concurrent; &#125; &#125; while (!reference.compareAndSet(current, update));&#125; 这里有个关键对象：ConcurrentMap]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cglib动态代理解析]]></title>
    <url>%2F2018%2F05%2F02%2Fcglib-proxy%2F</url>
    <content type="text"><![CDATA[简单的例子代码目标类123456public class HelloService &#123; public void sayHello() &#123; System.out.println(&quot;=== hello ===&quot;); &#125;&#125; 拦截器类123456789101112131415import java.lang.reflect.Method;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;public class MyMethodInterceptor implements MethodInterceptor &#123; public Object intercept(Object obj, Method method, Object[] args,MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;=== before ===&quot;); Object object = proxy.invokeSuper(obj, args); System.out.println(&quot;=== after ===&quot;); return object; &#125;&#125; 代理类1234567891011import net.sf.cglib.proxy.Enhancer;public class MyProxy&lt;T&gt; &#123; public T getProxy(Class&lt;T&gt; tClass)&#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(tClass); enhancer.setCallback(new MyMethodInterceptor()); return (T) enhancer.create(); &#125;&#125; 测试类123456789public class Main &#123; public static void main(String[] args) throws Exception &#123; MyProxy&lt;HelloService&gt; myProxy = new MyProxy(); HelloService helloService = myProxy.getProxy(HelloService.class); helloService.sayHello(); &#125;&#125; 执行结果123=== before ====== hello ====== after === 解析不同于jdk动态代理，cglib采用了继承目标类的方式来实现动态代理，因此cglib无法代理final类型的方法，相比比jdk动态代理，产生代理类，需要接口Class对象以及实现类的实例而言，cglib所需要的“原材料”更少，只需要目标类的Class对象即可实现动态代理。 源码解析代码入口就在MyProxy类的enhancer.create()方法，很明显这个方法产生出来的就是目标类的子类，但我们的代码中并没有存在目标类的子类，cglib如何new出来？这里的原理与jdk动态代理类似，都是动态产生字节码技术，不过不同于jdk动态代理直接写二进制文件，cglib底层采用asm框架来产生字节码文件，效率上笔者认为是比jdk动态代理要慢一点，但这不是关键，因为一个代理类的产生，只会经过一次这个步骤，而后成千上万次的方法调用，才是效率的关键。 来看enhancer.create()的具体步骤，经过createHelper()–&gt;super.create(key)–&gt;data.get(this)–&gt;generatedClasses.get(gen)–&gt;createEntry(key, cacheKey, v)–&gt;loader.apply(key)–&gt;gen.generate(ClassLoaderData.this)–&gt;super.generate(data)–&gt;strategy.generate(this)–&gt;transform(cg).generateClass(cw)后到达产生二进制文件的核心Enhancer类的generateClass(ClassVisitor v)方法。 这个方法采用asm动态生成字节码文件，具体如何生成，笔者认为没有必要去看具体的逻辑过程，繁琐且没有营养，我们熟悉asm的话也可以写的出来。反而是这个方法，到底生成了什么东西，值得我们关注。 动态代理类源码我们可以将上一步中取到的byte数组，写入到文件，通过反编译工具查看源码，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.lang.reflect.Method;import net.sf.cglib.core.ReflectUtils;import net.sf.cglib.proxy.Callback;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;//关键点，继承目标类public class HelloService$$EnhancerByCGLIB$$a89dc216 extends HelloService &#123; private boolean CGLIB$BOUND; private static ThreadLocal CGLIB$THREAD_CALLBACKS; private MethodInterceptor CGLIB$CALLBACK_0; private static MethodProxy CGLIB$sayHello$0$Proxy; private static Object[] CGLIB$emptyArgs; static &#123; try &#123; CGLIB$STATICHOOK2(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; static void CGLIB$STATICHOOK2() throws ClassNotFoundException &#123; CGLIB$THREAD_CALLBACKS = new ThreadLocal(); CGLIB$emptyArgs = new Object[0]; Class var0 = Class.forName(&quot;com.example.demo.java_demo.cglib.HelloService$$EnhancerByCGLIB$$a89dc216&quot;); Class var1; Method[] var10000 = ReflectUtils.findMethods(new String[]&#123;&quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;, &quot;hashCode&quot;, &quot;()I&quot;, &quot;clone&quot;, &quot;()Ljava/lang/Object;&quot;&#125;, (var1 = Class.forName(&quot;java.lang.Object&quot;)).getDeclaredMethods()); //关键代码，产生MethodProxy CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;); &#125; //拦截器类将会调用此方法 final void CGLIB$sayHello$0() &#123; super.sayHello(); &#125; //关键方法 public final void sayHello() &#123; MethodInterceptor var10000 = this.CGLIB$CALLBACK_0; if(this.CGLIB$CALLBACK_0 == null) &#123; CGLIB$BIND_CALLBACKS(this); var10000 = this.CGLIB$CALLBACK_0; &#125; if(var10000 != null) &#123; try &#123; //关键方法 var10000.intercept(this, null, CGLIB$emptyArgs, CGLIB$sayHello$0$Proxy); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125; else &#123; super.sayHello(); &#125; &#125; public HelloService$$EnhancerByCGLIB$$a89dc216() &#123; CGLIB$BIND_CALLBACKS(this); &#125; //通过这个方法注入拦截器类 public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123; CGLIB$THREAD_CALLBACKS.set(var0); &#125; //设置拦截器类 private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123; HelloService$$EnhancerByCGLIB$$a89dc216 var1 = (HelloService$$EnhancerByCGLIB$$a89dc216)var0; if(!var1.CGLIB$BOUND) &#123; var1.CGLIB$BOUND = true; Object var10000 = CGLIB$THREAD_CALLBACKS.get(); if(var10000 == null) &#123; return; &#125; var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0]; &#125; &#125;&#125; 这个源码已经做了大量的精简，但看上去仍然比jdk动态代理生成的动态代理类要复杂的多，有了这个动态代理类，我们就可以修改测试类中的代码为：12345678910111213import net.sf.cglib.proxy.Callback;public class Main &#123; public static void main(String[] args) throws Exception &#123; //设置拦截器 HelloService$$EnhancerByCGLIB$$a89dc216.CGLIB$SET_THREAD_CALLBACKS( new Callback[]&#123; new MyMethodInterceptor() &#125; ); //创建实例 HelloService helloService = new HelloService$$EnhancerByCGLIB$$a89dc216(); //调用方法 helloService.sayHello(); &#125;&#125; 先来看第一步设置拦截器，传入的拦截器将在稍后被设置到成员变量CGLIB$CALLBACK_0中，这个属性会在方法调用时发挥作用 123public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123; CGLIB$THREAD_CALLBACKS.set(var0);&#125; 1234567891011private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123; HelloService$$EnhancerByCGLIB$$a89dc216 var1 = (HelloService$$EnhancerByCGLIB$$a89dc216)var0; if(!var1.CGLIB$BOUND) &#123; var1.CGLIB$BOUND = true; Object var10000 = CGLIB$THREAD_CALLBACKS.get(); if(var10000 == null) &#123; return; &#125; var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0]; &#125; &#125; 第二步创建实例，这里有一行非常关键的代码：1CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;); 这个代码可以先忽略，等到方法执行时再看 第三步方法调用，即调用动态代理类的sayHello()方法，进而调用拦截器类的intercept方法，传入的4个参数分别为：1、动态代理类的对象本身 2、通过反射获得的method对象 3、方法参数 4、方法代理对象（关键）1var10000.intercept(this, null, CGLIB$emptyArgs, CGLIB$sayHello$0$Proxy); 代码跳到拦截器类的intercept方法中123456public Object intercept(Object obj, Method method, Object[] args,MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;=== before ===&quot;); Object object = proxy.invokeSuper(obj, args); System.out.println(&quot;=== after ===&quot;); return object;&#125; 在jdk动态代理中，也有类似的方法，但在jdk动态代理在执行目标方法时，是通过反射调用，我们知道反射调用比直接调用，效率上是要低的多，而cglib实现了自己的一套反射调用，查看MethodProxy类的init方法：12345678910private void init()&#123; CreateInfo ci = createInfo; FastClassInfo fci = new FastClassInfo(); fci.f1 = helper(ci, ci.c1); fci.f2 = helper(ci, ci.c2); fci.i1 = fci.f1.getIndex(sig1); fci.i2 = fci.f2.getIndex(sig2); fastClassInfo = fci; createInfo = null; &#125; 这里的c1，c2，sig1，sig2，即在动态代理类中传入的 1CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;); 这个方法会产生FastClassInfo对象，这个对象有4个属性，f1，f2，i1，i2，其中最主要的是f2和i2，将在稍后的调用中使用到，为了更清晰明了，我们先来看后面的代码：1return fci.f2.invoke(fci.i2, obj, args); 这行代码就是进行了代理类的方法调用，如果此时按F5进入方法，会发现代码跳到了刚刚的动态代理类的CGLIB$sayHello$0()方法，即123final void CGLIB$sayHello$0() &#123; super.sayHello(); &#125; 但f2的invoke方法，为何会调用到动态代理类的CGLIB$sayHello$0方法？这里就要看f2是如何产生的，回头看代码：1fci.f2 = helper(ci, ci.c2); helper()方法会产生一个FastClass对象，这个FastClass对象也是通过动态字节码技术产生的，产生流程跟产生动态代理类一致，通过反编译可以获得源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import com.example.demo.java_demo.cglib.HelloService..EnhancerByCGLIB..a89dc216;import java.lang.reflect.InvocationTargetException;import net.sf.cglib.core.Signature;import net.sf.cglib.proxy.Callback;import net.sf.cglib.reflect.FastClass;public class HelloService$$EnhancerByCGLIB$$a89dc216$$FastClassByCGLIB$$7d6c4fc4 extends FastClass &#123; public HelloService$$EnhancerByCGLIB$$a89dc216$$FastClassByCGLIB$$7d6c4fc4(Class var1) &#123; super(var1); &#125; public int getIndex(Signature var1) &#123; String var10000 = var1.toString(); switch(var10000.hashCode()) &#123; case -2055565910: if(var10000.equals(&quot;CGLIB$SET_THREAD_CALLBACKS([Lnet/sf/cglib/proxy/Callback;)V&quot;)) &#123; return 1; &#125; break; case -1457505897: if(var10000.equals(&quot;CGLIB$STATICHOOK2()V&quot;)) &#123; return 2; &#125; break; case 291273791: if(var10000.equals(&quot;CGLIB$sayHello$0()V&quot;)) &#123; return 3; &#125; break; case 1535311470: if(var10000.equals(&quot;sayHello()V&quot;)) &#123; return 0; &#125; break; &#125; return -1; &#125; public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException &#123; a89dc216 var10000 = (a89dc216)var2; int var10001 = var1; try &#123; switch(var10001) &#123; case 0: var10000.sayHello(); return null; case 1: a89dc216.CGLIB$SET_THREAD_CALLBACKS((Callback[])var3[0]); return null; case 2: a89dc216.CGLIB$STATICHOOK2(); return null; case 3: var10000.CGLIB$sayHello$0(); return null; &#125; &#125; catch (Throwable var4) &#123; throw new InvocationTargetException(var4); &#125; throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;); &#125;&#125; 代码同样做了精简，到这里流程差不多已经走完了，在进行f2的invoke调用时，会传入i1，i1即是通过f2的getinde方法获得的，这里的值为3，在进行invoker调用时，可以看到最终调用的是动态代理类的CGLIB$sayHello$0()方法，CGLIB$sayHello$0()方法的方法体在刚刚已经展示过，就一行代码:123final void CGLIB$sayHello$0() &#123; super.sayHello(); &#125; 至此，完成了cglib动态调用的过程完！]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《dubbo源码深度解析》之cluster 路由层]]></title>
    <url>%2F2018%2F05%2F01%2Fdubbo-cluster%2F</url>
    <content type="text"><![CDATA[cluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance Cluster123456789101112131415@SPI(FailoverCluster.NAME)public interface Cluster &#123; /** * Merge the directory invokers to a virtual invoker. * * @param &lt;T&gt; * @param directory * @return cluster invoker * @throws RpcException */ @Adaptive &lt;T&gt; Invoker&lt;T&gt; join(Directory&lt;T&gt; directory) throws RpcException;&#125; Cluster接口中就一个方法，接收一个Directory的参数，返回一个Invoker对象，Directory是多个Invoker的集合，也就是说Cluster的主要作用就是将多个Invoker伪装成一个Invoker，以供后续做负载均衡、集群容错、路由规则等功能提供条件。 我们来看下Cluster的实现类：123456789AvailableCluster (com.alibaba.dubbo.rpc.cluster.support) BroadcastCluster (com.alibaba.dubbo.rpc.cluster.support) FailbackCluster (com.alibaba.dubbo.rpc.cluster.support) FailfastCluster (com.alibaba.dubbo.rpc.cluster.support) FailoverCluster (com.alibaba.dubbo.rpc.cluster.support) FailsafeCluster (com.alibaba.dubbo.rpc.cluster.support) ForkingCluster (com.alibaba.dubbo.rpc.cluster.support) MergeableCluster (com.alibaba.dubbo.rpc.cluster.support) MockClusterWrapper (com.alibaba.dubbo.rpc.cluster.support.wrapper) 其中，默认的实现类是FailoverCluster，也就是自动重试的策略，常用的还有FailfastCluster：快速失败策略，通常用于非幂等性的操作，如写操作，在一次执行失败后就立即报失败，不会进行重试。MergeableCluster：结果合并策略。BroadcastCluster：广播策略等。 Directory1234567891011121314151617public interface Directory&lt;T&gt; extends Node &#123; /** * get service type. * * @return service type. */ Class&lt;T&gt; getInterface(); /** * list invokers. * * @return invokers */ List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) throws RpcException;&#125; Directory接口就两个方法，其中getInterface方法比较简单，就是返回该Invoker的接口类型，虽然Directory是多个Invoker的集合，但并不会有多个接口类型，因为这些不同的Invoker都是同一个接口在不同机器上的Invoker。 我们来看下Directory的实现类：123AbstractDirectory (com.alibaba.dubbo.rpc.cluster.directory) RegistryDirectory (com.alibaba.dubbo.registry.integration) StaticDirectory (com.alibaba.dubbo.rpc.cluster.directory) 其中AbstractDirectory是公共的抽象父类，StaticDirectory又非常少用，我们就以RegistryDirectory为例，在看RegistryDirectory的代码之前，先看下他父类AbstractDirectory的list方法：12345678910111213141516171819public List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) throws RpcException &#123; if (destroyed) &#123; throw new RpcException(&quot;Directory already destroyed .url: &quot; + getUrl()); &#125; List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation); List&lt;Router&gt; localRouters = this.routers; // local reference if (localRouters != null &amp;&amp; localRouters.size() &gt; 0) &#123; for (Router router : localRouters) &#123; try &#123; if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, true)) &#123; invokers = router.route(invokers, getConsumerUrl(), invocation); &#125; &#125; catch (Throwable t) &#123; logger.error(&quot;Failed to execute router: &quot; + getUrl() + &quot;, cause: &quot; + t.getMessage(), t); &#125; &#125; &#125; return invokers; &#125; 可以看到在获取Invoker列表时，调用的是子类的doList方法，然后进行路由选择操作，Router是在Cluster这一层中的主要概念之一，后面会讲到，先来看子类的doList方法：12345678910111213141516171819202122232425public List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) &#123; List&lt;Invoker&lt;T&gt;&gt; invokers = null; Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; localMethodInvokerMap = this.methodInvokerMap; // local reference if (localMethodInvokerMap != null &amp;&amp; localMethodInvokerMap.size() &gt; 0) &#123; String methodName = RpcUtils.getMethodName(invocation); Object[] args = RpcUtils.getArguments(invocation); if (args != null &amp;&amp; args.length &gt; 0 &amp;&amp; args[0] != null &amp;&amp; (args[0] instanceof String || args[0].getClass().isEnum())) &#123; invokers = localMethodInvokerMap.get(methodName + &quot;.&quot; + args[0]); // 可根据第一个参数枚举路由 &#125; if (invokers == null) &#123; invokers = localMethodInvokerMap.get(methodName); &#125; if (invokers == null) &#123; invokers = localMethodInvokerMap.get(Constants.ANY_VALUE); &#125; if (invokers == null) &#123; Iterator&lt;List&lt;Invoker&lt;T&gt;&gt;&gt; iterator = localMethodInvokerMap.values().iterator(); if (iterator.hasNext()) &#123; invokers = iterator.next(); &#125; &#125; &#125; return invokers == null ? new ArrayList&lt;Invoker&lt;T&gt;&gt;(0) : invokers;&#125; 这段代码中有个关键对象：methodInvokerMap，这是个Map]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jdk动态代理解析]]></title>
    <url>%2F2018%2F04%2F28%2Fjdk-proxy%2F</url>
    <content type="text"><![CDATA[简单的例子代码接口类123public interface HelloService &#123; void sayHello();&#125; 实现类123456public class HelloServiceImpl implements HelloService &#123; public void sayHello() &#123; System.out.println(&quot;hello&quot;); &#125;&#125; 代理类1234567891011121314151617181920212223242526272829import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class MyProxy &lt;T&gt;&#123; private Object target; private Class interfaceClass; public MyProxy(Object target,Class interfaceClass) &#123; super(); this.target = target; this.interfaceClass = interfaceClass; &#125; public T getProxy() &#123; return (T)Proxy.newProxyInstance(interfaceClass.getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;=== begin ===&quot;); Object result = method.invoke(target,args); System.out.println(&quot;=== end ===&quot;); return result; &#125; &#125;); &#125;&#125; 测试类123456789101112public class Main &#123; public static void main(String[] args) throws Throwable &#123; new Main().testProxy(); &#125; public void testProxy() throws Throwable &#123; HelloService userService = new HelloServiceImpl(); MyProxy&lt;HelloService&gt; myProxy = new MyProxy(userService,HelloService.class); HelloService proxy = myProxy.getProxy(); proxy.sayHello(); &#125;&#125; 运行结果123=== begin ===hello=== end === 解析关键代码在讲核心代码前先插播一个内容：ClassLoader，可以看到在匿名内部类中，有个interfaceClass.getClassLoader()的操作，interfaceClass是个Class对象，在new MyProxy是传入，唯一的作用就是获得这个对象的ClassLoader，这是由于ClassLoader的机制导致的，由不同ClassLoader加载的类，即便已经实现了目标接口的方法，也不会被认为是这个目标接口的子类，因此需要用同一个ClassLoader，才能使最终生成的代理对象，能够被强制转换成接口对象，更详细的内容请参考双亲委派模型。 接下来开始讲核心代码：1Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 这行代码将会产生一个代理类，这个类实现了HelloService的所有方法，在方法体重，调用第三个参数h，这个h即为我们上面代码中的匿名内部类123456789new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;=== begin ===&quot;); Object result = method.invoke(target,args); System.out.println(&quot;=== end ===&quot;); return result; &#125;&#125; 源码解析先来看newProxyInstance()这个方法，以下源码摘自jdk1.8，源码做了大量精简，仅保留核心代码。123456789public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)throws IllegalArgumentException &#123; //获取代理类的Class对象 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); //获取代理类的构造方法 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); //生成实例 return cons.newInstance(new Object[]&#123;h&#125;); &#125; getProxyClass0()方法也就是动态代理核心，经过各种缓存机制判断后，我们可以找到真正干活的那个方法，即ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags)，这个方法中，又调用了ProxyGenerator类的generateClassFile()方法，这个方法就是产生Class二进制文件的地方： 1234567891011121314151617181920212223private byte[] generateClassFile() &#123; this.addProxyMethod(hashCodeMethod, Object.class); this.addProxyMethod(equalsMethod, Object.class); this.addProxyMethod(toStringMethod, Object.class); //...省略代码 ByteArrayOutputStream var13 = new ByteArrayOutputStream(); DataOutputStream var14 = new DataOutputStream(var13); try &#123; var14.writeInt(-889275714); var14.writeShort(0); var14.writeShort(49); this.cp.write(var14); var14.writeShort(this.accessFlags); var14.writeShort(this.cp.getClass(dotToSlash(this.className))); var14.writeShort(this.cp.getClass(&quot;java/lang/reflect/Proxy&quot;)); var14.writeShort(this.interfaces.length); //...省略代码 return var13.toByteArray(); &#125; catch (IOException var9) &#123; throw new InternalError(&quot;unexpected I/O Exception&quot;, var9); &#125; &#125; 这个方法充斥着大量的逻辑性代码，没有什么值得看的地方，倒是这种生成Class二进制文件的方式是个亮点，笔者在看dubbo源码时，dubbo也会产生类似的动态代理类，但dubbo的方式是先生成java代码，就是 public class XXX这样，然后通过javassist变成Class文件，但jdk动态代理直接省去了生成java代码这一步，直接写二进制文件，显然这能提高效率，这里可以作为面试的一个点。 顺便介绍下Class文件的结构，java的Class文件是严格按照顺序来书写，各个属性之间没有间隔（如之类称之为间隔），通过预定义好的顺序写入和读取Class文件，以保证能够正确的读写，从上面的代码也能看出来 第一行：writeInt(-889275714) -889275714转成十六进制即为CAFEBABY，熟悉Class文件结构的同学都知道这是Java Class文件的标记，任何Class文件都是以这个开头。 第二行：writeShort(0)，即两个字节的0，转为十六进制是00 00，这两个字节目前没有意义，是Class文件中罕见的没有意义的字符 第三行：writeShort(49)，49是jdk的版本，即jdk1.5，即生成的Class文件，能被jdk1.5以上的虚拟机运行 第四行：cp.write(var14)，写入常量池，常量池包括字面量和符号引用，字面量即文本字符串，声明为final的常量，符号引用即类和接口的全限定名，方法、字段的名称和描述符等，在上面的逻辑步骤中已经解析出了所有需要的常量池 第五行：writeShort(this.accessFlags);accessFlags即类的访问标志，这里的值是17，十六进制为11，查表可知这代表 final 和 public两种访问标志。 第六行：常量池写完，后面的所有操作都是写常量池中的编号，而不会再写入具体的名称 Class文件的结构严谨而复杂，有兴趣的同学可以阅读周志明编写的深入理解java虚拟机这一书 我们可以手动调用ProxyGenerator.generateProxyClass(“$Proxy0”, HelloServiceImpl.class.getInterfaces())这个方法，得到二进制数据，将它写入磁盘，然后用反编译工具看下到底写了什么代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package com.sun.proxy;import com.example.demo.java_demo.jdk_proxy.HelloService;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements HelloService&#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; public $Proxy0(InvocationHandler paramInvocationHandler) throws &#123; super(paramInvocationHandler); &#125; public final boolean equals(Object paramObject) throws &#123; try &#123; return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void sayHello() throws &#123; try &#123; this.h.invoke(this, m3, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)this.h.invoke(this, m2, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)this.h.invoke(this, m0, null)).intValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; static &#123; try &#123; m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;); m3 = Class.forName(&quot;com.example.demo.java_demo.jdk_proxy.HelloService&quot;).getMethod(&quot;sayHello&quot;, new Class[0]); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 关键的sayHello方法，其实也是调用了this.h.invoke(this, m2, null);这个h，即我们上面写的那个匿名内部类。 完！]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《dubbo源码深度解析》之registry 注册中心层]]></title>
    <url>%2F2018%2F04%2F26%2Fdubbo-registry%20%2F</url>
    <content type="text"><![CDATA[registry 注册中心层：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService RegistryFactory123456789101112131415161718192021@SPI(&quot;dubbo&quot;)public interface RegistryFactory &#123; /** * 连接注册中心. * &lt;p&gt; * 连接注册中心需处理契约：&lt;br&gt; * 1. 当设置check=false时表示不检查连接，否则在连接不上时抛出异常。&lt;br&gt; * 2. 支持URL上的username:password权限认证。&lt;br&gt; * 3. 支持backup=10.20.153.10备选注册中心集群地址。&lt;br&gt; * 4. 支持file=registry.cache本地磁盘文件缓存。&lt;br&gt; * 5. 支持timeout=1000请求超时设置。&lt;br&gt; * 6. 支持session=60000会话超时或过期设置。&lt;br&gt; * * @param url 注册中心地址，不允许为空 * @return 注册中心引用，总不返回空 */ @Adaptive(&#123;&quot;protocol&quot;&#125;) Registry getRegistry(URL url);&#125; 实现类如下：1234567AbstractRegistryFactory (com.alibaba.dubbo.registry.support) DubboRegistryFactory (com.alibaba.dubbo.registry.dubbo) MockRegistryFactory (com.alibaba.dubbo.config.spring.registry) MockRegistryFactory (com.alibaba.dubbo.config.support) MulticastRegistryFactory (com.alibaba.dubbo.registry.multicast) RedisRegistryFactory (com.alibaba.dubbo.registry.redis) ZookeeperRegistryFactory (com.alibaba.dubbo.registry.zookeeper) Registry12public interface Registry extends Node, RegistryService &#123;&#125; 实现类：12345678910111213AbstractRegistry (com.alibaba.dubbo.registry.support) Anonymous in createRegistry() in Anonymous in registryFactory in AbstractRegistryFactoryTest (com.alibaba.dubbo.registry.support) DubboRegistry (com.alibaba.dubbo.registry.dubbo) FailbackRegistry (com.alibaba.dubbo.registry.support) MockRegistry (com.alibaba.dubbo.config.spring.registry) MockRegistry (com.alibaba.dubbo.config.support) MockRegistry in FailbackRegistryTest (com.alibaba.dubbo.registry.support) MockRegistry in RegistryDirectoryTest (com.alibaba.dubbo.registry.dubbo) MockRegistry in RegistryProtocolTest (com.alibaba.dubbo.registry.dubbo) MulticastRegistry (com.alibaba.dubbo.registry.multicast) RedisRegistry (com.alibaba.dubbo.registry.redis) SimpleRegistryService (com.alibaba.dubbo.registry.simple)ZookeeperRegistry (com.alibaba.dubbo.registry.zookeeper) RegistryService123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public interface RegistryService &#123; /** * 注册数据，比如：提供者地址，消费者地址，路由规则，覆盖规则，等数据。 * &lt;p&gt; * 注册需处理契约：&lt;br&gt; * 1. 当URL设置了check=false时，注册失败后不报错，在后台定时重试，否则抛出异常。&lt;br&gt; * 2. 当URL设置了dynamic=false参数，则需持久存储，否则，当注册者出现断电等情况异常退出时，需自动删除。&lt;br&gt; * 3. 当URL设置了category=routers时，表示分类存储，缺省类别为providers，可按分类部分通知数据。&lt;br&gt; * 4. 当注册中心重启，网络抖动，不能丢失数据，包括断线自动删除数据。&lt;br&gt; * 5. 允许URI相同但参数不同的URL并存，不能覆盖。&lt;br&gt; * * @param url 注册信息，不允许为空，如：dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin */ void register(URL url); /** * 取消注册. * &lt;p&gt; * 取消注册需处理契约：&lt;br&gt; * 1. 如果是dynamic=false的持久存储数据，找不到注册数据，则抛IllegalStateException，否则忽略。&lt;br&gt; * 2. 按全URL匹配取消注册。&lt;br&gt; * * @param url 注册信息，不允许为空，如：dubbo://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin */ void unregister(URL url); /** * 订阅符合条件的已注册数据，当有注册数据变更时自动推送. * &lt;p&gt; * 订阅需处理契约：&lt;br&gt; * 1. 当URL设置了check=false时，订阅失败后不报错，在后台定时重试。&lt;br&gt; * 2. 当URL设置了category=routers，只通知指定分类的数据，多个分类用逗号分隔，并允许星号通配，表示订阅所有分类数据。&lt;br&gt; * 3. 允许以interface,group,version,classifier作为条件查询，如：interface=com.alibaba.foo.BarService&amp;version=1.0.0&lt;br&gt; * 4. 并且查询条件允许星号通配，订阅所有接口的所有分组的所有版本，或：interface=*&amp;group=*&amp;version=*&amp;classifier=*&lt;br&gt; * 5. 当注册中心重启，网络抖动，需自动恢复订阅请求。&lt;br&gt; * 6. 允许URI相同但参数不同的URL并存，不能覆盖。&lt;br&gt; * 7. 必须阻塞订阅过程，等第一次通知完后再返回。&lt;br&gt; * * @param url 订阅条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @param listener 变更事件监听器，不允许为空 */ void subscribe(URL url, NotifyListener listener); /** * 取消订阅. * &lt;p&gt; * 取消订阅需处理契约：&lt;br&gt; * 1. 如果没有订阅，直接忽略。&lt;br&gt; * 2. 按全URL匹配取消订阅。&lt;br&gt; * * @param url 订阅条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @param listener 变更事件监听器，不允许为空 */ void unsubscribe(URL url, NotifyListener listener); /** * 查询符合条件的已注册数据，与订阅的推模式相对应，这里为拉模式，只返回一次结果。 * * @param url 查询条件，不允许为空，如：consumer://10.20.153.10/com.alibaba.foo.BarService?version=1.0.0&amp;application=kylin * @return 已注册信息列表，可能为空，含义同&#123;@link com.alibaba.dubbo.registry.NotifyListener#notify(List&lt;URL&gt;)&#125;的参数。 * @see com.alibaba.dubbo.registry.NotifyListener#notify(List) */ List&lt;URL&gt; lookup(URL url);&#125; 实现类如下：123456789101112131415AbstractRegistry (com.alibaba.dubbo.registry.support) AbstractRegistryService (com.alibaba.dubbo.config.spring) AbstractRegistryService (com.alibaba.dubbo.registry.dubbo) Anonymous in createRegistry() in Anonymous in registryFactory in AbstractRegistryFactoryTest (com.alibaba.dubbo.registry.support) DubboRegistry (com.alibaba.dubbo.registry.dubbo) FailbackRegistry (com.alibaba.dubbo.registry.support) MockRegistry (com.alibaba.dubbo.config.spring.registry) MockRegistry (com.alibaba.dubbo.config.support) MulticastRegistry (com.alibaba.dubbo.registry.multicast) RedisRegistry (com.alibaba.dubbo.registry.redis) Registry (com.alibaba.dubbo.registry) SimpleRegistryService (com.alibaba.dubbo.config.spring) SimpleRegistryService (com.alibaba.dubbo.registry.dubbo) SimpleRegistryService (com.alibaba.dubbo.registry.simple) ZookeeperRegistry (com.alibaba.dubbo.registry.zookeeper) 通过这几个类的接口方法可以看到，dubbo的registry层是围绕这注册中心的注册、订阅展开的，我们以最常用的zookeeper注册中心来看下注册订阅的流程：1234567protected void doRegister(URL url) &#123; try &#123; zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true)); &#125; catch (Throwable e) &#123; throw new RpcException(&quot;Failed to register &quot; + url + &quot; to zookeeper &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e); &#125; &#125; zkClient.create的方法体在AbstractZookeeperClient中：1234567891011public void create(String path, boolean ephemeral) &#123; int i = path.lastIndexOf(&apos;/&apos;); if (i &gt; 0) &#123; create(path.substring(0, i), false); &#125; if (ephemeral) &#123; createEphemeral(path); &#125; else &#123; createPersistent(path); &#125; &#125; ephemeral参数是用于控制永久节点还是临时节点的，再玩下代码基本上到了ZkClient的范畴，不在本文讨论范围内。 再看下取消注册的代码：1234567protected void doUnregister(URL url) &#123; try &#123; zkClient.delete(toUrlPath(url)); &#125; catch (Throwable e) &#123; throw new RpcException(&quot;Failed to unregister &quot; + url + &quot; to zookeeper &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e); &#125; &#125; 也非常的简单，调用ZKClient删除节点即可。再来看12345678910111213141516171819202122232425protected void doSubscribe(final URL url, final NotifyListener listener) &#123; List&lt;URL&gt; urls = new ArrayList&lt;URL&gt;(); for (String path : toCategoriesPath(url)) &#123; ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url); if (listeners == null) &#123; zkListeners.putIfAbsent(url, new ConcurrentHashMap&lt;NotifyListener, ChildListener&gt;()); listeners = zkListeners.get(url); &#125; ChildListener zkListener = listeners.get(listener); if (zkListener == null) &#123; listeners.putIfAbsent(listener, new ChildListener() &#123; public void childChanged(String parentPath, List&lt;String&gt; currentChilds) &#123; ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds)); &#125; &#125;); zkListener = listeners.get(listener); &#125; zkClient.create(path, false); List&lt;String&gt; children = zkClient.addChildListener(path, zkListener); if (children != null) &#123; urls.addAll(toUrlsWithEmpty(url, path, children)); &#125; &#125; notify(url, listener, urls); &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《dubbo源码深度解析》之proxy 服务代理层]]></title>
    <url>%2F2018%2F04%2F22%2Fdubbo-proxy%20%2F</url>
    <content type="text"><![CDATA[proxy层是dubbo架构中的第三层，在dubbo官网中的定义如下：proxy 服务代理层：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 ServiceProxy 为中心，扩展接口为 ProxyFactory ProxyFactory12345678910@SPI(&quot;javassist&quot;)public interface ProxyFactory &#123; @Adaptive(&#123;Constants.PROXY_KEY&#125;) &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException; @Adaptive(&#123;Constants.PROXY_KEY&#125;) &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) throws RpcException;&#125; ProxyFactory只有两个方法：getProxy和getInvoker，其中，getProxy针对客户端，参数只有一个：Invoker，Invoker也多次提到，是贯穿dubbo全文的一个可执行对象，getProxy返回的是一个动态代理对象，暂时可以理解为jdk动态代理对象，当然这里不止jdk动态代理一种实现方式。 getInvoker方法针对服务端，传入的参数有三个：目标接口实现类（DemoServiceImpl）、接口的Class对象、url，通过这三个参数，构造出一个Invoker，通过这个方法也可以看出Invoker对象是一个具备执行能力的对象。 ProxyFactory的实现类有很多，但扣去包装类，公共父类等，真正的实现类就两个：JdkProxyFactory和JavassistProxyFactory JdkProxyFactory12345678910111213141516171819public class JdkProxyFactory extends AbstractProxyFactory &#123; @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123; return (T) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), interfaces, new InvokerInvocationHandler(invoker)); &#125; public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123; return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123; @Override protected Object doInvoke(T proxy, String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments) throws Throwable &#123; Method method = proxy.getClass().getMethod(methodName, parameterTypes); return method.invoke(proxy, arguments); &#125; &#125;; &#125;&#125; 其中，getProxy方法就是一个标准的jdk动态代理的实现方式，对jdk动态代理不熟悉的同学可以看我之前的文章：http://wangzx.org/2018/04/28/jdk-proxy/ ，这里有个关键的类，就是InvokerInvocationHandler，我们来看下代码：123456789101112131415161718192021222324252627public class InvokerInvocationHandler implements InvocationHandler &#123; private final Invoker&lt;?&gt; invoker; public InvokerInvocationHandler(Invoker&lt;?&gt; handler) &#123; this.invoker = handler; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(invoker, args); &#125; if (&quot;toString&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123; return invoker.toString(); &#125; if (&quot;hashCode&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123; return invoker.hashCode(); &#125; if (&quot;equals&quot;.equals(methodName) &amp;&amp; parameterTypes.length == 1) &#123; return invoker.equals(args[0]); &#125; return invoker.invoke(new RpcInvocation(method, args)).recreate(); &#125;&#125; 这个类也是jdk动态代理的标准实现方式，最终调用的是Invoker的invoke方法，这个方法非常关键，我们在后面再讲。 然后是getInvoker方法，重申一遍这个方法针对的是服务端，从方法参数中也可以看到这是一个针对服务端的接口，因为参数中包含proxy这个对象，即实现类的对象，只有在服务端中才有实现类，返回的是一个AbstractProxyInvoker对象，这是一个实现了Invoker的抽象类，但在getInvoker方法中，我们好像并没有实现Invoker的invoker方法，而是实现了doInvoke方法，这个怎么回事呢？我们看下AbstractProxyInvoker的invoke方法就能得到答案：123456789public Result invoke(Invocation invocation) throws RpcException &#123; try &#123; return new RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments())); &#125; catch (InvocationTargetException e) &#123; return new RpcResult(e.getTargetException()); &#125; catch (Throwable e) &#123; throw new RpcException(&quot;Failed to invoke remote proxy method &quot; + invocation.getMethodName() + &quot; to &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e); &#125; &#125; AbstractProxyInvoker将在服务端收到客户端发来的请求后，通过url找到Invoker，然后调用Invoker的invoke方法，然后调用我们重写的doInvoke方法，最终通过jdk反射完成了方法的调用。 JavassistProxyFactory123456789101112131415161718192021public class JavassistProxyFactory extends AbstractProxyFactory &#123; @SuppressWarnings(&quot;unchecked&quot;) public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123; return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker)); &#125; public &lt;T&gt; Invoker&lt;T&gt; getInvoker(T proxy, Class&lt;T&gt; type, URL url) &#123; // TODO Wrapper类不能正确处理带$的类名 final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(&apos;$&apos;) &lt; 0 ? proxy.getClass() : type); return new AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123; @Override protected Object doInvoke(T proxy, String methodName, Class&lt;?&gt;[] parameterTypes, Object[] arguments) throws Throwable &#123; return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments); &#125; &#125;; &#125;&#125; getProxy方法也就一行代码，乍看跟jdk动态代理很像，但其实这里Proxy.getProxy()方法是dubbo自己实现的一套生成动态代理类的逻辑：1234567891011121314151617181920212223public static Proxy getProxy(ClassLoader cl, Class&lt;?&gt;... ics) &#123; //省略代码 String pcn = pkg + &quot;.proxy&quot; + id; ccp.setClassName(pcn); ccp.addField(&quot;public static java.lang.reflect.Method[] methods;&quot;); ccp.addField(&quot;private &quot; + InvocationHandler.class.getName() + &quot; handler;&quot;); ccp.addConstructor(Modifier.PUBLIC, new Class&lt;?&gt;[]&#123;InvocationHandler.class&#125;, new Class&lt;?&gt;[0], &quot;handler=$1;&quot;); ccp.addDefaultConstructor(); Class&lt;?&gt; clazz = ccp.toClass(); clazz.getField(&quot;methods&quot;).set(null, methods.toArray(new Method[0])); // create Proxy class. String fcn = Proxy.class.getName() + id; ccm = ClassGenerator.newInstance(cl); ccm.setClassName(fcn); ccm.addDefaultConstructor(); ccm.setSuperClass(Proxy.class); ccm.addMethod(&quot;public Object newInstance(&quot; + InvocationHandler.class.getName() + &quot; h)&#123; return new &quot; + pcn + &quot;($1); &#125;&quot;); Class&lt;?&gt; pc = ccm.toClass(); proxy = (Proxy) pc.newInstance(); //省略代码 return proxy; &#125; 可以大概看出是通过javassist来动态生成类，具体的生成逻辑我们不用他太过关心，倒是可以看下最终生成的类是什么样子：123456789101112131415161718192021222324252627public class Proxy0 extends Proxy implements com.alibaba.dubbo.rpc.service.EchoService,com.alibaba.dubbo.demo.DemoService&#123; public static java.lang.reflect.Method[] methods; private java.lang.reflect.InvocationHandler handler; public Proxy0(java.lang.reflect.InvocationHandler arg0)&#123; handler=arg0; &#125; public Object newInstance(InvocationHandler h)&#123; return new Proxy0(h); &#125; public java.lang.String sayHello(java.lang.String arg0) throws Throwable &#123; Object[] args = new Object[1]; args[0] = arg0; Object ret = handler.invoke(this, methods[0], args); return (java.lang.String)ret; &#125; public java.lang.Object $echo(java.lang.Object arg0) throws Throwable &#123; Object[] args = new Object[1]; args[0] = arg0; Object ret = handler.invoke(this, methods[1], args); return (java.lang.Object)ret; &#125;&#125; 这个就是代理对象的代码，可以看到在调用sayHello这个方法是，最终调用的其实也是InvocationHandler对象的invoke方法，而InvocationHandler 这个对象，是在newInstance这个方法中传进去的，这里的而InvocationHandler用的和JdkProxyFactory中用的是同一个，所以我们可以近似的认为，在getProxy这个方法上，ProxyFactory的两个实现类的实现，并没有多大差别。 再看getInvoker方法，返回的依然是个AbstractProxyInvoker对象，但在重新的doInvoke方法中，调用的是Wrapper类的invokeMethod方法，而不是JdkProxyFactory中的用反射调用，这里是多了一个包装类的逻辑，其实这里非常像jdk动态代理和cglib动态代理之间的关系，jdk动态代理在最终方法调用时，是通过反射调用，但cglib在最终方法调用时，是通过一个fastClass机制调用，避免过多使用反射造成性能问题，我们可以来看下这个Wrapper类的生成过程：1234567891011121314151617181920212223242526272829303132private static Wrapper makeWrapper(Class&lt;?&gt; c) &#123; StringBuilder c1 = new StringBuilder(&quot;public void setPropertyValue(Object o, String n, Object v)&#123; &quot;); StringBuilder c2 = new StringBuilder(&quot;public Object getPropertyValue(Object o, String n)&#123; &quot;); StringBuilder c3 = new StringBuilder(&quot;public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws &quot; + InvocationTargetException.class.getName() + &quot;&#123; &quot;); c1.append(name).append(&quot; w; try&#123; w = ((&quot;).append(name).append(&quot;)$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;&quot;); c2.append(name).append(&quot; w; try&#123; w = ((&quot;).append(name).append(&quot;)$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;&quot;); c3.append(name).append(&quot; w; try&#123; w = ((&quot;).append(name).append(&quot;)$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;&quot;); c1.append(&quot; throw new &quot; + NoSuchPropertyException.class.getName() + &quot;(\&quot;Not found property \\\&quot;\&quot;+$2+\&quot;\\\&quot; filed or setter method in class &quot; + c.getName() + &quot;.\&quot;); &#125;&quot;); c2.append(&quot; throw new &quot; + NoSuchPropertyException.class.getName() + &quot;(\&quot;Not found property \\\&quot;\&quot;+$2+\&quot;\\\&quot; filed or setter method in class &quot; + c.getName() + &quot;.\&quot;); &#125;&quot;); // make class long id = WRAPPER_CLASS_COUNTER.getAndIncrement(); ClassGenerator cc = ClassGenerator.newInstance(cl); cc.setClassName((Modifier.isPublic(c.getModifiers()) ? Wrapper.class.getName() : c.getName() + &quot;$sw&quot;) + id); cc.setSuperClass(Wrapper.class); cc.addDefaultConstructor(); cc.addField(&quot;public static String[] pns;&quot;); // property name array. cc.addField(&quot;public static &quot; + Map.class.getName() + &quot; pts;&quot;); // property type map. cc.addField(&quot;public static String[] mns;&quot;); // all method name array. cc.addField(&quot;public static String[] dmns;&quot;); // declared method name array. for (int i = 0, len = ms.size(); i &lt; len; i++) cc.addField(&quot;public static Class[] mts&quot; + i + &quot;;&quot;); cc.addMethod(&quot;public String[] getPropertyNames()&#123; return pns; &#125;&quot;); cc.addMethod(&quot;public boolean hasProperty(String n)&#123; return pts.containsKey($1); &#125;&quot;); cc.addMethod(&quot;public Class getPropertyType(String n)&#123; return (Class)pts.get($1); &#125;&quot;); cc.addMethod(&quot;public String[] getMethodNames()&#123; return mns; &#125;&quot;); cc.addMethod(&quot;public String[] getDeclaredMethodNames()&#123; return dmns; &#125;&quot;); //省略代码 &#125; 可以看到同样是通过Javassist来动态生成类，与其看生成的逻辑，还不如看下最终生成的类：123456789101112131415161718192021public class Wrapper1 extends Wrapper &#123; //省略代码 public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws java.lang.reflect.InvocationTargetException&#123; com.alibaba.dubbo.demo.provider.DemoServiceImpl w; try&#123; w = ((com.alibaba.dubbo.demo.provider.DemoServiceImpl)o); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125; try&#123; if( &quot;sayHello&quot;.equals( n ) &amp;&amp; p.length == 1 ) &#123; return w.sayHello((java.lang.String)v[0]); &#125; &#125; catch(Throwable e) &#123; throw new java.lang.reflect.InvocationTargetException(e); &#125; throw new com.alibaba.dubbo.common.bytecode.NoSuchMethodException(&quot;Not found method \&quot;&quot;+n+&quot;\&quot; in class com.alibaba.dubbo.demo.provider.DemoServiceImpl.&quot;); &#125;&#125; 可以看到这里是通过直接调用的方式来调用目标方法，相比于JdkProxyFactory的反射调用，直接调用能带来更大的性能提升，因此JavassistProxyFactory也是dubbo的默认配置。]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《dubbo源码深度解析》之config配置层]]></title>
    <url>%2F2018%2F04%2F18%2Fdubbo-config%2F</url>
    <content type="text"><![CDATA[config层是dubbo架构中的第二层，第一层的service即是我们的业务层，因此我们从config层开始看，config层在官网中的解释如下: 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类 spring自定义标签我们在通过xml文件配置dubbo时，使用了dubbo给我们提供的spring自定义标签，入口类在dubbo-config包下的DubboNamespaceHandler文件：1234567891011121314151617181920public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123; static &#123; Version.checkDuplicate(DubboNamespaceHandler.class); &#125; public void init() &#123; registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true)); registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true)); registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true)); registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true)); registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true)); registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true)); registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true)); registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true)); registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false)); registerBeanDefinitionParser(&quot;annotation&quot;, new DubboBeanDefinitionParser(AnnotationBean.class, true)); &#125;&#125; 我们在xml中配置的标签，将会转换为如ApplicationConfig、RegistryConfig、ProtocolConfig、ServiceBean等一个个bean，xml到bean的过程，不是重点，我们稍微看下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) &#123; RootBeanDefinition beanDefinition = new RootBeanDefinition(); beanDefinition.setBeanClass(beanClass); beanDefinition.setLazyInit(false); String id = element.getAttribute(&quot;id&quot;); if ((id == null || id.length() == 0) &amp;&amp; required) &#123; String generatedBeanName = element.getAttribute(&quot;name&quot;); if (generatedBeanName == null || generatedBeanName.length() == 0) &#123; if (ProtocolConfig.class.equals(beanClass)) &#123; generatedBeanName = &quot;dubbo&quot;; &#125; else &#123; generatedBeanName = element.getAttribute(&quot;interface&quot;); &#125; &#125; if (generatedBeanName == null || generatedBeanName.length() == 0) &#123; generatedBeanName = beanClass.getName(); &#125; id = generatedBeanName; int counter = 2; while (parserContext.getRegistry().containsBeanDefinition(id)) &#123; id = generatedBeanName + (counter++); &#125; &#125; if (id != null &amp;&amp; id.length() &gt; 0) &#123; if (parserContext.getRegistry().containsBeanDefinition(id)) &#123; throw new IllegalStateException(&quot;Duplicate spring bean id &quot; + id); &#125; parserContext.getRegistry().registerBeanDefinition(id, beanDefinition); beanDefinition.getPropertyValues().addPropertyValue(&quot;id&quot;, id); &#125; if (ProtocolConfig.class.equals(beanClass)) &#123; for (String name : parserContext.getRegistry().getBeanDefinitionNames()) &#123; BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name); PropertyValue property = definition.getPropertyValues().getPropertyValue(&quot;protocol&quot;); if (property != null) &#123; Object value = property.getValue(); if (value instanceof ProtocolConfig &amp;&amp; id.equals(((ProtocolConfig) value).getName())) &#123; definition.getPropertyValues().addPropertyValue(&quot;protocol&quot;, new RuntimeBeanReference(id)); &#125; &#125; &#125; &#125; else if (ServiceBean.class.equals(beanClass)) &#123; String className = element.getAttribute(&quot;class&quot;); if (className != null &amp;&amp; className.length() &gt; 0) &#123; RootBeanDefinition classDefinition = new RootBeanDefinition(); classDefinition.setBeanClass(ReflectUtils.forName(className)); classDefinition.setLazyInit(false); parseProperties(element.getChildNodes(), classDefinition); beanDefinition.getPropertyValues().addPropertyValue(&quot;ref&quot;, new BeanDefinitionHolder(classDefinition, id + &quot;Impl&quot;)); &#125; &#125; else if (ProviderConfig.class.equals(beanClass)) &#123; parseNested(element, parserContext, ServiceBean.class, true, &quot;service&quot;, &quot;provider&quot;, id, beanDefinition); &#125; else if (ConsumerConfig.class.equals(beanClass)) &#123; parseNested(element, parserContext, ReferenceBean.class, false, &quot;reference&quot;, &quot;consumer&quot;, id, beanDefinition); &#125; Set&lt;String&gt; props = new HashSet&lt;String&gt;(); ManagedMap parameters = null; //省略部分代码 NamedNodeMap attributes = element.getAttributes(); int len = attributes.getLength(); for (int i = 0; i &lt; len; i++) &#123; Node node = attributes.item(i); String name = node.getLocalName(); if (!props.contains(name)) &#123; if (parameters == null) &#123; parameters = new ManagedMap(); &#125; String value = node.getNodeValue(); parameters.put(name, new TypedStringValue(value, String.class)); &#125; &#125; if (parameters != null) &#123; beanDefinition.getPropertyValues().addPropertyValue(&quot;parameters&quot;, parameters); &#125; return beanDefinition;&#125; 构造BeanDefinition的过程并没有什么特殊，但由于dubbo把所有的解析过程都写在这个方法里，看上去难免杂乱一些，与其看BeanDefinition的解析过程，还不如看最终解析出了什么东西，在此之前先附上xml配置文件：1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name=&quot;demo-provider&quot;/&gt; &lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=&quot;192.168.32.145:2181&quot; protocol=&quot;zookeeper&quot;/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;bean id=&quot;demoService&quot; class=&quot;com.alibaba.dubbo.demo.provider.DemoServiceImpl&quot;/&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;dubbo:service interface=&quot;com.alibaba.dubbo.demo.DemoService&quot; ref=&quot;demoService&quot;/&gt;&lt;/beans&gt; ApplicationConfig:123456789101112name = &quot;demo-provider&quot;version = nullowner = nullorganization = nullarchitecture = nullenvironment = nullcompiler = nulllogger = nullregistries = nullmonitor = nullisDefault = nullid = &quot;demo-provider&quot; //自动把id设置为和name一样 RegistryConfig:12345678910111213141516171819202122address = &quot;192.168.32.145:2181&quot;username = nullpassword = nullport = nullprotocol = &quot;zookeeper&quot;transporter = nullserver = nullclient = nullcluster = nullgroup = nullversion = nulltimeout = nullsession = nullfile = nullwait = nullcheck = nulldynamic = nullregister = nullsubscribe = nullparameters = nullisDefault = nullid = &quot;com.alibaba.dubbo.config.RegistryConfig&quot; //自动设置了id ProtocolConfig：1234567891011121314151617181920212223242526272829name = &quot;dubbo&quot;host = nullport = &#123;Integer@1956&#125; &quot;20880&quot;contextpath = nullthreadpool = nullthreads = nulliothreads = nullqueues = nullaccepts = nullcodec = nullserialization = nullcharset = nullpayload = nullbuffer = nullheartbeat = nullaccesslog = nulltransporter = nullexchanger = nulldispatcher = nullnetworker = nullserver = nullclient = nulltelnet = nullprompt = nullstatus = nullregister = nullparameters = nullisDefault = nullid = &quot;dubbo&quot; //自动把id设置为和name一样 可以看到基本上就和我们在配置文件中看到的一样，当然，这是在最简单的配置下，如果有配置多注册中心，多protocol，配置method等，解析过程就稍微复杂一些。 ServiceConfig代码的入口在ServiceBean这个类中，这里有两个关键方法：afterPropertiesSet()和onApplicationEvent()，在初始化这个Bean的时候会调用afterPropertiesSet()方法，这个方法的主要作用，就是获取ApplicationConfig、RegistryConfig、ProtocolConfig等对象，注入到ServiceBean当中，已供ServiceBean在后续的服务暴露过程中使用。onApplicationEvent()方法会在spring初始化完成后调用：12345678910public void onApplicationEvent(ApplicationEvent event) &#123; if (ContextRefreshedEvent.class.getName().equals(event.getClass().getName())) &#123; if (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(&quot;The service ready on spring started. service: &quot; + getInterface()); &#125; export(); &#125; &#125; &#125; export()方法在其父类ServiceConfig中，这个方法就做一些简单的检查后跳到doExport()方法，在这个方法中，除了一些检查设置外，还有一个填充默认配置的方法：appendProperties(this)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566protected static void appendProperties(AbstractConfig config) &#123; if (config == null) &#123; return; &#125; String prefix = &quot;dubbo.&quot; + getTagName(config.getClass()) + &quot;.&quot;; Method[] methods = config.getClass().getMethods(); for (Method method : methods) &#123; try &#123; String name = method.getName(); if (name.length() &gt; 3 &amp;&amp; name.startsWith(&quot;set&quot;) &amp;&amp; Modifier.isPublic(method.getModifiers()) &amp;&amp; method.getParameterTypes().length == 1 &amp;&amp; isPrimitive(method.getParameterTypes()[0])) &#123; String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), &quot;-&quot;); String value = null; if (config.getId() != null &amp;&amp; config.getId().length() &gt; 0) &#123; String pn = prefix + config.getId() + &quot;.&quot; + property; value = System.getProperty(pn); if (!StringUtils.isBlank(value)) &#123; logger.info(&quot;Use System Property &quot; + pn + &quot; to config dubbo&quot;); &#125; &#125; if (value == null || value.length() == 0) &#123; String pn = prefix + property; value = System.getProperty(pn); if (!StringUtils.isBlank(value)) &#123; logger.info(&quot;Use System Property &quot; + pn + &quot; to config dubbo&quot;); &#125; &#125; if (value == null || value.length() == 0) &#123; Method getter; try &#123; getter = config.getClass().getMethod(&quot;get&quot; + name.substring(3), new Class&lt;?&gt;[0]); &#125; catch (NoSuchMethodException e) &#123; try &#123; getter = config.getClass().getMethod(&quot;is&quot; + name.substring(3), new Class&lt;?&gt;[0]); &#125; catch (NoSuchMethodException e2) &#123; getter = null; &#125; &#125; if (getter != null) &#123; if (getter.invoke(config, new Object[0]) == null) &#123; if (config.getId() != null &amp;&amp; config.getId().length() &gt; 0) &#123; value = ConfigUtils.getProperty(prefix + config.getId() + &quot;.&quot; + property); &#125; if (value == null || value.length() == 0) &#123; value = ConfigUtils.getProperty(prefix + property); &#125; if (value == null || value.length() == 0) &#123; String legacyKey = legacyProperties.get(prefix + property); if (legacyKey != null &amp;&amp; legacyKey.length() &gt; 0) &#123; value = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey)); &#125; &#125; &#125; &#125; &#125; if (value != null &amp;&amp; value.length() &gt; 0) &#123; method.invoke(config, new Object[]&#123;convertPrimitive(method.getParameterTypes()[0], value)&#125;); &#125; &#125; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; &#125; &#125; 这个方法的主要作用，是从系统的环境变量、dubbo.properties中获取配置，注入到ApplicationConfig、RegistryConfig、ProtocolConfig等对象中，这也是dubbo默认参数的实现方式，可以将一些公共的配置，写在dubbo.properties中，dubbo会帮我们注入，由于我们没有使用dubbo.properties配置，因此这一轮检查和注入过后，配置没有发生变化，之后就到了正在开始暴露服务：doExportUrls():123456private void doExportUrls() &#123; List&lt;URL&gt; registryURLs = loadRegistries(true); for (ProtocolConfig protocolConfig : protocols) &#123; doExportUrlsFor1Protocol(protocolConfig, registryURLs); &#125; &#125; 这个方法首先进行了url的组装：loadRegistries(boolean provider)：123456789101112131415161718192021222324252627282930313233343536373839404142434445protected List&lt;URL&gt; loadRegistries(boolean provider) &#123; checkRegistry(); List&lt;URL&gt; registryList = new ArrayList&lt;URL&gt;(); if (registries != null &amp;&amp; registries.size() &gt; 0) &#123; for (RegistryConfig config : registries) &#123; String address = config.getAddress(); if (address == null || address.length() == 0) &#123; address = Constants.ANYHOST_VALUE; &#125; String sysaddress = System.getProperty(&quot;dubbo.registry.address&quot;); if (sysaddress != null &amp;&amp; sysaddress.length() &gt; 0) &#123; address = sysaddress; &#125; if (address != null &amp;&amp; address.length() &gt; 0 &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); appendParameters(map, application); appendParameters(map, config); map.put(&quot;path&quot;, RegistryService.class.getName()); map.put(&quot;dubbo&quot;, Version.getVersion()); map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis())); if (ConfigUtils.getPid() &gt; 0) &#123; map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid())); &#125; if (!map.containsKey(&quot;protocol&quot;)) &#123; if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(&quot;remote&quot;)) &#123; map.put(&quot;protocol&quot;, &quot;remote&quot;); &#125; else &#123; map.put(&quot;protocol&quot;, &quot;dubbo&quot;); &#125; &#125; List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map); for (URL url : urls) &#123; url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol()); url = url.setProtocol(Constants.REGISTRY_PROTOCOL); if ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true)) || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, true))) &#123; registryList.add(url); &#125; &#125; &#125; &#125; &#125; return registryList; &#125; 这个方法分为2部分，第一部分组装map和address，第二部分根据map和address生成url，在第一部分中有个比较重要的方法：appendParameters()：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465protected static void appendParameters(Map&lt;String, String&gt; parameters, Object config, String prefix) &#123; if (config == null) &#123; return; &#125; Method[] methods = config.getClass().getMethods(); for (Method method : methods) &#123; try &#123; String name = method.getName(); if ((name.startsWith(&quot;get&quot;) || name.startsWith(&quot;is&quot;)) &amp;&amp; !&quot;getClass&quot;.equals(name) &amp;&amp; Modifier.isPublic(method.getModifiers()) &amp;&amp; method.getParameterTypes().length == 0 &amp;&amp; isPrimitive(method.getReturnType())) &#123; Parameter parameter = method.getAnnotation(Parameter.class); if (method.getReturnType() == Object.class || parameter != null &amp;&amp; parameter.excluded()) &#123; continue; &#125; int i = name.startsWith(&quot;get&quot;) ? 3 : 2; String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), &quot;.&quot;); String key; if (parameter != null &amp;&amp; parameter.key() != null &amp;&amp; parameter.key().length() &gt; 0) &#123; key = parameter.key(); &#125; else &#123; key = prop; &#125; Object value = method.invoke(config, new Object[0]); String str = String.valueOf(value).trim(); if (value != null &amp;&amp; str.length() &gt; 0) &#123; if (parameter != null &amp;&amp; parameter.escaped()) &#123; str = URL.encode(str); &#125; if (parameter != null &amp;&amp; parameter.append()) &#123; String pre = (String) parameters.get(Constants.DEFAULT_KEY + &quot;.&quot; + key); if (pre != null &amp;&amp; pre.length() &gt; 0) &#123; str = pre + &quot;,&quot; + str; &#125; pre = (String) parameters.get(key); if (pre != null &amp;&amp; pre.length() &gt; 0) &#123; str = pre + &quot;,&quot; + str; &#125; &#125; if (prefix != null &amp;&amp; prefix.length() &gt; 0) &#123; key = prefix + &quot;.&quot; + key; &#125; parameters.put(key, str); &#125; else if (parameter != null &amp;&amp; parameter.required()) &#123; throw new IllegalStateException(config.getClass().getSimpleName() + &quot;.&quot; + key + &quot; == null&quot;); &#125; &#125; else if (&quot;getParameters&quot;.equals(name) &amp;&amp; Modifier.isPublic(method.getModifiers()) &amp;&amp; method.getParameterTypes().length == 0 &amp;&amp; method.getReturnType() == Map.class) &#123; Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) method.invoke(config, new Object[0]); if (map != null &amp;&amp; map.size() &gt; 0) &#123; String pre = (prefix != null &amp;&amp; prefix.length() &gt; 0 ? prefix + &quot;.&quot; : &quot;&quot;); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; parameters.put(pre + entry.getKey().replace(&apos;-&apos;, &apos;.&apos;), entry.getValue()); &#125; &#125; &#125; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; &#125; 这个方法的作用如下：遍历传进来的config对象的所有方法，如果是get或is开头，就调用该方法，如果返回值不为空，就存入map中，存入的key跟该方法是否有@Parameter注解有关，如果有，则以这个注解指定的key作为key值。 最终收集到的map如下：1234560 = &#123;HashMap$Entry@1722&#125; &quot;timestamp&quot; -&gt; &quot;1526381630841&quot;1 = &#123;HashMap$Entry@1723&#125; &quot;dubbo&quot; -&gt; &quot;2.0.0&quot;2 = &#123;HashMap$Entry@1724&#125; &quot;protocol&quot; -&gt; &quot;zookeeper&quot;3 = &#123;HashMap$Entry@1725&#125; &quot;application&quot; -&gt; &quot;demo-provider&quot;4 = &#123;HashMap$Entry@1726&#125; &quot;path&quot; -&gt; &quot;com.alibaba.dubbo.registry.RegistryService&quot;5 = &#123;HashMap$Entry@1727&#125; &quot;pid&quot; -&gt; &quot;1448&quot; 然后调用UrlUtils.parseURLs(address, map)方法组装url，这个方法就是一些拼装逻辑，与其去看它如何拼装，不如看下最终拼装的结果： 1zookeeper://192.168.32.145:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.0&amp;pid=1448&amp;registry=zookeeper&amp;timestamp=1526381630841 url拼装完成后，调用doExportUrlsFor1Protocol(protocolConfig, registryURLs)方法，这个方法是Config层的最后一个方法，这个方法过后将转到Registry层,由于这个方法太长，因此这里分为为2个部分进行说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123; //省略代码 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); if (anyhost) &#123; map.put(Constants.ANYHOST_KEY, &quot;true&quot;); &#125; map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE); map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion()); map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis())); if (ConfigUtils.getPid() &gt; 0) &#123; map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid())); &#125; appendParameters(map, application); appendParameters(map, module); appendParameters(map, provider, Constants.DEFAULT_KEY); appendParameters(map, protocolConfig); appendParameters(map, this); if (ProtocolUtils.isGeneric(generic)) &#123; map.put(&quot;generic&quot;, generic); map.put(&quot;methods&quot;, Constants.ANY_VALUE); &#125; else &#123; String revision = Version.getVersion(interfaceClass, version); if (revision != null &amp;&amp; revision.length() &gt; 0) &#123; map.put(&quot;revision&quot;, revision); &#125; String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames(); if (methods.length == 0) &#123; logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName()); map.put(&quot;methods&quot;, Constants.ANY_VALUE); &#125; else &#123; map.put(&quot;methods&quot;, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;)); &#125; &#125; if (!ConfigUtils.isEmpty(token)) &#123; if (ConfigUtils.isDefault(token)) &#123; map.put(&quot;token&quot;, UUID.randomUUID().toString()); &#125; else &#123; map.put(&quot;token&quot;, token); &#125; &#125; if (&quot;injvm&quot;.equals(protocolConfig.getName())) &#123; protocolConfig.setRegister(false); map.put(&quot;notify&quot;, &quot;false&quot;); &#125; //省略第二部分代码&#125; 这里的作用跟上面的方法一样，从各个config中，获取信息组装到map中，最后的结果如下：1234567890 = &#123;HashMap$Entry@2469&#125; &quot;methods&quot; -&gt; &quot;sayHello&quot;1 = &#123;HashMap$Entry@2204&#125; &quot;generic&quot; -&gt; &quot;false&quot;2 = &#123;HashMap$Entry@2205&#125; &quot;timestamp&quot; -&gt; &quot;1526382333491&quot;3 = &#123;HashMap$Entry@2206&#125; &quot;dubbo&quot; -&gt; &quot;2.0.0&quot;4 = &#123;HashMap$Entry@2207&#125; &quot;application&quot; -&gt; &quot;demo-provider&quot;5 = &#123;HashMap$Entry@2208&#125; &quot;side&quot; -&gt; &quot;provider&quot;6 = &#123;HashMap$Entry@2209&#125; &quot;pid&quot; -&gt; &quot;1448&quot;7 = &#123;HashMap$Entry@2210&#125; &quot;interface&quot; -&gt; &quot;com.alibaba.dubbo.demo.DemoService&quot;8 = &#123;HashMap$Entry@2211&#125; &quot;anyhost&quot; -&gt; &quot;true&quot; 第二部分代码，根据这个map，组装url，然后进行export：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123; //省略第一部分代码 // 导出服务 String contextPath = protocolConfig.getContextpath(); if ((contextPath == null || contextPath.length() == 0) &amp;&amp; provider != null) &#123; contextPath = provider.getContextpath(); &#125; URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? &quot;&quot; : contextPath + &quot;/&quot;) + path, map); if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class) .hasExtension(url.getProtocol())) &#123; url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class) .getExtension(url.getProtocol()).getConfigurator(url).configure(url); &#125; String scope = url.getParameter(Constants.SCOPE_KEY); //配置为none不暴露 if (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) &#123; //配置不是remote的情况下做本地暴露 (配置为remote，则表示只暴露远程服务) if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123; exportLocal(url); &#125; //如果配置不是local则暴露为远程服务.(配置为local，则表示只暴露本地服务) if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) &#123; if (logger.isInfoEnabled()) &#123; logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() + &quot; to url &quot; + url); &#125; if (registryURLs != null &amp;&amp; registryURLs.size() &gt; 0 &amp;&amp; url.getParameter(&quot;register&quot;, true)) &#123; for (URL registryURL : registryURLs) &#123; url = url.addParameterIfAbsent(&quot;dynamic&quot;, registryURL.getParameter(&quot;dynamic&quot;)); URL monitorUrl = loadMonitor(registryURL); if (monitorUrl != null) &#123; url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString()); &#125; if (logger.isInfoEnabled()) &#123; logger.info(&quot;Register dubbo service &quot; + interfaceClass.getName() + &quot; url &quot; + url + &quot; to registry &quot; + registryURL); &#125; Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString())); Exporter&lt;?&gt; exporter = protocol.export(invoker); exporters.add(exporter); &#125; &#125; else &#123; Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url); Exporter&lt;?&gt; exporter = protocol.export(invoker); exporters.add(exporter); &#125; &#125; &#125; this.urls.add(url);&#125; 首先进行了一次url组装，组装结果为：1dubbo://192.168.252.169:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=1448&amp;side=provider&amp;timestamp=1526382333491 然后判断url中的scope属性的值，如果是remote，则值进行远程暴露，如果是local，则只进行本地暴露，本地暴露和远程暴露的逻辑差不多，首先是获取一个Invoker，然后进行export，export完成后存入List]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《dubbo源码深度解析》之dubbo扩展点加载机制]]></title>
    <url>%2F2018%2F04%2F15%2Fdubbo-spi%2F</url>
    <content type="text"><![CDATA[dubbo的扩展点加载机制是dubbo的内核，是贯穿整个dubbo的设计思想，在dubbo的官方文档中，也是将扩展点加载机制放在第一篇幅，要想看懂dubbo的源码，首先要看懂dubbo的扩展点加载机制。本章会从java spi的例子开始，到dubbo spi的例子，然后到分析源码，帮助读者看懂dubbo的扩展点加载机制。 简单的例子java spi接口类123public interface Operate &#123; double count(double c1,double c2);&#125; 实现类112345678import com.example.java_spi.spi.Operate;public class AddOperate implements Operate &#123; public double count(double c1,double c2) &#123; return c1 + c2; &#125;&#125; 实现类21234567import com.example.java_spi.spi.Operate;public class DelOperate implements Operate &#123; public double count(double c1,double c2) &#123; return c1 - c2; &#125;&#125; META-INF文件12com.example.java_spi.impl.AddOperatecom.example.java_spi.impl.DelOperate 文件路径：META-INF/services/com.example.java_spi.spi.Operate 测试类123456789101112import com.example.java_spi.spi.Operate;import java.util.ServiceLoader;public class Main &#123; public static void main(String[] args) &#123; ServiceLoader&lt;Operate&gt; loaders = ServiceLoader.load(Operate.class); for (Operate d : loaders) &#123; double res = d.count(2,1); System.out.println(res); &#125; &#125;&#125; 执行结果123.01.0 可以看到java spi会加载所有的扩展点，且功能比较简单，没有apo ioc等功能 dubbo spi接口类123456789import com.alibaba.dubbo.common.URL;import com.alibaba.dubbo.common.extension.Adaptive;import com.alibaba.dubbo.common.extension.SPI;@SPIpublic interface Operate &#123; @Adaptive double count(URL url,double c1,double c2);&#125; 实现类1123456789import com.alibaba.dubbo.common.URL;import com.example.dubbo_spi.spi.Operate;public class AddOperate implements Operate &#123; public double count(URL url,double c1,double c2) &#123; return c1 + c2; &#125;&#125; 实现类212345678import com.alibaba.dubbo.common.URL;import com.example.dubbo_spi.spi.Operate;public class DelOperate implements Operate &#123; public double count(URL url,double c1,double c2) &#123; return c1 - c2; &#125;&#125; META-INF文件12add=com.example.dubbo_spi.impl.AddOperatedel=com.example.dubbo_spi.impl.DelOperate 文件路径：META-INF/dubbo/com.example.dubbo_spi.spi.Operate 测试类123456789101112131415161718import com.alibaba.dubbo.common.URL;import com.alibaba.dubbo.common.extension.ExtensionLoader;import com.example.dubbo_spi.spi.Operate;import java.util.HashMap;import java.util.Map;public class Main&#123; public static void main( String[] args ) &#123; Operate p = ExtensionLoader.getExtensionLoader(Operate.class).getAdaptiveExtension(); Map paramMap = new HashMap(); paramMap.put(&quot;operate&quot;,&quot;add&quot;); URL url = new URL(&quot;&quot;,&quot;&quot;,20880,paramMap); double res = p.count(url,2,1); System.out.println(res); &#125;&#125; 执行结果13.0 解析这个是dubbo spi最简单的一个例子，但也可以看出要比java 的spi要复杂的多。 首先从接口类看，类上要加一个注解：@SPI，否则会报错：1Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Extension type(interface com.example.dubbo_spi.spi.Operate) is not extension, because WITHOUT @SPI Annotation! 我们会在后面的源码解析中，分析出这些报错的原因及代码位置。 第二、接口方法至少一个要有@Adaptive注解，否则会报错：1Exception in thread &quot;main&quot; java.lang.IllegalStateException: fail to create adaptive instance: java.lang.IllegalStateException: Can not create adaptive extenstion interface com.example.dubbo_spi.spi.Operate, cause: No adaptive method on extension com.example.dubbo_spi.spi.Operate, refuse to create the adaptive class! 第三、注明@Adaptive的方法的参数中，必须要有URL类型的参数，或者参数的属性中包含URL类型的属性，否则会报错：1Exception in thread &quot;main&quot; java.lang.IllegalStateException: fail to create adaptive instance: java.lang.IllegalStateException: Can not create adaptive extenstion interface com.example.dubbo_spi.spi.Operate, cause: fail to create adative class for interface com.example.dubbo_spi.spi.Operate: not found url parameter or url attribute in parameters of method count 第四、META-INF文件中要指定key，如add=com.xxx.AddOperate,不指定不会报错，但会生成一个默认的key，比如AddOperate的默认key就是add，这个key，将会在url中用到。 第五、测试类中的URL对象要有paramMap，并且这个map中要包含一个key，就是接口类的方法中，有注明@Adaptive的方法，这个注解有个属性，如果指定，这这里的url的key，就是指定的这个，如果不指定，则这里url的key就是接口类的类名（驼峰转”.”,如SayHello的默认key是“say.hello”），本案例中没有指定，因此这里的key，应该是operate，因此需指定operate及其值，否则会报错：1Exception in thread &quot;main&quot; java.lang.IllegalStateException: Fail to get extension(com.example.dubbo_spi.spi.Operate) name from url() use keys([operate]) 到这里会难免有疑问，dubbo为什么要指定这么多奇奇怪怪的规则，我们来看测试类中Operate p的实际对象，通过源码分析可以取到代码：123456789101112package com.example.dubbo_spi.spi; import com.alibaba.dubbo.common.extension.ExtensionLoader;public class Operate$Adpative implements com.example.dubbo_spi.spi.Operate &#123; public double count(com.alibaba.dubbo.common.URL arg0, double arg1, double arg2) &#123; if (arg0 == null) throw new IllegalArgumentException(&quot;url == null&quot;); com.alibaba.dubbo.common.URL url = arg0; String extName = url.getParameter(&quot;operate&quot;); if(extName == null) throw new IllegalStateException(&quot;Fail to get extension(com.example.dubbo_spi.spi.Operate) name from url(&quot; + url.toString() + &quot;) use keys([operate])&quot;); com.example.dubbo_spi.spi.Operate extension = (com.example.dubbo_spi.spi.Operate)ExtensionLoader.getExtensionLoader(com.example.dubbo_spi.spi.Operate.class).getExtension(extName); return extension.count(arg0, arg1, arg2); &#125;&#125; 主要代码是：1ExtensionLoader.getExtensionLoader(com.example.dubbo_spi.spi.Operate.class).getExtension(extName); 这里的extName就是add，通过这行代码取到的对象就是AddOperate的实例，到这里完成了最简单的dubbo spi的调用。 dubbo spi之aopdubbo spi可以实现类似spring的aop功能，我们需要先创建一个OperateWrapper类，代码如下：12345678910111213141516171819import com.alibaba.dubbo.common.URL;import com.example.dubbo_spi.spi.Operate;public class OperateWrapper implements Operate &#123; private Operate operate; public OperateWrapper(Operate operate) &#123; this.operate = operate; &#125; public double count(URL url,double c1,double c2) &#123; System.out.println(&quot;==before==&quot;); double result = this.operate.count(url,c1,c2); System.out.println(result); System.out.println(&quot;==after==&quot;); return result; &#125;&#125; 执行结果如下：123==before==3.0==after== OperateWrapper也需要实现Operate接口，并且在构造方法中，需要有Operate这个接口参数，这样的类，dubbo的扩展点加载机制会认为它是一个代理类，用于实现aop的功能，这种包装类可以有多个，会按照在META-INF中的顺序排下来 dubbo spi之ioc首先我们需要如法炮制创建一个SayHello接口123456789import com.alibaba.dubbo.common.URL;import com.alibaba.dubbo.common.extension.Adaptive;import com.alibaba.dubbo.common.extension.SPI;@SPIpublic interface SayHello &#123; @Adaptive void say(URL url);&#125; 然后再创建一个实现类：12345678import com.alibaba.dubbo.common.URL;import com.example.dubbo_spi.spi.SayHello;public class ChineseSayHello implements SayHello &#123; public void say(URL url) &#123; System.out.println(&quot;你好！&quot;); &#125;&#125; 添加META-INF文件1chinese=com.example.dubbo_spi.impl.ChineseSayHello 然后修改AddOperate代码如下：123456789101112131415161718192021import com.alibaba.dubbo.common.URL;import com.example.dubbo_spi.spi.Operate;import com.example.dubbo_spi.spi.SayHello;public class AddOperate implements Operate &#123; private SayHello sayHello; public SayHello getSayHello() &#123; return sayHello; &#125; public void setSayHello(SayHello sayHello) &#123; this.sayHello = sayHello; &#125; public double count(URL url, double c1, double c2) &#123; sayHello.say(url); return c1 + c2; &#125;&#125; 最后在测试类的paramMap中加上say.hello的key和value1paramMap.put(&quot;say.hello&quot;,&quot;chinese&quot;); 运行结果：1234==before==你好！3.0==after== 这里的关键代码，在ExtensionLoader的injectExtension方法中123456789101112131415private T injectExtension(T instance) &#123; for (Method method : instance.getClass().getMethods()) &#123; if (method.getName().startsWith(&quot;set&quot;) &amp;&amp; method.getParameterTypes().length == 1 &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123; Class&lt;?&gt; pt = method.getParameterTypes()[0]; String property = method.getName().length() &gt; 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : &quot;&quot;; Object object = objectFactory.getExtension(pt, property); if (object != null) &#123; method.invoke(instance, object); &#125; &#125; &#125; return instance; &#125; 代码做了适当精简，主要逻辑是遍历目标类的方法，如果是set开头，如setSayHello，那就去找sayHello有没有这个对象，如果有，就通过set方法注入，问题是怎么找sayHello这个对象？答案是通过objectFactory的getExtension方法来找，这是个关键对象，后面会再提到，这里插播一个知识点，dubbo的自动注入，需要提供属性的set方法，否则无法注入，spring通过xml配置的属性，同样要有set方法，否则也无法注入，但spring通过@Autowired配置的属性，可以没有set方法，那spring是怎么实现的呢？答案是通过setAccessible()方法改变属性的访问标志，从而达到修改属性的目的，即注入。 源码解析代码入口在：1ExtensionLoader.getExtensionLoader(Operate.class).getAdaptiveExtension(); 进入getExtensionLoader方法：12345678public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) &#123; ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type); if (loader == null) &#123; EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type)); loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type); &#125; return loader; &#125; 这里有个关键对象： ConcurrentMap]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java内存结构与垃圾回收]]></title>
    <url>%2F2018%2F02%2F24%2Fjvm%2F</url>
    <content type="text"><![CDATA[内存结构堆内存（线程共享）新生代新创建的对象放入新生代，由于新生代的对象，大部分是朝生夕死，为了更好的垃圾回收，大多数垃圾收集器都采用复制算法，但由于最初的复制算法，将内存一分为二，浪费了50%的内存，因此后来将新生代内存划分为1块Eden区域和两块Survivor区域，默认的比例为8：1：1 Eden新创建的对象优先放入Eden区域 SuviderSurvivor区域有两块，进行一次垃圾回收后，Eden中存活的对象，被复制到Survivor区域中 老年代长期存活的对象放入老年代 方法区（线程共享）用于存储已被加载的类信息，常量，静态变量，即使编译器编译后的代码数据等 虚拟机栈（线程独享）每个方法执行时，都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，栈帧伴随着方法的执行而入栈，随着方法的结束而出栈 本地方法栈（线程独享）功能类似于虚拟机栈，只是这部分内存由native方法使用 程序计数器（线程独享）用于记录方法执行的行号，如果执行native方法，则无法记录行号，这是内存中唯一一块不会出现OOM的区域 如何判断对象为垃圾对象引用计数法添加一个引用计数器，当对象被引用时+1，解除引用时-1，当值为0时，即为垃圾对象，但由于这种算法，无法回收相互引用的对象，因此很少jvm采用这种算法 可达性分析法从GCRoot向下搜索，所走过的路径，称之为引用链，都为有用的对象，否则即为垃圾对象 可作为GCroot的节点：全局性的引用（常量或静态类的引用）与执行上下文（栈帧中的本地变量表） 如何回收回收策略标记-清除算法当对象被确认为垃圾对象之后，就会被标记为垃圾对象，标记的位置，在对象的header中，标记清除算法的两个缺点：1、效率不高 2、空间问题，不连续，后续创建大对象时寻址困难 复制算法将堆内存分为两块区域，当创建对象时，仅仅使用其中一块区域，当进行垃圾回收时，不再是清除那些被标记为垃圾的对象，而是将没有被标记为垃圾的对象，复制到另一块内存区域，然后将原来那块区域清空，这样很好的解决了标记-清除算法的空间问题，但同时引入了一个新问题，就是内存的浪费，将一块内存分为相等的两块内存，意味着浪费了50%的空间，为此，IBM公司的一个专项研究表明，新生代内存中，98%的对象都是朝生夕死，因此不需要按照1：1来分配内存，而是将内存划分为1块较大的Eden空间和两块较小的Survivor空间，具体的比例为8：1：1，在垃圾回收时，Eden区域和其中一块Surivor区域中还存活的对象，一次性被复制到另一块Surivivor空间上，然后清理掉Eden和刚刚那块Surivivor空间，如果遇到大对象，Surivivor空间不够放时，将进行空间分配担保，将对象放入老年代 标记-整理算法复制算法更适合新生代，但对于老年代，对象存活率比较高，无法采用复制算法，因此有人想出标记-整理算法，整个过程也分为两步，标记和整理，标记过程与标记清楚算法无异，但是标记完成后并没有马上清除，而是将所有存活的对象向内存的其中一端移动，然后再清理掉另一端的内存 分代收集算法当前主流的垃圾收集器都采用此算法，但这种算法并没有特别的思想，只是针对不同的区域，进行不同的算法，比如新生代采用复制算法，老年代采用标记-清除或标记-整理算法 垃圾收集器Serial最早的垃圾收集器，使用单线程收集垃圾，收集效率低下，无法利用多核Cpu的资源，但是现在Client模式的jvm，仍然默认使用这个收集器。 Parnew是Serial的多线程版本，能充分利用多核cpu的资源，另一个重要的原因是能与CMS收集器配合使用 Cms并发标记清除垃圾收集器，能使GC产生的停顿时间减小到最小，除了枚举根节点，会产生GC停顿之外，其他的都能并发执行 G1是当今收集器最前沿的成果之一 垃圾回收回收过程分析打印垃圾回收报告1VM参数： -XX:+PrintGCDetails -verbose:gc -XX:+UseSerialGC GC日志分析1[GC (Allocation Failure) [DefNew: 69085K-&gt;8704K(78656K), 0.0203408 secs] 69085K-&gt;64309K(253440K), 0.0203707 secs] [Times: user=0.02 sys=0.02, real=0.02 secs] DefNew新生代区域名称，由垃圾收集器指定，如使用Serial收集器时，新生代的名字叫DefNew，采用Parallel收集器时，新生代的名称为PSYoungGen 69085K-&gt;8704K(78656K)69085K代表本区域GC前的内存大小，8704K代表本区域GC后的内存大小，(78656K)代表本区域总内存大小 69085K-&gt;64309K(253440K)69085K代表堆内存GC前的内存大小，64309K代表堆内存GC后的内存大小，(253440K)代表堆内存的总大小 GC停顿在枚举根节点时，不能出现对象的引用关系还在不断发生变化的情况，因此造成GC进行时，必须停止所有的线程，Sun将这件事称之为“Stop The World”，即使在号称几乎不会发生停顿的CMS（并发标记收集）收集器中，枚举根节点时也必须要停顿 内存的创建内存分配策略优先分配到edenEden区域新生代中的一块区域，也是垃圾收集器最常光顾的地方，新创建对象默认放置这个区域。 大对象直接分配到老年代由于在Eden区域中，一般使用复制算法进行垃圾清理，并且次数非常频繁，大对象在频繁但复制过程中性能低下，因此放到老年代中，gc次数相对较少，并且也并不使用复制算法，以提高性能。大对象的标准会根据内存环境自动计算得出，也可以使用-XX:PretenureSizeThreshold=10M,指定大于10Mb的对象叫大对象。 长期存活到对象分配到老年代每一次的垃圾回收之后，都会给对象的年龄+1，当年龄达到某个值当时候，即称之为长期存活，进入老年代。我们可以使用-XX:MaxTenuringThreshshold=10,指定age达到10的时候进入老年代，默认值为15 空间分配担保动态对象年龄判断并非所有对象都需要到达MaxTenuringThreshshold指定的分代年龄之后才会进入老年代，但Survivor区域中，所有相同年龄的对象内存总和，大于Survivor的一半，即会进入老年代，不受MaxTenuringThreshshold的限制 逃逸分析与栈上分配当对象仅在方法体内部使用时，由于方法当调用会创建栈帧，当调用结束就会出栈，因此将仅供该方法使用的对象，放在栈内存中，随着方法的出入栈而出入栈，而不用垃圾回收机制进行干预，可大大提高性能 虚拟机工具jps是一个命令行工具，全称是java process status，常用的命令如下： jps -l 可以显示java进程执行的主类 jps -m 可以显示程序执行所接收的参数，即main方法中的args参数 jps -v 可以显示虚拟机执行所接收的参数，如-Xms8m 常用参数-Xmx最大堆容量 -Xms最小堆容量 -Xss栈内存大小，注意是单个线程的栈内存大小 -Xmn新生代内存大小 -XX:SurvivorRatio=8新生代中，Eden区域与其中一个Surivivor区的大小比例是8：1 -XX:PertenureSizeThreshold大对象的定义，超过这个值的称之为大对象，直接放入老年代，避免在新生代中来回复制造成性能问题 -XX:MaxTenuringThreshold对象分代年龄分界线，超过这个值进入老年代，默认为15 -XX:MaxPermSize最大方法区(非堆)容量 -XX:MaxDirectMemorySize最大直接内存，如果不指定，默认与最大堆内存一致 -XX:+PrintGCDetail打印GC日志 -XX:+PrintTenuringDistribution打印对象分代年龄 HeapDumpOnOutOfMemoryError当内存溢出时打印堆栈信息]]></content>
      <categories>
        <category>jvm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos7搭建saltstack]]></title>
    <url>%2F2018%2F02%2F07%2Fsalt-install%2F</url>
    <content type="text"><![CDATA[Salt，一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯。 salt底层采用动态的连接总线, 使其可以用于编配, 远程执行, 配置管理等等. 本次搭建使用centos7.1，共搭建1台master，2台minion，ip分配如下： 服务器ip hostname 说明 192.168.32.140 salt-master master 192.168.32.141 salt-minion1 minion 192.168.32.142 salt-minion2 minion 服务器基础设置关闭防火墙12$ systemctl stop firewalld$ systemctl disable firewalld 关闭selinux12$ setenforce 0$ vi /etc/selinux/config 将第6行修改为SELINUX=permissive1234567891011# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=permissive# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected.# mls - Multi Level Security protection.SELINUXTYPE=targeted 设置hostname1$ hostnamectl set-hostname salt-master 修改host文件修改/etc/hosts文件为如下内容123192.168.32.140 salt-master192.168.32.141 salt-minion1192.168.32.142 salt-minion2 使用scp命令复制到其他2台服务器1$ scp /etc/hosts root@salt-minion1:/etc/hosts 环境准备，依赖解决分别为三台机器添加阿里云epel源123$ mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup$ mv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup$ wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 解决依赖关系，不然会报python依赖错误 1234$ yum clean expire-cache$ yum upgrade$ yum -y install epel-release$ yum install zeromq3 m2crypto python-crypto python-jinja2 python-msgpack python-yaml python-zmq -y 开始安装salt-master安装1$ yum install -y salt-master salt-minion安装1$ yum install -y salt-minion 配置&amp;启动master配置1$ vim /etc/salt/master 修改如下：123456789#master消息发布端口 Default: 4505publish_port: 4505#工作线程数，应答和接受minion Default: 5worker_threads: 100#客户端与服务端通信的端口 Default: 4506ret_port: 4506#自动接受所有客户端auto_accept: True#启动salt-master 启动：1$ systemctl start salt-master minion配置1$ vim /etc/salt/minion 修改如下： 123456# master IP或域名master: salt-master# 客户端与服务端通信的端口。 Default: 4506master_port: 4506# id minion的唯一标示。Default: hostnameid: salt-minion1 启动：1$ systemctl start salt-minion 测试查看master的key列表1234567[root@localhost ~]# salt-key -LAccepted Keys:（接受的key）salt-minion1salt-minion2Denied Keys:（否认的key）Unaccepted Keys:（未接受的key）Rejected Keys:（拒绝的key） salt-key常用参数说明：1234567-L 列出当前所有认证，包括Accepted Keys、Denied Keys、Unaccepted Keys、Rejected Keys-a 添加某个或某些个未接受(Unaccepted Keys)认证-A 添加所有未接受(Unaccepted Keys)认证-d 删除某个或某些个已接受(Accepted Keys)认证-D 删除所有已接受(Accepted Keys)认证-y 使用该参数可免去证书操作的交互，除非对minion端很信任，一般不建议使用-h 帮助 test.ping12345$ salt &apos;*&apos; test.pingsalt-minion1:Truesalt-minion2:True]]></content>
      <categories>
        <category>运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos7搭建mesos集群]]></title>
    <url>%2F2018%2F01%2F09%2Fmesos-install%2F</url>
    <content type="text"><![CDATA[Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。 本次搭建使用centos7.1，共搭建3台master，3台slave，ip分配如下： 服务器ip hostname 说明 192.168.32.131 docker1.nd.com master 192.168.32.132 docker2.nd.com master 192.168.32.133 docker3.nd.com master 192.168.32.134 docker4.nd.com slave 192.168.32.135 docker5.nd.com slave 192.168.32.136 docker6.nd.com slave 服务器基础设置关闭防火墙12$ systemctl stop firewalld$ systemctl disable firewalld 关闭selinux12$ setenforce 0$ vi /etc/selinux/config 将第6行修改为SELINUX=permissive1234567891011# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=permissive# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected.# mls - Multi Level Security protection.SELINUXTYPE=targeted 设置hostname1$ hostnamectl set-hostname docker1.nd.com 修改host文件修改/etc/hosts文件为如下内容123456192.168.32.131 docker1.nd.com192.168.32.132 docker2.nd.com192.168.32.133 docker3.nd.com192.168.32.134 docker4.nd.com192.168.32.135 docker5.nd.com192.168.32.136 docker6.nd.com 使用scp命令复制到其他5台服务器1$ scp /etc/hosts root@docker2.nd.com:/etc/hosts 安装mesos、zookeeper包 1、分别在6台服务器上执行如下命令12$ rpm -Uvh http://repos.mesosphere.io/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm$ rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-mesosphere 2、进入3台master服务器安装mesos、marathon和zookeeper1$ yum install mesos marathon mesosphere-zookeeper -y 3、进入3台slave服务器安装mesos1$ yum install mesos -y 配置mesos、zookeeper配置zookeeper1、修改/var/lib/zookeeper/myid文件，三台master服务器，分别设置为1、2、32、修改/etc/zookeeper/conf/zoo.cfg文件，在文件末尾添加以下配置123server.1=192.168.32.131:2888:3888server.2=192.168.32.132:2888:3888server.3=192.168.32.133:2888:3888 3、启动zookeeper服务1$ systemctl start zookeeper 4、查看zookeeper服务是否已启动 1$ systemctl is-active zookeeper 配置mesos-master1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容1zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos 2、设置/etc/mesos-master/quorum文件中quorum的值，这个值要大于master数量的1/2，我们这里设置为23、停用mesos-slave1$ systemctl stop mesos-slave.service 1$ systemctl disable mesos-slave.service 4、启动mesos-master marathon12$ systemctl start mesos-master$ marathon --master zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos 正常情况下此时已经可以通过http://docker1.nd.com:5050打开mesos页面 配置mesos-slave1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容1zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos 2、停用mesos-master12$ systemctl stop mesos-master.service$ systemctl disable mesos-master.service 3、启动mesos-slave1$ systemctl start mesos-slave docker配置如需要在slave上运行docker，除docker自身安装配置外，还需要做如下设置1、指定使用docker容器化1$ echo &apos;docker,mesos&apos; &gt; /etc/mesos-slave/containerizers 2、考虑到拉取容器镜像等的操作，适当增加timeout的时间1$ echo &apos;5mins&apos; &gt; /etc/mesos-slave/executor_registration_timeout 3、重启mesos-slave以使上面配置生效1$ systemctl restart mesos-slave 注意事项在测试环境中我们可以关闭防火墙，但在生产环境中，为了安全考虑，还是需要将防火墙开启此时应注意，master需要向agent的所有ip开放5050端口，所有agent需要向master开放5051端口并且为了用户可以访问mesos的前端页面，master需向用户ip开放5050端口，所有agent也需要向用户ip开放5051端口，否则会出现agent信息无法查看，task日志无法查看等问题]]></content>
      <categories>
        <category>运维</category>
      </categories>
  </entry>
</search>
