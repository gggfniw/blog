<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《dubbo源码深度解析》之config配置层]]></title>
    <url>%2F2018%2F05%2F15%2Fdubbo-config%2F</url>
    <content type="text"><![CDATA[config层是dubbo架构中的第二层，第一层的service即是我们的业务层，因此我们从config层开始看，config层在官网中的解释如下: 配置层：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类 spring自定义标签我们在通过xml文件配置dubbo时，使用了dubbo给我们提供的spring自定义标签，入口类在dubbo-config包下的DubboNamespaceHandler文件：1234567891011121314151617181920public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123; static &#123; Version.checkDuplicate(DubboNamespaceHandler.class); &#125; public void init() &#123; registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true)); registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true)); registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true)); registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true)); registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true)); registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true)); registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true)); registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true)); registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false)); registerBeanDefinitionParser(&quot;annotation&quot;, new DubboBeanDefinitionParser(AnnotationBean.class, true)); &#125;&#125; 我们在xml中配置的标签，将会转换为如ApplicationConfig、RegistryConfig、ProtocolConfig、ServiceBean等一个个bean，xml到bean的过程，不是重点，我们稍微看下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576private static BeanDefinition parse(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, boolean required) &#123; RootBeanDefinition beanDefinition = new RootBeanDefinition(); beanDefinition.setBeanClass(beanClass); beanDefinition.setLazyInit(false); String id = element.getAttribute(&quot;id&quot;); if ((id == null || id.length() == 0) &amp;&amp; required) &#123; String generatedBeanName = element.getAttribute(&quot;name&quot;); if (generatedBeanName == null || generatedBeanName.length() == 0) &#123; if (ProtocolConfig.class.equals(beanClass)) &#123; generatedBeanName = &quot;dubbo&quot;; &#125; else &#123; generatedBeanName = element.getAttribute(&quot;interface&quot;); &#125; &#125; if (generatedBeanName == null || generatedBeanName.length() == 0) &#123; generatedBeanName = beanClass.getName(); &#125; id = generatedBeanName; int counter = 2; while (parserContext.getRegistry().containsBeanDefinition(id)) &#123; id = generatedBeanName + (counter++); &#125; &#125; if (id != null &amp;&amp; id.length() &gt; 0) &#123; if (parserContext.getRegistry().containsBeanDefinition(id)) &#123; throw new IllegalStateException(&quot;Duplicate spring bean id &quot; + id); &#125; parserContext.getRegistry().registerBeanDefinition(id, beanDefinition); beanDefinition.getPropertyValues().addPropertyValue(&quot;id&quot;, id); &#125; if (ProtocolConfig.class.equals(beanClass)) &#123; for (String name : parserContext.getRegistry().getBeanDefinitionNames()) &#123; BeanDefinition definition = parserContext.getRegistry().getBeanDefinition(name); PropertyValue property = definition.getPropertyValues().getPropertyValue(&quot;protocol&quot;); if (property != null) &#123; Object value = property.getValue(); if (value instanceof ProtocolConfig &amp;&amp; id.equals(((ProtocolConfig) value).getName())) &#123; definition.getPropertyValues().addPropertyValue(&quot;protocol&quot;, new RuntimeBeanReference(id)); &#125; &#125; &#125; &#125; else if (ServiceBean.class.equals(beanClass)) &#123; String className = element.getAttribute(&quot;class&quot;); if (className != null &amp;&amp; className.length() &gt; 0) &#123; RootBeanDefinition classDefinition = new RootBeanDefinition(); classDefinition.setBeanClass(ReflectUtils.forName(className)); classDefinition.setLazyInit(false); parseProperties(element.getChildNodes(), classDefinition); beanDefinition.getPropertyValues().addPropertyValue(&quot;ref&quot;, new BeanDefinitionHolder(classDefinition, id + &quot;Impl&quot;)); &#125; &#125; else if (ProviderConfig.class.equals(beanClass)) &#123; parseNested(element, parserContext, ServiceBean.class, true, &quot;service&quot;, &quot;provider&quot;, id, beanDefinition); &#125; else if (ConsumerConfig.class.equals(beanClass)) &#123; parseNested(element, parserContext, ReferenceBean.class, false, &quot;reference&quot;, &quot;consumer&quot;, id, beanDefinition); &#125; Set&lt;String&gt; props = new HashSet&lt;String&gt;(); ManagedMap parameters = null; //省略部分代码 NamedNodeMap attributes = element.getAttributes(); int len = attributes.getLength(); for (int i = 0; i &lt; len; i++) &#123; Node node = attributes.item(i); String name = node.getLocalName(); if (!props.contains(name)) &#123; if (parameters == null) &#123; parameters = new ManagedMap(); &#125; String value = node.getNodeValue(); parameters.put(name, new TypedStringValue(value, String.class)); &#125; &#125; if (parameters != null) &#123; beanDefinition.getPropertyValues().addPropertyValue(&quot;parameters&quot;, parameters); &#125; return beanDefinition;&#125; 构造BeanDefinition的过程并没有什么特殊，但由于dubbo把所有的解析过程都写在这个方法里，看上去难免杂乱一些，与其看BeanDefinition的解析过程，还不如看最终解析出了什么东西，在此之前先附上xml配置文件：1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name=&quot;demo-provider&quot;/&gt; &lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=&quot;192.168.32.145:2181&quot; protocol=&quot;zookeeper&quot;/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;bean id=&quot;demoService&quot; class=&quot;com.alibaba.dubbo.demo.provider.DemoServiceImpl&quot;/&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;dubbo:service interface=&quot;com.alibaba.dubbo.demo.DemoService&quot; ref=&quot;demoService&quot;/&gt;&lt;/beans&gt; ApplicationConfig:123456789101112name = &quot;demo-provider&quot;version = nullowner = nullorganization = nullarchitecture = nullenvironment = nullcompiler = nulllogger = nullregistries = nullmonitor = nullisDefault = nullid = &quot;demo-provider&quot; //自动把id设置为和name一样 RegistryConfig:12345678910111213141516171819202122address = &quot;192.168.32.145:2181&quot;username = nullpassword = nullport = nullprotocol = &quot;zookeeper&quot;transporter = nullserver = nullclient = nullcluster = nullgroup = nullversion = nulltimeout = nullsession = nullfile = nullwait = nullcheck = nulldynamic = nullregister = nullsubscribe = nullparameters = nullisDefault = nullid = &quot;com.alibaba.dubbo.config.RegistryConfig&quot; //自动设置了id ProtocolConfig：1234567891011121314151617181920212223242526272829name = &quot;dubbo&quot;host = nullport = &#123;Integer@1956&#125; &quot;20880&quot;contextpath = nullthreadpool = nullthreads = nulliothreads = nullqueues = nullaccepts = nullcodec = nullserialization = nullcharset = nullpayload = nullbuffer = nullheartbeat = nullaccesslog = nulltransporter = nullexchanger = nulldispatcher = nullnetworker = nullserver = nullclient = nulltelnet = nullprompt = nullstatus = nullregister = nullparameters = nullisDefault = nullid = &quot;dubbo&quot; //自动把id设置为和name一样 可以看到基本上就和我们在配置文件中看到的一样，当然，这是在最简单的配置下，如果有配置多注册中心，多protocol，配置method等，解析过程就稍微复杂一些。 ServiceConfig代码的入口在ServiceBean这个类中，这里有两个关键方法：afterPropertiesSet()和onApplicationEvent()，在初始化这个Bean的时候会调用afterPropertiesSet()方法，这个方法的主要作用，就是获取ApplicationConfig、RegistryConfig、ProtocolConfig等对象，注入到ServiceBean当中，已供ServiceBean在后续的服务暴露过程中使用。onApplicationEvent()方法会在spring初始化完成后调用：12345678910public void onApplicationEvent(ApplicationEvent event) &#123; if (ContextRefreshedEvent.class.getName().equals(event.getClass().getName())) &#123; if (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123; if (logger.isInfoEnabled()) &#123; logger.info(&quot;The service ready on spring started. service: &quot; + getInterface()); &#125; export(); &#125; &#125; &#125; export()方法在其父类ServiceConfig中，这个方法就做一些简单的检查后跳到doExport()方法，在这个方法中，除了一些检查设置外，还有一个填充默认配置的方法：appendProperties(this)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566protected static void appendProperties(AbstractConfig config) &#123; if (config == null) &#123; return; &#125; String prefix = &quot;dubbo.&quot; + getTagName(config.getClass()) + &quot;.&quot;; Method[] methods = config.getClass().getMethods(); for (Method method : methods) &#123; try &#123; String name = method.getName(); if (name.length() &gt; 3 &amp;&amp; name.startsWith(&quot;set&quot;) &amp;&amp; Modifier.isPublic(method.getModifiers()) &amp;&amp; method.getParameterTypes().length == 1 &amp;&amp; isPrimitive(method.getParameterTypes()[0])) &#123; String property = StringUtils.camelToSplitName(name.substring(3, 4).toLowerCase() + name.substring(4), &quot;-&quot;); String value = null; if (config.getId() != null &amp;&amp; config.getId().length() &gt; 0) &#123; String pn = prefix + config.getId() + &quot;.&quot; + property; value = System.getProperty(pn); if (!StringUtils.isBlank(value)) &#123; logger.info(&quot;Use System Property &quot; + pn + &quot; to config dubbo&quot;); &#125; &#125; if (value == null || value.length() == 0) &#123; String pn = prefix + property; value = System.getProperty(pn); if (!StringUtils.isBlank(value)) &#123; logger.info(&quot;Use System Property &quot; + pn + &quot; to config dubbo&quot;); &#125; &#125; if (value == null || value.length() == 0) &#123; Method getter; try &#123; getter = config.getClass().getMethod(&quot;get&quot; + name.substring(3), new Class&lt;?&gt;[0]); &#125; catch (NoSuchMethodException e) &#123; try &#123; getter = config.getClass().getMethod(&quot;is&quot; + name.substring(3), new Class&lt;?&gt;[0]); &#125; catch (NoSuchMethodException e2) &#123; getter = null; &#125; &#125; if (getter != null) &#123; if (getter.invoke(config, new Object[0]) == null) &#123; if (config.getId() != null &amp;&amp; config.getId().length() &gt; 0) &#123; value = ConfigUtils.getProperty(prefix + config.getId() + &quot;.&quot; + property); &#125; if (value == null || value.length() == 0) &#123; value = ConfigUtils.getProperty(prefix + property); &#125; if (value == null || value.length() == 0) &#123; String legacyKey = legacyProperties.get(prefix + property); if (legacyKey != null &amp;&amp; legacyKey.length() &gt; 0) &#123; value = convertLegacyValue(legacyKey, ConfigUtils.getProperty(legacyKey)); &#125; &#125; &#125; &#125; &#125; if (value != null &amp;&amp; value.length() &gt; 0) &#123; method.invoke(config, new Object[]&#123;convertPrimitive(method.getParameterTypes()[0], value)&#125;); &#125; &#125; &#125; catch (Exception e) &#123; logger.error(e.getMessage(), e); &#125; &#125; &#125; 这个方法的主要作用，是从系统的环境变量、dubbo.properties中获取配置，注入到ApplicationConfig、RegistryConfig、ProtocolConfig等对象中，这也是dubbo默认参数的实现方式，可以将一些公共的配置，写在dubbo.properties中，dubbo会帮我们注入，由于我们没有使用dubbo.properties配置，因此这一轮检查和注入过后，配置没有发生变化，之后就到了正在开始暴露服务：doExportUrls():123456private void doExportUrls() &#123; List&lt;URL&gt; registryURLs = loadRegistries(true); for (ProtocolConfig protocolConfig : protocols) &#123; doExportUrlsFor1Protocol(protocolConfig, registryURLs); &#125; &#125; 这个方法首先进行了url的组装：loadRegistries(boolean provider)：123456789101112131415161718192021222324252627282930313233343536373839404142434445protected List&lt;URL&gt; loadRegistries(boolean provider) &#123; checkRegistry(); List&lt;URL&gt; registryList = new ArrayList&lt;URL&gt;(); if (registries != null &amp;&amp; registries.size() &gt; 0) &#123; for (RegistryConfig config : registries) &#123; String address = config.getAddress(); if (address == null || address.length() == 0) &#123; address = Constants.ANYHOST_VALUE; &#125; String sysaddress = System.getProperty(&quot;dubbo.registry.address&quot;); if (sysaddress != null &amp;&amp; sysaddress.length() &gt; 0) &#123; address = sysaddress; &#125; if (address != null &amp;&amp; address.length() &gt; 0 &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); appendParameters(map, application); appendParameters(map, config); map.put(&quot;path&quot;, RegistryService.class.getName()); map.put(&quot;dubbo&quot;, Version.getVersion()); map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis())); if (ConfigUtils.getPid() &gt; 0) &#123; map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid())); &#125; if (!map.containsKey(&quot;protocol&quot;)) &#123; if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(&quot;remote&quot;)) &#123; map.put(&quot;protocol&quot;, &quot;remote&quot;); &#125; else &#123; map.put(&quot;protocol&quot;, &quot;dubbo&quot;); &#125; &#125; List&lt;URL&gt; urls = UrlUtils.parseURLs(address, map); for (URL url : urls) &#123; url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol()); url = url.setProtocol(Constants.REGISTRY_PROTOCOL); if ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true)) || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, true))) &#123; registryList.add(url); &#125; &#125; &#125; &#125; &#125; return registryList; &#125; 这个方法分为2部分，第一部分组装map和address，第二部分根据map和address生成url，在第一部分中有个比较重要的方法：appendParameters()：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465protected static void appendParameters(Map&lt;String, String&gt; parameters, Object config, String prefix) &#123; if (config == null) &#123; return; &#125; Method[] methods = config.getClass().getMethods(); for (Method method : methods) &#123; try &#123; String name = method.getName(); if ((name.startsWith(&quot;get&quot;) || name.startsWith(&quot;is&quot;)) &amp;&amp; !&quot;getClass&quot;.equals(name) &amp;&amp; Modifier.isPublic(method.getModifiers()) &amp;&amp; method.getParameterTypes().length == 0 &amp;&amp; isPrimitive(method.getReturnType())) &#123; Parameter parameter = method.getAnnotation(Parameter.class); if (method.getReturnType() == Object.class || parameter != null &amp;&amp; parameter.excluded()) &#123; continue; &#125; int i = name.startsWith(&quot;get&quot;) ? 3 : 2; String prop = StringUtils.camelToSplitName(name.substring(i, i + 1).toLowerCase() + name.substring(i + 1), &quot;.&quot;); String key; if (parameter != null &amp;&amp; parameter.key() != null &amp;&amp; parameter.key().length() &gt; 0) &#123; key = parameter.key(); &#125; else &#123; key = prop; &#125; Object value = method.invoke(config, new Object[0]); String str = String.valueOf(value).trim(); if (value != null &amp;&amp; str.length() &gt; 0) &#123; if (parameter != null &amp;&amp; parameter.escaped()) &#123; str = URL.encode(str); &#125; if (parameter != null &amp;&amp; parameter.append()) &#123; String pre = (String) parameters.get(Constants.DEFAULT_KEY + &quot;.&quot; + key); if (pre != null &amp;&amp; pre.length() &gt; 0) &#123; str = pre + &quot;,&quot; + str; &#125; pre = (String) parameters.get(key); if (pre != null &amp;&amp; pre.length() &gt; 0) &#123; str = pre + &quot;,&quot; + str; &#125; &#125; if (prefix != null &amp;&amp; prefix.length() &gt; 0) &#123; key = prefix + &quot;.&quot; + key; &#125; parameters.put(key, str); &#125; else if (parameter != null &amp;&amp; parameter.required()) &#123; throw new IllegalStateException(config.getClass().getSimpleName() + &quot;.&quot; + key + &quot; == null&quot;); &#125; &#125; else if (&quot;getParameters&quot;.equals(name) &amp;&amp; Modifier.isPublic(method.getModifiers()) &amp;&amp; method.getParameterTypes().length == 0 &amp;&amp; method.getReturnType() == Map.class) &#123; Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) method.invoke(config, new Object[0]); if (map != null &amp;&amp; map.size() &gt; 0) &#123; String pre = (prefix != null &amp;&amp; prefix.length() &gt; 0 ? prefix + &quot;.&quot; : &quot;&quot;); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; parameters.put(pre + entry.getKey().replace(&apos;-&apos;, &apos;.&apos;), entry.getValue()); &#125; &#125; &#125; &#125; catch (Exception e) &#123; throw new IllegalStateException(e.getMessage(), e); &#125; &#125; &#125; 这个方法的作用如下：遍历传进来的config对象的所有方法，如果是get或is开头，就调用该方法，如果返回值不为空，就存入map中，存入的key跟该方法是否有@Parameter注解有关，如果有，则以这个注解指定的key作为key值。 最终收集到的map如下：1234560 = &#123;HashMap$Entry@1722&#125; &quot;timestamp&quot; -&gt; &quot;1526381630841&quot;1 = &#123;HashMap$Entry@1723&#125; &quot;dubbo&quot; -&gt; &quot;2.0.0&quot;2 = &#123;HashMap$Entry@1724&#125; &quot;protocol&quot; -&gt; &quot;zookeeper&quot;3 = &#123;HashMap$Entry@1725&#125; &quot;application&quot; -&gt; &quot;demo-provider&quot;4 = &#123;HashMap$Entry@1726&#125; &quot;path&quot; -&gt; &quot;com.alibaba.dubbo.registry.RegistryService&quot;5 = &#123;HashMap$Entry@1727&#125; &quot;pid&quot; -&gt; &quot;1448&quot; 然后调用UrlUtils.parseURLs(address, map)方法组装url，这个方法就是一些拼装逻辑，与其去看它如何拼装，不如看下最终拼装的结果： 1zookeeper://192.168.32.145:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.0&amp;pid=1448&amp;registry=zookeeper&amp;timestamp=1526381630841 url拼装完成后，调用doExportUrlsFor1Protocol(protocolConfig, registryURLs)方法，这个方法是Config层的最后一个方法，这个方法过后将转到Registry层,由于这个方法太长，因此这里分为为2个部分进行说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123; //省略代码 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); if (anyhost) &#123; map.put(Constants.ANYHOST_KEY, &quot;true&quot;); &#125; map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE); map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion()); map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis())); if (ConfigUtils.getPid() &gt; 0) &#123; map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid())); &#125; appendParameters(map, application); appendParameters(map, module); appendParameters(map, provider, Constants.DEFAULT_KEY); appendParameters(map, protocolConfig); appendParameters(map, this); if (ProtocolUtils.isGeneric(generic)) &#123; map.put(&quot;generic&quot;, generic); map.put(&quot;methods&quot;, Constants.ANY_VALUE); &#125; else &#123; String revision = Version.getVersion(interfaceClass, version); if (revision != null &amp;&amp; revision.length() &gt; 0) &#123; map.put(&quot;revision&quot;, revision); &#125; String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames(); if (methods.length == 0) &#123; logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName()); map.put(&quot;methods&quot;, Constants.ANY_VALUE); &#125; else &#123; map.put(&quot;methods&quot;, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;)); &#125; &#125; if (!ConfigUtils.isEmpty(token)) &#123; if (ConfigUtils.isDefault(token)) &#123; map.put(&quot;token&quot;, UUID.randomUUID().toString()); &#125; else &#123; map.put(&quot;token&quot;, token); &#125; &#125; if (&quot;injvm&quot;.equals(protocolConfig.getName())) &#123; protocolConfig.setRegister(false); map.put(&quot;notify&quot;, &quot;false&quot;); &#125; //省略第二部分代码&#125; 这里的作用跟上面的方法一样，从各个config中，获取信息组装到map中，最后的结果如下：1234567890 = &#123;HashMap$Entry@2469&#125; &quot;methods&quot; -&gt; &quot;sayHello&quot;1 = &#123;HashMap$Entry@2204&#125; &quot;generic&quot; -&gt; &quot;false&quot;2 = &#123;HashMap$Entry@2205&#125; &quot;timestamp&quot; -&gt; &quot;1526382333491&quot;3 = &#123;HashMap$Entry@2206&#125; &quot;dubbo&quot; -&gt; &quot;2.0.0&quot;4 = &#123;HashMap$Entry@2207&#125; &quot;application&quot; -&gt; &quot;demo-provider&quot;5 = &#123;HashMap$Entry@2208&#125; &quot;side&quot; -&gt; &quot;provider&quot;6 = &#123;HashMap$Entry@2209&#125; &quot;pid&quot; -&gt; &quot;1448&quot;7 = &#123;HashMap$Entry@2210&#125; &quot;interface&quot; -&gt; &quot;com.alibaba.dubbo.demo.DemoService&quot;8 = &#123;HashMap$Entry@2211&#125; &quot;anyhost&quot; -&gt; &quot;true&quot; 第二部分代码，根据这个map，组装url，然后进行export：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123; //省略第一部分代码 // 导出服务 String contextPath = protocolConfig.getContextpath(); if ((contextPath == null || contextPath.length() == 0) &amp;&amp; provider != null) &#123; contextPath = provider.getContextpath(); &#125; URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? &quot;&quot; : contextPath + &quot;/&quot;) + path, map); if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class) .hasExtension(url.getProtocol())) &#123; url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class) .getExtension(url.getProtocol()).getConfigurator(url).configure(url); &#125; String scope = url.getParameter(Constants.SCOPE_KEY); //配置为none不暴露 if (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) &#123; //配置不是remote的情况下做本地暴露 (配置为remote，则表示只暴露远程服务) if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123; exportLocal(url); &#125; //如果配置不是local则暴露为远程服务.(配置为local，则表示只暴露本地服务) if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) &#123; if (logger.isInfoEnabled()) &#123; logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() + &quot; to url &quot; + url); &#125; if (registryURLs != null &amp;&amp; registryURLs.size() &gt; 0 &amp;&amp; url.getParameter(&quot;register&quot;, true)) &#123; for (URL registryURL : registryURLs) &#123; url = url.addParameterIfAbsent(&quot;dynamic&quot;, registryURL.getParameter(&quot;dynamic&quot;)); URL monitorUrl = loadMonitor(registryURL); if (monitorUrl != null) &#123; url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString()); &#125; if (logger.isInfoEnabled()) &#123; logger.info(&quot;Register dubbo service &quot; + interfaceClass.getName() + &quot; url &quot; + url + &quot; to registry &quot; + registryURL); &#125; Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString())); Exporter&lt;?&gt; exporter = protocol.export(invoker); exporters.add(exporter); &#125; &#125; else &#123; Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url); Exporter&lt;?&gt; exporter = protocol.export(invoker); exporters.add(exporter); &#125; &#125; &#125; this.urls.add(url);&#125; 首先进行了一次url组装，组装结果为：1dubbo://192.168.252.169:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.0&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=1448&amp;side=provider&amp;timestamp=1526382333491 然后判断url中的scope属性的值，如果是remote，则值进行远程暴露，如果是local，则只进行本地暴露，本地暴露和远程暴露的逻辑差不多，首先是获取一个Invoker，然后进行export，export完成后存入List]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《dubbo源码深度解析》之dubbo扩展点加载机制]]></title>
    <url>%2F2018%2F05%2F10%2Fdubbo-spi%2F</url>
    <content type="text"><![CDATA[dubbo的扩展点加载机制是dubbo的内核，是贯穿整个dubbo的设计思想，在dubbo的官方文档中，也是将扩展点加载机制放在第一篇幅，要想看懂dubbo的源码，首先要看懂dubbo的扩展点加载机制。本章会从java spi的例子开始，到dubbo spi的例子，然后到分析源码，帮助读者看懂dubbo的扩展点加载机制。 简单的例子java spi接口类123public interface Operate &#123; double count(double c1,double c2);&#125; 实现类112345678import com.example.java_spi.spi.Operate;public class AddOperate implements Operate &#123; public double count(double c1,double c2) &#123; return c1 + c2; &#125;&#125; 实现类21234567import com.example.java_spi.spi.Operate;public class DelOperate implements Operate &#123; public double count(double c1,double c2) &#123; return c1 - c2; &#125;&#125; META-INF文件12com.example.java_spi.impl.AddOperatecom.example.java_spi.impl.DelOperate 文件路径：META-INF/services/com.example.java_spi.spi.Operate 测试类123456789101112import com.example.java_spi.spi.Operate;import java.util.ServiceLoader;public class Main &#123; public static void main(String[] args) &#123; ServiceLoader&lt;Operate&gt; loaders = ServiceLoader.load(Operate.class); for (Operate d : loaders) &#123; double res = d.count(2,1); System.out.println(res); &#125; &#125;&#125; 执行结果123.01.0 可以看到java spi会加载所有的扩展点，且功能比较简单，没有apo ioc等功能 dubbo spi接口类123456789import com.alibaba.dubbo.common.URL;import com.alibaba.dubbo.common.extension.Adaptive;import com.alibaba.dubbo.common.extension.SPI;@SPIpublic interface Operate &#123; @Adaptive double count(URL url,double c1,double c2);&#125; 实现类1123456789import com.alibaba.dubbo.common.URL;import com.example.dubbo_spi.spi.Operate;public class AddOperate implements Operate &#123; public double count(URL url,double c1,double c2) &#123; return c1 + c2; &#125;&#125; 实现类212345678import com.alibaba.dubbo.common.URL;import com.example.dubbo_spi.spi.Operate;public class DelOperate implements Operate &#123; public double count(URL url,double c1,double c2) &#123; return c1 - c2; &#125;&#125; META-INF文件12add=com.example.dubbo_spi.impl.AddOperatedel=com.example.dubbo_spi.impl.DelOperate 文件路径：META-INF/dubbo/com.example.dubbo_spi.spi.Operate 测试类123456789101112131415161718import com.alibaba.dubbo.common.URL;import com.alibaba.dubbo.common.extension.ExtensionLoader;import com.example.dubbo_spi.spi.Operate;import java.util.HashMap;import java.util.Map;public class Main&#123; public static void main( String[] args ) &#123; Operate p = ExtensionLoader.getExtensionLoader(Operate.class).getAdaptiveExtension(); Map paramMap = new HashMap(); paramMap.put(&quot;operate&quot;,&quot;add&quot;); URL url = new URL(&quot;&quot;,&quot;&quot;,20880,paramMap); double res = p.count(url,2,1); System.out.println(res); &#125;&#125; 执行结果13.0 解析这个是dubbo spi最简单的一个例子，但也可以看出要比java 的spi要复杂的多。 首先从接口类看，类上要加一个注解：@SPI，否则会报错：1Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Extension type(interface com.example.dubbo_spi.spi.Operate) is not extension, because WITHOUT @SPI Annotation! 我们会在后面的源码解析中，分析出这些报错的原因及代码位置。 第二、接口方法至少一个要有@Adaptive注解，否则会报错：1Exception in thread &quot;main&quot; java.lang.IllegalStateException: fail to create adaptive instance: java.lang.IllegalStateException: Can not create adaptive extenstion interface com.example.dubbo_spi.spi.Operate, cause: No adaptive method on extension com.example.dubbo_spi.spi.Operate, refuse to create the adaptive class! 第三、注明@Adaptive的方法的参数中，必须要有URL类型的参数，或者参数的属性中包含URL类型的属性，否则会报错：1Exception in thread &quot;main&quot; java.lang.IllegalStateException: fail to create adaptive instance: java.lang.IllegalStateException: Can not create adaptive extenstion interface com.example.dubbo_spi.spi.Operate, cause: fail to create adative class for interface com.example.dubbo_spi.spi.Operate: not found url parameter or url attribute in parameters of method count 第四、META-INF文件中要指定key，如add=com.xxx.AddOperate,不指定不会报错，但会生成一个默认的key，比如AddOperate的默认key就是add，这个key，将会在url中用到。 第五、测试类中的URL对象要有paramMap，并且这个map中要包含一个key，就是接口类的方法中，有注明@Adaptive的方法，这个注解有个属性，如果指定，这这里的url的key，就是指定的这个，如果不指定，则这里url的key就是接口类的类名（驼峰转”.”,如SayHello的默认key是“say.hello”），本案例中没有指定，因此这里的key，应该是operate，因此需指定operate及其值，否则会报错：1Exception in thread &quot;main&quot; java.lang.IllegalStateException: Fail to get extension(com.example.dubbo_spi.spi.Operate) name from url() use keys([operate]) 到这里会难免有疑问，dubbo为什么要指定这么多奇奇怪怪的规则，我们来看测试类中Operate p的实际对象，通过源码分析可以取到代码：123456789101112package com.example.dubbo_spi.spi; import com.alibaba.dubbo.common.extension.ExtensionLoader;public class Operate$Adpative implements com.example.dubbo_spi.spi.Operate &#123; public double count(com.alibaba.dubbo.common.URL arg0, double arg1, double arg2) &#123; if (arg0 == null) throw new IllegalArgumentException(&quot;url == null&quot;); com.alibaba.dubbo.common.URL url = arg0; String extName = url.getParameter(&quot;operate&quot;); if(extName == null) throw new IllegalStateException(&quot;Fail to get extension(com.example.dubbo_spi.spi.Operate) name from url(&quot; + url.toString() + &quot;) use keys([operate])&quot;); com.example.dubbo_spi.spi.Operate extension = (com.example.dubbo_spi.spi.Operate)ExtensionLoader.getExtensionLoader(com.example.dubbo_spi.spi.Operate.class).getExtension(extName); return extension.count(arg0, arg1, arg2); &#125;&#125; 主要代码是：1ExtensionLoader.getExtensionLoader(com.example.dubbo_spi.spi.Operate.class).getExtension(extName); 这里的extName就是add，通过这行代码取到的对象就是AddOperate的实例，到这里完成了最简单的dubbo spi的调用。 dubbo spi之aopdubbo spi可以实现类似spring的aop功能，我们需要先创建一个OperateWrapper类，代码如下：12345678910111213141516171819import com.alibaba.dubbo.common.URL;import com.example.dubbo_spi.spi.Operate;public class OperateWrapper implements Operate &#123; private Operate operate; public OperateWrapper(Operate operate) &#123; this.operate = operate; &#125; public double count(URL url,double c1,double c2) &#123; System.out.println(&quot;==before==&quot;); double result = this.operate.count(url,c1,c2); System.out.println(result); System.out.println(&quot;==after==&quot;); return result; &#125;&#125; 执行结果如下：123==before==3.0==after== OperateWrapper也需要实现Operate接口，并且在构造方法中，需要有Operate这个接口参数，这样的类，dubbo的扩展点加载机制会认为它是一个代理类，用于实现aop的功能，这种包装类可以有多个，会按照在META-INF中的顺序排下来 dubbo spi之ioc首先我们需要如法炮制创建一个SayHello接口123456789import com.alibaba.dubbo.common.URL;import com.alibaba.dubbo.common.extension.Adaptive;import com.alibaba.dubbo.common.extension.SPI;@SPIpublic interface SayHello &#123; @Adaptive void say(URL url);&#125; 然后再创建一个实现类：12345678import com.alibaba.dubbo.common.URL;import com.example.dubbo_spi.spi.SayHello;public class ChineseSayHello implements SayHello &#123; public void say(URL url) &#123; System.out.println(&quot;你好！&quot;); &#125;&#125; 添加META-INF文件1chinese=com.example.dubbo_spi.impl.ChineseSayHello 然后修改AddOperate代码如下：123456789101112131415161718192021import com.alibaba.dubbo.common.URL;import com.example.dubbo_spi.spi.Operate;import com.example.dubbo_spi.spi.SayHello;public class AddOperate implements Operate &#123; private SayHello sayHello; public SayHello getSayHello() &#123; return sayHello; &#125; public void setSayHello(SayHello sayHello) &#123; this.sayHello = sayHello; &#125; public double count(URL url, double c1, double c2) &#123; sayHello.say(url); return c1 + c2; &#125;&#125; 最后在测试类的paramMap中加上say.hello的key和value1paramMap.put(&quot;say.hello&quot;,&quot;chinese&quot;); 运行结果：1234==before==你好！3.0==after== 这里的关键代码，在ExtensionLoader的injectExtension方法中123456789101112131415private T injectExtension(T instance) &#123; for (Method method : instance.getClass().getMethods()) &#123; if (method.getName().startsWith(&quot;set&quot;) &amp;&amp; method.getParameterTypes().length == 1 &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123; Class&lt;?&gt; pt = method.getParameterTypes()[0]; String property = method.getName().length() &gt; 3 ? method.getName().substring(3, 4).toLowerCase() + method.getName().substring(4) : &quot;&quot;; Object object = objectFactory.getExtension(pt, property); if (object != null) &#123; method.invoke(instance, object); &#125; &#125; &#125; return instance; &#125; 代码做了适当精简，主要逻辑是遍历目标类的方法，如果是set开头，如setSayHello，那就去找sayHello有没有这个对象，如果有，就通过set方法注入，问题是怎么找sayHello这个对象？答案是通过objectFactory的getExtension方法来找，这是个关键对象，后面会再提到，这里插播一个知识点，dubbo的自动注入，需要提供属性的set方法，否则无法注入，spring通过xml配置的属性，同样要有set方法，否则也无法注入，但spring通过@Autowired配置的属性，可以没有set方法，那spring是怎么实现的呢？答案是通过setAccessible()方法改变属性的访问标志，从而达到修改属性的目的，即注入。 源码解析代码入口在：1ExtensionLoader.getExtensionLoader(Operate.class).getAdaptiveExtension(); 进入getExtensionLoader方法：12345678public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(Class&lt;T&gt; type) &#123; ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type); if (loader == null) &#123; EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&lt;T&gt;(type)); loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type); &#125; return loader; &#125; 这里有个关键对象： ConcurrentMap]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cglib动态代理解析]]></title>
    <url>%2F2018%2F05%2F02%2Fcglib-proxy%2F</url>
    <content type="text"><![CDATA[简单的例子代码目标类123456public class HelloService &#123; public void sayHello() &#123; System.out.println(&quot;=== hello ===&quot;); &#125;&#125; 拦截器类123456789101112131415import java.lang.reflect.Method;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;public class MyMethodInterceptor implements MethodInterceptor &#123; public Object intercept(Object obj, Method method, Object[] args,MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;=== before ===&quot;); Object object = proxy.invokeSuper(obj, args); System.out.println(&quot;=== after ===&quot;); return object; &#125;&#125; 代理类1234567891011import net.sf.cglib.proxy.Enhancer;public class MyProxy&lt;T&gt; &#123; public T getProxy(Class&lt;T&gt; tClass)&#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(tClass); enhancer.setCallback(new MyMethodInterceptor()); return (T) enhancer.create(); &#125;&#125; 测试类123456789public class Main &#123; public static void main(String[] args) throws Exception &#123; MyProxy&lt;HelloService&gt; myProxy = new MyProxy(); HelloService helloService = myProxy.getProxy(HelloService.class); helloService.sayHello(); &#125;&#125; 执行结果123=== before ====== hello ====== after === 解析不同于jdk动态代理，cglib采用了继承目标类的方式来实现动态代理，因此cglib无法代理final类型的方法，相比比jdk动态代理，产生代理类，需要接口Class对象以及实现类的实例而言，cglib所需要的“原材料”更少，只需要目标类的Class对象即可实现动态代理。 源码解析代码入口就在MyProxy类的enhancer.create()方法，很明显这个方法产生出来的就是目标类的子类，但我们的代码中并没有存在目标类的子类，cglib如何new出来？这里的原理与jdk动态代理类似，都是动态产生字节码技术，不过不同于jdk动态代理直接写二进制文件，cglib底层采用asm框架来产生字节码文件，效率上笔者认为是比jdk动态代理要慢一点，但这不是关键，因为一个代理类的产生，只会经过一次这个步骤，而后成千上万次的方法调用，才是效率的关键。 来看enhancer.create()的具体步骤，经过createHelper()–&gt;super.create(key)–&gt;data.get(this)–&gt;generatedClasses.get(gen)–&gt;createEntry(key, cacheKey, v)–&gt;loader.apply(key)–&gt;gen.generate(ClassLoaderData.this)–&gt;super.generate(data)–&gt;strategy.generate(this)–&gt;transform(cg).generateClass(cw)后到达产生二进制文件的核心Enhancer类的generateClass(ClassVisitor v)方法。 这个方法采用asm动态生成字节码文件，具体如何生成，笔者认为没有必要去看具体的逻辑过程，繁琐且没有营养，我们熟悉asm的话也可以写的出来。反而是这个方法，到底生成了什么东西，值得我们关注。 动态代理类源码我们可以将上一步中取到的byte数组，写入到文件，通过反编译工具查看源码，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.lang.reflect.Method;import net.sf.cglib.core.ReflectUtils;import net.sf.cglib.proxy.Callback;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;//关键点，继承目标类public class HelloService$$EnhancerByCGLIB$$a89dc216 extends HelloService &#123; private boolean CGLIB$BOUND; private static ThreadLocal CGLIB$THREAD_CALLBACKS; private MethodInterceptor CGLIB$CALLBACK_0; private static MethodProxy CGLIB$sayHello$0$Proxy; private static Object[] CGLIB$emptyArgs; static &#123; try &#123; CGLIB$STATICHOOK2(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; static void CGLIB$STATICHOOK2() throws ClassNotFoundException &#123; CGLIB$THREAD_CALLBACKS = new ThreadLocal(); CGLIB$emptyArgs = new Object[0]; Class var0 = Class.forName(&quot;com.example.demo.java_demo.cglib.HelloService$$EnhancerByCGLIB$$a89dc216&quot;); Class var1; Method[] var10000 = ReflectUtils.findMethods(new String[]&#123;&quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;, &quot;hashCode&quot;, &quot;()I&quot;, &quot;clone&quot;, &quot;()Ljava/lang/Object;&quot;&#125;, (var1 = Class.forName(&quot;java.lang.Object&quot;)).getDeclaredMethods()); //关键代码，产生MethodProxy CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;); &#125; //拦截器类将会调用此方法 final void CGLIB$sayHello$0() &#123; super.sayHello(); &#125; //关键方法 public final void sayHello() &#123; MethodInterceptor var10000 = this.CGLIB$CALLBACK_0; if(this.CGLIB$CALLBACK_0 == null) &#123; CGLIB$BIND_CALLBACKS(this); var10000 = this.CGLIB$CALLBACK_0; &#125; if(var10000 != null) &#123; try &#123; //关键方法 var10000.intercept(this, null, CGLIB$emptyArgs, CGLIB$sayHello$0$Proxy); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125; else &#123; super.sayHello(); &#125; &#125; public HelloService$$EnhancerByCGLIB$$a89dc216() &#123; CGLIB$BIND_CALLBACKS(this); &#125; //通过这个方法注入拦截器类 public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123; CGLIB$THREAD_CALLBACKS.set(var0); &#125; //设置拦截器类 private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123; HelloService$$EnhancerByCGLIB$$a89dc216 var1 = (HelloService$$EnhancerByCGLIB$$a89dc216)var0; if(!var1.CGLIB$BOUND) &#123; var1.CGLIB$BOUND = true; Object var10000 = CGLIB$THREAD_CALLBACKS.get(); if(var10000 == null) &#123; return; &#125; var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0]; &#125; &#125;&#125; 这个源码已经做了大量的精简，但看上去仍然比jdk动态代理生成的动态代理类要复杂的多，有了这个动态代理类，我们就可以修改测试类中的代码为：12345678910111213import net.sf.cglib.proxy.Callback;public class Main &#123; public static void main(String[] args) throws Exception &#123; //设置拦截器 HelloService$$EnhancerByCGLIB$$a89dc216.CGLIB$SET_THREAD_CALLBACKS( new Callback[]&#123; new MyMethodInterceptor() &#125; ); //创建实例 HelloService helloService = new HelloService$$EnhancerByCGLIB$$a89dc216(); //调用方法 helloService.sayHello(); &#125;&#125; 先来看第一步设置拦截器，传入的拦截器将在稍后被设置到成员变量CGLIB$CALLBACK_0中，这个属性会在方法调用时发挥作用 123public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123; CGLIB$THREAD_CALLBACKS.set(var0);&#125; 1234567891011private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123; HelloService$$EnhancerByCGLIB$$a89dc216 var1 = (HelloService$$EnhancerByCGLIB$$a89dc216)var0; if(!var1.CGLIB$BOUND) &#123; var1.CGLIB$BOUND = true; Object var10000 = CGLIB$THREAD_CALLBACKS.get(); if(var10000 == null) &#123; return; &#125; var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0]; &#125; &#125; 第二步创建实例，这里有一行非常关键的代码：1CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;); 这个代码可以先忽略，等到方法执行时再看 第三步方法调用，即调用动态代理类的sayHello()方法，进而调用拦截器类的intercept方法，传入的4个参数分别为：1、动态代理类的对象本身 2、通过反射获得的method对象 3、方法参数 4、方法代理对象（关键）1var10000.intercept(this, null, CGLIB$emptyArgs, CGLIB$sayHello$0$Proxy); 代码跳到拦截器类的intercept方法中123456public Object intercept(Object obj, Method method, Object[] args,MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;=== before ===&quot;); Object object = proxy.invokeSuper(obj, args); System.out.println(&quot;=== after ===&quot;); return object;&#125; 在jdk动态代理中，也有类似的方法，但在jdk动态代理在执行目标方法时，是通过反射调用，我们知道反射调用比直接调用，效率上是要低的多，而cglib实现了自己的一套反射调用，查看MethodProxy类的init方法：12345678910private void init()&#123; CreateInfo ci = createInfo; FastClassInfo fci = new FastClassInfo(); fci.f1 = helper(ci, ci.c1); fci.f2 = helper(ci, ci.c2); fci.i1 = fci.f1.getIndex(sig1); fci.i2 = fci.f2.getIndex(sig2); fastClassInfo = fci; createInfo = null; &#125; 这里的c1，c2，sig1，sig2，即在动态代理类中传入的 1CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;); 这个方法会产生FastClassInfo对象，这个对象有4个属性，f1，f2，i1，i2，其中最主要的是f2和i2，将在稍后的调用中使用到，为了更清晰明了，我们先来看后面的代码：1return fci.f2.invoke(fci.i2, obj, args); 这行代码就是进行了代理类的方法调用，如果此时按F5进入方法，会发现代码跳到了刚刚的动态代理类的CGLIB$sayHello$0()方法，即123final void CGLIB$sayHello$0() &#123; super.sayHello(); &#125; 但f2的invoke方法，为何会调用到动态代理类的CGLIB$sayHello$0方法？这里就要看f2是如何产生的，回头看代码：1fci.f2 = helper(ci, ci.c2); helper()方法会产生一个FastClass对象，这个FastClass对象也是通过动态字节码技术产生的，产生流程跟产生动态代理类一致，通过反编译可以获得源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import com.example.demo.java_demo.cglib.HelloService..EnhancerByCGLIB..a89dc216;import java.lang.reflect.InvocationTargetException;import net.sf.cglib.core.Signature;import net.sf.cglib.proxy.Callback;import net.sf.cglib.reflect.FastClass;public class HelloService$$EnhancerByCGLIB$$a89dc216$$FastClassByCGLIB$$7d6c4fc4 extends FastClass &#123; public HelloService$$EnhancerByCGLIB$$a89dc216$$FastClassByCGLIB$$7d6c4fc4(Class var1) &#123; super(var1); &#125; public int getIndex(Signature var1) &#123; String var10000 = var1.toString(); switch(var10000.hashCode()) &#123; case -2055565910: if(var10000.equals(&quot;CGLIB$SET_THREAD_CALLBACKS([Lnet/sf/cglib/proxy/Callback;)V&quot;)) &#123; return 1; &#125; break; case -1457505897: if(var10000.equals(&quot;CGLIB$STATICHOOK2()V&quot;)) &#123; return 2; &#125; break; case 291273791: if(var10000.equals(&quot;CGLIB$sayHello$0()V&quot;)) &#123; return 3; &#125; break; case 1535311470: if(var10000.equals(&quot;sayHello()V&quot;)) &#123; return 0; &#125; break; &#125; return -1; &#125; public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException &#123; a89dc216 var10000 = (a89dc216)var2; int var10001 = var1; try &#123; switch(var10001) &#123; case 0: var10000.sayHello(); return null; case 1: a89dc216.CGLIB$SET_THREAD_CALLBACKS((Callback[])var3[0]); return null; case 2: a89dc216.CGLIB$STATICHOOK2(); return null; case 3: var10000.CGLIB$sayHello$0(); return null; &#125; &#125; catch (Throwable var4) &#123; throw new InvocationTargetException(var4); &#125; throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;); &#125;&#125; 代码同样做了精简，到这里流程差不多已经走完了，在进行f2的invoke调用时，会传入i1，i1即是通过f2的getinde方法获得的，这里的值为3，在进行invoker调用时，可以看到最终调用的是动态代理类的CGLIB$sayHello$0()方法，CGLIB$sayHello$0()方法的方法体在刚刚已经展示过，就一行代码:123final void CGLIB$sayHello$0() &#123; super.sayHello(); &#125; 至此，完成了cglib动态调用的过程完！]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jdk动态代理解析]]></title>
    <url>%2F2018%2F04%2F28%2Fjdk-proxy%2F</url>
    <content type="text"><![CDATA[简单的例子代码接口类123public interface HelloService &#123; void sayHello();&#125; 实现类123456public class HelloServiceImpl implements HelloService &#123; public void sayHello() &#123; System.out.println(&quot;hello&quot;); &#125;&#125; 代理类1234567891011121314151617181920212223242526272829import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class MyProxy &lt;T&gt;&#123; private Object target; private Class interfaceClass; public MyProxy(Object target,Class interfaceClass) &#123; super(); this.target = target; this.interfaceClass = interfaceClass; &#125; public T getProxy() &#123; return (T)Proxy.newProxyInstance(interfaceClass.getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;=== begin ===&quot;); Object result = method.invoke(target,args); System.out.println(&quot;=== end ===&quot;); return result; &#125; &#125;); &#125;&#125; 测试类123456789101112public class Main &#123; public static void main(String[] args) throws Throwable &#123; new Main().testProxy(); &#125; public void testProxy() throws Throwable &#123; HelloService userService = new HelloServiceImpl(); MyProxy&lt;HelloService&gt; myProxy = new MyProxy(userService,HelloService.class); HelloService proxy = myProxy.getProxy(); proxy.sayHello(); &#125;&#125; 运行结果123=== begin ===hello=== end === 解析关键代码在讲核心代码前先插播一个内容：ClassLoader，可以看到在匿名内部类中，有个interfaceClass.getClassLoader()的操作，interfaceClass是个Class对象，在new MyProxy是传入，唯一的作用就是获得这个对象的ClassLoader，这是由于ClassLoader的机制导致的，由不同ClassLoader加载的类，即便已经实现了目标接口的方法，也不会被认为是这个目标接口的子类，因此需要用同一个ClassLoader，才能使最终生成的代理对象，能够被强制转换成接口对象，更详细的内容请参考双亲委派模型。 接下来开始讲核心代码：1Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 这行代码将会产生一个代理类，这个类实现了HelloService的所有方法，在方法体重，调用第三个参数h，这个h即为我们上面代码中的匿名内部类123456789new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;=== begin ===&quot;); Object result = method.invoke(target,args); System.out.println(&quot;=== end ===&quot;); return result; &#125;&#125; 源码解析先来看newProxyInstance()这个方法，以下源码摘自jdk1.8，源码做了大量精简，仅保留核心代码。123456789public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)throws IllegalArgumentException &#123; //获取代理类的Class对象 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); //获取代理类的构造方法 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); //生成实例 return cons.newInstance(new Object[]&#123;h&#125;); &#125; getProxyClass0()方法也就是动态代理核心，经过各种缓存机制判断后，我们可以找到真正干活的那个方法，即ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags)，这个方法中，又调用了ProxyGenerator类的generateClassFile()方法，这个方法就是产生Class二进制文件的地方： 1234567891011121314151617181920212223private byte[] generateClassFile() &#123; this.addProxyMethod(hashCodeMethod, Object.class); this.addProxyMethod(equalsMethod, Object.class); this.addProxyMethod(toStringMethod, Object.class); //...省略代码 ByteArrayOutputStream var13 = new ByteArrayOutputStream(); DataOutputStream var14 = new DataOutputStream(var13); try &#123; var14.writeInt(-889275714); var14.writeShort(0); var14.writeShort(49); this.cp.write(var14); var14.writeShort(this.accessFlags); var14.writeShort(this.cp.getClass(dotToSlash(this.className))); var14.writeShort(this.cp.getClass(&quot;java/lang/reflect/Proxy&quot;)); var14.writeShort(this.interfaces.length); //...省略代码 return var13.toByteArray(); &#125; catch (IOException var9) &#123; throw new InternalError(&quot;unexpected I/O Exception&quot;, var9); &#125; &#125; 这个方法充斥着大量的逻辑性代码，没有什么值得看的地方，倒是这种生成Class二进制文件的方式是个亮点，笔者在看dubbo源码时，dubbo也会产生类似的动态代理类，但dubbo的方式是先生成java代码，就是 public class XXX这样，然后通过javassist变成Class文件，但jdk动态代理直接省去了生成java代码这一步，直接写二进制文件，显然这能提高效率，这里可以作为面试的一个点。 顺便介绍下Class文件的结构，java的Class文件是严格按照顺序来书写，各个属性之间没有间隔（如之类称之为间隔），通过预定义好的顺序写入和读取Class文件，以保证能够正确的读写，从上面的代码也能看出来 第一行：writeInt(-889275714) -889275714转成十六进制即为CAFEBABY，熟悉Class文件结构的同学都知道这是Java Class文件的标记，任何Class文件都是以这个开头。 第二行：writeShort(0)，即两个字节的0，转为十六进制是00 00，这两个字节目前没有意义，是Class文件中罕见的没有意义的字符 第三行：writeShort(49)，49是jdk的版本，即jdk1.5，即生成的Class文件，能被jdk1.5以上的虚拟机运行 第四行：cp.write(var14)，写入常量池，常量池包括字面量和符号引用，字面量即文本字符串，声明为final的常量，符号引用即类和接口的全限定名，方法、字段的名称和描述符等，在上面的逻辑步骤中已经解析出了所有需要的常量池 第五行：writeShort(this.accessFlags);accessFlags即类的访问标志，这里的值是17，十六进制为11，查表可知这代表 final 和 public两种访问标志。 第六行：常量池写完，后面的所有操作都是写常量池中的编号，而不会再写入具体的名称 Class文件的结构严谨而复杂，有兴趣的同学可以阅读周志明编写的深入理解java虚拟机这一书 我们可以手动调用ProxyGenerator.generateProxyClass(“$Proxy0”, HelloServiceImpl.class.getInterfaces())这个方法，得到二进制数据，将它写入磁盘，然后用反编译工具看下到底写了什么代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package com.sun.proxy;import com.example.demo.java_demo.jdk_proxy.HelloService;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements HelloService&#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; public $Proxy0(InvocationHandler paramInvocationHandler) throws &#123; super(paramInvocationHandler); &#125; public final boolean equals(Object paramObject) throws &#123; try &#123; return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void sayHello() throws &#123; try &#123; this.h.invoke(this, m3, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)this.h.invoke(this, m2, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)this.h.invoke(this, m0, null)).intValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; static &#123; try &#123; m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;); m3 = Class.forName(&quot;com.example.demo.java_demo.jdk_proxy.HelloService&quot;).getMethod(&quot;sayHello&quot;, new Class[0]); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 关键的sayHello方法，其实也是调用了this.h.invoke(this, m2, null);这个h，即我们上面写的那个匿名内部类。 完！]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java内存结构与垃圾回收]]></title>
    <url>%2F2018%2F02%2F24%2Fjvm%2F</url>
    <content type="text"><![CDATA[内存结构堆内存（线程共享）新生代新创建的对象放入新生代，由于新生代的对象，大部分是朝生夕死，为了更好的垃圾回收，大多数垃圾收集器都采用复制算法，但由于最初的复制算法，将内存一分为二，浪费了50%的内存，因此后来将新生代内存划分为1块Eden区域和两块Survivor区域，默认的比例为8：1：1 Eden新创建的对象优先放入Eden区域 SuviderSurvivor区域有两块，进行一次垃圾回收后，Eden中存活的对象，被复制到Survivor区域中 老年代长期存活的对象放入老年代 方法区（线程共享）用于存储已被加载的类信息，常量，静态变量，即使编译器编译后的代码数据等 虚拟机栈（线程独享）每个方法执行时，都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，栈帧伴随着方法的执行而入栈，随着方法的结束而出栈 本地方法栈（线程独享）功能类似于虚拟机栈，只是这部分内存由native方法使用 程序计数器（线程独享）用于记录方法执行的行号，如果执行native方法，则无法记录行号，这是内存中唯一一块不会出现OOM的区域 如何判断对象为垃圾对象引用计数法添加一个引用计数器，当对象被引用时+1，解除引用时-1，当值为0时，即为垃圾对象，但由于这种算法，无法回收相互引用的对象，因此很少jvm采用这种算法 可达性分析法从GCRoot向下搜索，所走过的路径，称之为引用链，都为有用的对象，否则即为垃圾对象 可作为GCroot的节点：全局性的引用（常量或静态类的引用）与执行上下文（栈帧中的本地变量表） 如何回收回收策略标记-清除算法当对象被确认为垃圾对象之后，就会被标记为垃圾对象，标记的位置，在对象的header中，标记清除算法的两个缺点：1、效率不高 2、空间问题，不连续，后续创建大对象时寻址困难 复制算法将堆内存分为两块区域，当创建对象时，仅仅使用其中一块区域，当进行垃圾回收时，不再是清除那些被标记为垃圾的对象，而是将没有被标记为垃圾的对象，复制到另一块内存区域，然后将原来那块区域清空，这样很好的解决了标记-清除算法的空间问题，但同时引入了一个新问题，就是内存的浪费，将一块内存分为相等的两块内存，意味着浪费了50%的空间，为此，IBM公司的一个专项研究表明，新生代内存中，98%的对象都是朝生夕死，因此不需要按照1：1来分配内存，而是将内存划分为1块较大的Eden空间和两块较小的Survivor空间，具体的比例为8：1：1，在垃圾回收时，Eden区域和其中一块Surivor区域中还存活的对象，一次性被复制到另一块Surivivor空间上，然后清理掉Eden和刚刚那块Surivivor空间，如果遇到大对象，Surivivor空间不够放时，将进行空间分配担保，将对象放入老年代 标记-整理算法复制算法更适合新生代，但对于老年代，对象存活率比较高，无法采用复制算法，因此有人想出标记-整理算法，整个过程也分为两步，标记和整理，标记过程与标记清楚算法无异，但是标记完成后并没有马上清除，而是将所有存活的对象向内存的其中一端移动，然后再清理掉另一端的内存 分代收集算法当前主流的垃圾收集器都采用此算法，但这种算法并没有特别的思想，只是针对不同的区域，进行不同的算法，比如新生代采用复制算法，老年代采用标记-清除或标记-整理算法 垃圾收集器Serial最早的垃圾收集器，使用单线程收集垃圾，收集效率低下，无法利用多核Cpu的资源，但是现在Client模式的jvm，仍然默认使用这个收集器。 Parnew是Serial的多线程版本，能充分利用多核cpu的资源，另一个重要的原因是能与CMS收集器配合使用 Cms并发标记清除垃圾收集器，能使GC产生的停顿时间减小到最小，除了枚举根节点，会产生GC停顿之外，其他的都能并发执行 G1是当今收集器最前沿的成果之一 垃圾回收回收过程分析打印垃圾回收报告1VM参数： -XX:+PrintGCDetails -verbose:gc -XX:+UseSerialGC GC日志分析1[GC (Allocation Failure) [DefNew: 69085K-&gt;8704K(78656K), 0.0203408 secs] 69085K-&gt;64309K(253440K), 0.0203707 secs] [Times: user=0.02 sys=0.02, real=0.02 secs] DefNew新生代区域名称，由垃圾收集器指定，如使用Serial收集器时，新生代的名字叫DefNew，采用Parallel收集器时，新生代的名称为PSYoungGen 69085K-&gt;8704K(78656K)69085K代表本区域GC前的内存大小，8704K代表本区域GC后的内存大小，(78656K)代表本区域总内存大小 69085K-&gt;64309K(253440K)69085K代表堆内存GC前的内存大小，64309K代表堆内存GC后的内存大小，(253440K)代表堆内存的总大小 GC停顿在枚举根节点时，不能出现对象的引用关系还在不断发生变化的情况，因此造成GC进行时，必须停止所有的线程，Sun将这件事称之为“Stop The World”，即使在号称几乎不会发生停顿的CMS（并发标记收集）收集器中，枚举根节点时也必须要停顿 内存的创建内存分配策略优先分配到edenEden区域新生代中的一块区域，也是垃圾收集器最常光顾的地方，新创建对象默认放置这个区域。 大对象直接分配到老年代由于在Eden区域中，一般使用复制算法进行垃圾清理，并且次数非常频繁，大对象在频繁但复制过程中性能低下，因此放到老年代中，gc次数相对较少，并且也并不使用复制算法，以提高性能。大对象的标准会根据内存环境自动计算得出，也可以使用-XX:PretenureSizeThreshold=10M,指定大于10Mb的对象叫大对象。 长期存活到对象分配到老年代每一次的垃圾回收之后，都会给对象的年龄+1，当年龄达到某个值当时候，即称之为长期存活，进入老年代。我们可以使用-XX:MaxTenuringThreshshold=10,指定age达到10的时候进入老年代，默认值为15 空间分配担保动态对象年龄判断并非所有对象都需要到达MaxTenuringThreshshold指定的分代年龄之后才会进入老年代，但Survivor区域中，所有相同年龄的对象内存总和，大于Survivor的一半，即会进入老年代，不受MaxTenuringThreshshold的限制 逃逸分析与栈上分配当对象仅在方法体内部使用时，由于方法当调用会创建栈帧，当调用结束就会出栈，因此将仅供该方法使用的对象，放在栈内存中，随着方法的出入栈而出入栈，而不用垃圾回收机制进行干预，可大大提高性能 虚拟机工具jps是一个命令行工具，全称是java process status，常用的命令如下： jps -l 可以显示java进程执行的主类 jps -m 可以显示程序执行所接收的参数，即main方法中的args参数 jps -v 可以显示虚拟机执行所接收的参数，如-Xms8m 常用参数-Xmx最大堆容量 -Xms最小堆容量 -Xss栈内存大小，注意是单个线程的栈内存大小 -Xmn新生代内存大小 -XX:SurvivorRatio=8新生代中，Eden区域与其中一个Surivivor区的大小比例是8：1 -XX:PertenureSizeThreshold大对象的定义，超过这个值的称之为大对象，直接放入老年代，避免在新生代中来回复制造成性能问题 -XX:MaxTenuringThreshold对象分代年龄分界线，超过这个值进入老年代，默认为15 -XX:MaxPermSize最大方法区(非堆)容量 -XX:MaxDirectMemorySize最大直接内存，如果不指定，默认与最大堆内存一致 -XX:+PrintGCDetail打印GC日志 -XX:+PrintTenuringDistribution打印对象分代年龄 HeapDumpOnOutOfMemoryError当内存溢出时打印堆栈信息]]></content>
      <categories>
        <category>jvm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos7搭建saltstack]]></title>
    <url>%2F2018%2F02%2F07%2Fsalt-install%2F</url>
    <content type="text"><![CDATA[Salt，一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯。 salt底层采用动态的连接总线, 使其可以用于编配, 远程执行, 配置管理等等. 本次搭建使用centos7.1，共搭建1台master，2台minion，ip分配如下： 服务器ip hostname 说明 192.168.32.140 salt-master master 192.168.32.141 salt-minion1 minion 192.168.32.142 salt-minion2 minion 服务器基础设置关闭防火墙12$ systemctl stop firewalld$ systemctl disable firewalld 关闭selinux12$ setenforce 0$ vi /etc/selinux/config 将第6行修改为SELINUX=permissive1234567891011# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=permissive# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected.# mls - Multi Level Security protection.SELINUXTYPE=targeted 设置hostname1$ hostnamectl set-hostname salt-master 修改host文件修改/etc/hosts文件为如下内容123192.168.32.140 salt-master192.168.32.141 salt-minion1192.168.32.142 salt-minion2 使用scp命令复制到其他2台服务器1$ scp /etc/hosts root@salt-minion1:/etc/hosts 环境准备，依赖解决分别为三台机器添加阿里云epel源123$ mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup$ mv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup$ wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 解决依赖关系，不然会报python依赖错误 1234$ yum clean expire-cache$ yum upgrade$ yum -y install epel-release$ yum install zeromq3 m2crypto python-crypto python-jinja2 python-msgpack python-yaml python-zmq -y 开始安装salt-master安装1$ yum install -y salt-master salt-minion安装1$ yum install -y salt-minion 配置&amp;启动master配置1$ vim /etc/salt/master 修改如下：123456789#master消息发布端口 Default: 4505publish_port: 4505#工作线程数，应答和接受minion Default: 5worker_threads: 100#客户端与服务端通信的端口 Default: 4506ret_port: 4506#自动接受所有客户端auto_accept: True#启动salt-master 启动：1$ systemctl start salt-master minion配置1$ vim /etc/salt/minion 修改如下： 123456# master IP或域名master: salt-master# 客户端与服务端通信的端口。 Default: 4506master_port: 4506# id minion的唯一标示。Default: hostnameid: salt-minion1 启动：1$ systemctl start salt-minion 测试查看master的key列表1234567[root@localhost ~]# salt-key -LAccepted Keys:（接受的key）salt-minion1salt-minion2Denied Keys:（否认的key）Unaccepted Keys:（未接受的key）Rejected Keys:（拒绝的key） salt-key常用参数说明：1234567-L 列出当前所有认证，包括Accepted Keys、Denied Keys、Unaccepted Keys、Rejected Keys-a 添加某个或某些个未接受(Unaccepted Keys)认证-A 添加所有未接受(Unaccepted Keys)认证-d 删除某个或某些个已接受(Accepted Keys)认证-D 删除所有已接受(Accepted Keys)认证-y 使用该参数可免去证书操作的交互，除非对minion端很信任，一般不建议使用-h 帮助 test.ping12345$ salt &apos;*&apos; test.pingsalt-minion1:Truesalt-minion2:True]]></content>
      <categories>
        <category>运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos7搭建mesos集群]]></title>
    <url>%2F2018%2F01%2F09%2Fmesos-install%2F</url>
    <content type="text"><![CDATA[Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。 本次搭建使用centos7.1，共搭建3台master，3台slave，ip分配如下： 服务器ip hostname 说明 192.168.32.131 docker1.nd.com master 192.168.32.132 docker2.nd.com master 192.168.32.133 docker3.nd.com master 192.168.32.134 docker4.nd.com slave 192.168.32.135 docker5.nd.com slave 192.168.32.136 docker6.nd.com slave 服务器基础设置关闭防火墙12$ systemctl stop firewalld$ systemctl disable firewalld 关闭selinux12$ setenforce 0$ vi /etc/selinux/config 将第6行修改为SELINUX=permissive1234567891011# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=permissive# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected.# mls - Multi Level Security protection.SELINUXTYPE=targeted 设置hostname1$ hostnamectl set-hostname docker1.nd.com 修改host文件修改/etc/hosts文件为如下内容123456192.168.32.131 docker1.nd.com192.168.32.132 docker2.nd.com192.168.32.133 docker3.nd.com192.168.32.134 docker4.nd.com192.168.32.135 docker5.nd.com192.168.32.136 docker6.nd.com 使用scp命令复制到其他5台服务器1$ scp /etc/hosts root@docker2.nd.com:/etc/hosts 安装mesos、zookeeper包 1、分别在6台服务器上执行如下命令12$ rpm -Uvh http://repos.mesosphere.io/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm$ rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-mesosphere 2、进入3台master服务器安装mesos、marathon和zookeeper1$ yum install mesos marathon mesosphere-zookeeper -y 3、进入3台slave服务器安装mesos1$ yum install mesos -y 配置mesos、zookeeper配置zookeeper1、修改/var/lib/zookeeper/myid文件，三台master服务器，分别设置为1、2、32、修改/etc/zookeeper/conf/zoo.cfg文件，在文件末尾添加以下配置123server.1=192.168.32.131:2888:3888server.2=192.168.32.132:2888:3888server.3=192.168.32.133:2888:3888 3、启动zookeeper服务1$ systemctl start zookeeper 4、查看zookeeper服务是否已启动 1$ systemctl is-active zookeeper 配置mesos-master1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容1zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos 2、设置/etc/mesos-master/quorum文件中quorum的值，这个值要大于master数量的1/2，我们这里设置为23、停用mesos-slave1$ systemctl stop mesos-slave.service 1$ systemctl disable mesos-slave.service 4、启动mesos-master marathon12$ systemctl start mesos-master$ marathon --master zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos 正常情况下此时已经可以通过http://docker1.nd.com:5050打开mesos页面 配置mesos-slave1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容1zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos 2、停用mesos-master12$ systemctl stop mesos-master.service$ systemctl disable mesos-master.service 3、启动mesos-slave1$ systemctl start mesos-slave docker配置如需要在slave上运行docker，除docker自身安装配置外，还需要做如下设置1、指定使用docker容器化1$ echo &apos;docker,mesos&apos; &gt; /etc/mesos-slave/containerizers 2、考虑到拉取容器镜像等的操作，适当增加timeout的时间1$ echo &apos;5mins&apos; &gt; /etc/mesos-slave/executor_registration_timeout 3、重启mesos-slave以使上面配置生效1$ systemctl restart mesos-slave 注意事项在测试环境中我们可以关闭防火墙，但在生产环境中，为了安全考虑，还是需要将防火墙开启此时应注意，master需要向agent的所有ip开放5050端口，所有agent需要向master开放5051端口并且为了用户可以访问mesos的前端页面，master需向用户ip开放5050端口，所有agent也需要向用户ip开放5051端口，否则会出现agent信息无法查看，task日志无法查看等问题]]></content>
      <categories>
        <category>运维</category>
      </categories>
  </entry>
</search>
