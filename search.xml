<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[cglib动态代理解析]]></title>
    <url>%2F2018%2F05%2F02%2Fcglib-proxy%2F</url>
    <content type="text"><![CDATA[简单的例子代码目标类123456public class HelloService &#123; public void sayHello() &#123; System.out.println(&quot;=== hello ===&quot;); &#125;&#125; 拦截器类123456789101112131415import java.lang.reflect.Method;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;public class MyMethodInterceptor implements MethodInterceptor &#123; public Object intercept(Object obj, Method method, Object[] args,MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;=== before ===&quot;); Object object = proxy.invokeSuper(obj, args); System.out.println(&quot;=== after ===&quot;); return object; &#125;&#125; 代理类1234567891011import net.sf.cglib.proxy.Enhancer;public class MyProxy&lt;T&gt; &#123; public T getProxy(Class&lt;T&gt; tClass)&#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(tClass); enhancer.setCallback(new MyMethodInterceptor()); return (T) enhancer.create(); &#125;&#125; 测试类123456789public class Main &#123; public static void main(String[] args) throws Exception &#123; MyProxy&lt;HelloService&gt; myProxy = new MyProxy(); HelloService helloService = myProxy.getProxy(HelloService.class); helloService.sayHello(); &#125;&#125; 执行结果123=== before ====== hello ====== after === 解析不同于jdk动态代理，cglib采用了继承目标类的方式来实现动态代理，因此cglib无法代理final类型的方法，相比比jdk动态代理，产生代理类，需要接口Class对象以及实现类的实例而言，cglib所需要的“原材料”更少，只需要目标类的Class对象即可实现动态代理。 源码解析代码入口就在MyProxy类的enhancer.create()方法，很明显这个方法产生出来的就是目标类的子类，但我们的代码中并没有存在目标类的子类，cglib如何new出来？这里的原理与jdk动态代理类似，都是动态产生字节码技术，不过不同于jdk动态代理直接写二进制文件，cglib底层采用asm框架来产生字节码文件，效率上笔者认为是比jdk动态代理要慢一点，但这不是关键，因为一个代理类的产生，只会经过一次这个步骤，而后成千上万次的方法调用，才是效率的关键。 来看enhancer.create()的具体步骤，经过createHelper()–&gt;super.create(key)–&gt;data.get(this)–&gt;generatedClasses.get(gen)–&gt;createEntry(key, cacheKey, v)–&gt;loader.apply(key)–&gt;gen.generate(ClassLoaderData.this)–&gt;super.generate(data)–&gt;strategy.generate(this)–&gt;transform(cg).generateClass(cw)后到达产生二进制文件的核心Enhancer类的generateClass(ClassVisitor v)方法。 这个方法采用asm动态生成字节码文件，具体如何生成，笔者认为没有必要去看具体的逻辑过程，繁琐且没有营养，我们熟悉asm的话也可以写的出来。反而是这个方法，到底生成了什么东西，值得我们关注。 动态代理类源码我们可以将上一步中取到的byte数组，写入到文件，通过反编译工具查看源码，如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.lang.reflect.Method;import net.sf.cglib.core.ReflectUtils;import net.sf.cglib.proxy.Callback;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;//关键点，继承目标类public class HelloService$$EnhancerByCGLIB$$a89dc216 extends HelloService &#123; private boolean CGLIB$BOUND; private static ThreadLocal CGLIB$THREAD_CALLBACKS; private MethodInterceptor CGLIB$CALLBACK_0; private static MethodProxy CGLIB$sayHello$0$Proxy; private static Object[] CGLIB$emptyArgs; static &#123; try &#123; CGLIB$STATICHOOK2(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; static void CGLIB$STATICHOOK2() throws ClassNotFoundException &#123; CGLIB$THREAD_CALLBACKS = new ThreadLocal(); CGLIB$emptyArgs = new Object[0]; Class var0 = Class.forName(&quot;com.example.demo.java_demo.cglib.HelloService$$EnhancerByCGLIB$$a89dc216&quot;); Class var1; Method[] var10000 = ReflectUtils.findMethods(new String[]&#123;&quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;, &quot;hashCode&quot;, &quot;()I&quot;, &quot;clone&quot;, &quot;()Ljava/lang/Object;&quot;&#125;, (var1 = Class.forName(&quot;java.lang.Object&quot;)).getDeclaredMethods()); //关键代码，产生MethodProxy CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;); &#125; //拦截器类将会调用此方法 final void CGLIB$sayHello$0() &#123; super.sayHello(); &#125; //关键方法 public final void sayHello() &#123; MethodInterceptor var10000 = this.CGLIB$CALLBACK_0; if(this.CGLIB$CALLBACK_0 == null) &#123; CGLIB$BIND_CALLBACKS(this); var10000 = this.CGLIB$CALLBACK_0; &#125; if(var10000 != null) &#123; try &#123; //关键方法 var10000.intercept(this, null, CGLIB$emptyArgs, CGLIB$sayHello$0$Proxy); &#125; catch (Throwable throwable) &#123; throwable.printStackTrace(); &#125; &#125; else &#123; super.sayHello(); &#125; &#125; public HelloService$$EnhancerByCGLIB$$a89dc216() &#123; CGLIB$BIND_CALLBACKS(this); &#125; //通过这个方法注入拦截器类 public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123; CGLIB$THREAD_CALLBACKS.set(var0); &#125; //设置拦截器类 private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123; HelloService$$EnhancerByCGLIB$$a89dc216 var1 = (HelloService$$EnhancerByCGLIB$$a89dc216)var0; if(!var1.CGLIB$BOUND) &#123; var1.CGLIB$BOUND = true; Object var10000 = CGLIB$THREAD_CALLBACKS.get(); if(var10000 == null) &#123; return; &#125; var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0]; &#125; &#125;&#125; 这个源码已经做了大量的精简，但看上去仍然比jdk动态代理生成的动态代理类要复杂的多，有了这个动态代理类，我们就可以修改测试类中的代码为：12345678910111213import net.sf.cglib.proxy.Callback;public class Main &#123; public static void main(String[] args) throws Exception &#123; //设置拦截器 HelloService$$EnhancerByCGLIB$$a89dc216.CGLIB$SET_THREAD_CALLBACKS( new Callback[]&#123; new MyMethodInterceptor() &#125; ); //创建实例 HelloService helloService = new HelloService$$EnhancerByCGLIB$$a89dc216(); //调用方法 helloService.sayHello(); &#125;&#125; 先来看第一步设置拦截器，传入的拦截器将在稍后被设置到成员变量CGLIB$CALLBACK_0中，这个属性会在方法调用时发挥作用 123public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) &#123; CGLIB$THREAD_CALLBACKS.set(var0);&#125; 1234567891011private static final void CGLIB$BIND_CALLBACKS(Object var0) &#123; HelloService$$EnhancerByCGLIB$$a89dc216 var1 = (HelloService$$EnhancerByCGLIB$$a89dc216)var0; if(!var1.CGLIB$BOUND) &#123; var1.CGLIB$BOUND = true; Object var10000 = CGLIB$THREAD_CALLBACKS.get(); if(var10000 == null) &#123; return; &#125; var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0]; &#125; &#125; 第二步创建实例，这里有一行非常关键的代码：1CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;); 这个代码可以先忽略，等到方法执行时再看 第三步方法调用，即调用动态代理类的sayHello()方法，进而调用拦截器类的intercept方法，传入的4个参数分别为：1、动态代理类的对象本身 2、通过反射获得的method对象 3、方法参数 4、方法代理对象（关键）1var10000.intercept(this, null, CGLIB$emptyArgs, CGLIB$sayHello$0$Proxy); 代码跳到拦截器类的intercept方法中123456public Object intercept(Object obj, Method method, Object[] args,MethodProxy proxy) throws Throwable &#123; System.out.println(&quot;=== before ===&quot;); Object object = proxy.invokeSuper(obj, args); System.out.println(&quot;=== after ===&quot;); return object;&#125; 在jdk动态代理中，也有类似的方法，但在jdk动态代理在执行目标方法时，是通过反射调用，我们知道反射调用比直接调用，效率上是要低的多，而cglib实现了自己的一套反射调用，查看MethodProxy类的init方法：12345678910private void init()&#123; CreateInfo ci = createInfo; FastClassInfo fci = new FastClassInfo(); fci.f1 = helper(ci, ci.c1); fci.f2 = helper(ci, ci.c2); fci.i1 = fci.f1.getIndex(sig1); fci.i2 = fci.f2.getIndex(sig2); fastClassInfo = fci; createInfo = null; &#125; 这里的c1，c2，sig1，sig2，即在动态代理类中传入的 1CGLIB$sayHello$0$Proxy = MethodProxy.create(var1, var0, &quot;()V&quot;, &quot;sayHello&quot;, &quot;CGLIB$sayHello$0&quot;); 这个方法会产生FastClassInfo对象，这个对象有4个属性，f1，f2，i1，i2，其中最主要的是f2和i2，将在稍后的调用中使用到，为了更清晰明了，我们先来看后面的代码：1return fci.f2.invoke(fci.i2, obj, args); 这行代码就是进行了代理类的方法调用，如果此时按F5进入方法，会发现代码跳到了刚刚的动态代理类的CGLIB$sayHello$0()方法，即123final void CGLIB$sayHello$0() &#123; super.sayHello(); &#125; 但f2的invoke方法，为何会调用到动态代理类的CGLIB$sayHello$0方法？这里就要看f2是如何产生的，回头看代码：1fci.f2 = helper(ci, ci.c2); helper()方法会产生一个FastClass对象，这个FastClass对象也是通过动态字节码技术产生的，产生流程跟产生动态代理类一致，通过反编译可以获得源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import com.example.demo.java_demo.cglib.HelloService..EnhancerByCGLIB..a89dc216;import java.lang.reflect.InvocationTargetException;import net.sf.cglib.core.Signature;import net.sf.cglib.proxy.Callback;import net.sf.cglib.reflect.FastClass;public class HelloService$$EnhancerByCGLIB$$a89dc216$$FastClassByCGLIB$$7d6c4fc4 extends FastClass &#123; public HelloService$$EnhancerByCGLIB$$a89dc216$$FastClassByCGLIB$$7d6c4fc4(Class var1) &#123; super(var1); &#125; public int getIndex(Signature var1) &#123; String var10000 = var1.toString(); switch(var10000.hashCode()) &#123; case -2055565910: if(var10000.equals(&quot;CGLIB$SET_THREAD_CALLBACKS([Lnet/sf/cglib/proxy/Callback;)V&quot;)) &#123; return 1; &#125; break; case -1457505897: if(var10000.equals(&quot;CGLIB$STATICHOOK2()V&quot;)) &#123; return 2; &#125; break; case 291273791: if(var10000.equals(&quot;CGLIB$sayHello$0()V&quot;)) &#123; return 3; &#125; break; case 1535311470: if(var10000.equals(&quot;sayHello()V&quot;)) &#123; return 0; &#125; break; &#125; return -1; &#125; public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException &#123; a89dc216 var10000 = (a89dc216)var2; int var10001 = var1; try &#123; switch(var10001) &#123; case 0: var10000.sayHello(); return null; case 1: a89dc216.CGLIB$SET_THREAD_CALLBACKS((Callback[])var3[0]); return null; case 2: a89dc216.CGLIB$STATICHOOK2(); return null; case 3: var10000.CGLIB$sayHello$0(); return null; &#125; &#125; catch (Throwable var4) &#123; throw new InvocationTargetException(var4); &#125; throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;); &#125;&#125; 代码同样做了精简，到这里流程差不多已经走完了，在进行f2的invoke调用时，会传入i1，i1即是通过f2的getinde方法获得的，这里的值为3，在进行invoker调用时，可以看到最终调用的是动态代理类的CGLIB$sayHello$0()方法，CGLIB$sayHello$0()方法的方法体在刚刚已经展示过，就一行代码:123final void CGLIB$sayHello$0() &#123; super.sayHello(); &#125; 至此，完成了cglib动态调用的过程完！]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jdk动态代理解析]]></title>
    <url>%2F2018%2F04%2F28%2Fjdk-proxy%2F</url>
    <content type="text"><![CDATA[简单的例子代码接口类123public interface HelloService &#123; void sayHello();&#125; 实现类123456public class HelloServiceImpl implements HelloService &#123; public void sayHello() &#123; System.out.println(&quot;hello&quot;); &#125;&#125; 代理类1234567891011121314151617181920212223242526272829import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class MyProxy &lt;T&gt;&#123; private Object target; private Class interfaceClass; public MyProxy(Object target,Class interfaceClass) &#123; super(); this.target = target; this.interfaceClass = interfaceClass; &#125; public T getProxy() &#123; return (T)Proxy.newProxyInstance(interfaceClass.getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;=== begin ===&quot;); Object result = method.invoke(target,args); System.out.println(&quot;=== end ===&quot;); return result; &#125; &#125;); &#125;&#125; 测试类123456789101112public class Main &#123; public static void main(String[] args) throws Throwable &#123; new Main().testProxy(); &#125; public void testProxy() throws Throwable &#123; HelloService userService = new HelloServiceImpl(); MyProxy&lt;HelloService&gt; myProxy = new MyProxy(userService,HelloService.class); HelloService proxy = myProxy.getProxy(); proxy.sayHello(); &#125;&#125; 运行结果123=== begin ===hello=== end === 解析关键代码在讲核心代码前先插播一个内容：ClassLoader，可以看到在匿名内部类中，有个interfaceClass.getClassLoader()的操作，interfaceClass是个Class对象，在new MyProxy是传入，唯一的作用就是获得这个对象的ClassLoader，这是由于ClassLoader的机制导致的，由不同ClassLoader加载的类，即便已经实现了目标接口的方法，也不会被认为是这个目标接口的子类，因此需要用同一个ClassLoader，才能使最终生成的代理对象，能够被强制转换成接口对象，更详细的内容请参考双亲委派模型。 接下来开始讲核心代码：1Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 这行代码将会产生一个代理类，这个类实现了HelloService的所有方法，在方法体重，调用第三个参数h，这个h即为我们上面代码中的匿名内部类123456789new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;=== begin ===&quot;); Object result = method.invoke(target,args); System.out.println(&quot;=== end ===&quot;); return result; &#125;&#125; 源码解析先来看newProxyInstance()这个方法，以下源码摘自jdk1.8，源码做了大量精简，仅保留核心代码。123456789public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)throws IllegalArgumentException &#123; //获取代理类的Class对象 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); //获取代理类的构造方法 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); //生成实例 return cons.newInstance(new Object[]&#123;h&#125;); &#125; getProxyClass0()方法也就是动态代理核心，经过各种缓存机制判断后，我们可以找到真正干活的那个方法，即ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags)，这个方法中，又调用了ProxyGenerator类的generateClassFile()方法，这个方法就是产生Class二进制文件的地方： 1234567891011121314151617181920212223private byte[] generateClassFile() &#123; this.addProxyMethod(hashCodeMethod, Object.class); this.addProxyMethod(equalsMethod, Object.class); this.addProxyMethod(toStringMethod, Object.class); //...省略代码 ByteArrayOutputStream var13 = new ByteArrayOutputStream(); DataOutputStream var14 = new DataOutputStream(var13); try &#123; var14.writeInt(-889275714); var14.writeShort(0); var14.writeShort(49); this.cp.write(var14); var14.writeShort(this.accessFlags); var14.writeShort(this.cp.getClass(dotToSlash(this.className))); var14.writeShort(this.cp.getClass(&quot;java/lang/reflect/Proxy&quot;)); var14.writeShort(this.interfaces.length); //...省略代码 return var13.toByteArray(); &#125; catch (IOException var9) &#123; throw new InternalError(&quot;unexpected I/O Exception&quot;, var9); &#125; &#125; 这个方法充斥着大量的逻辑性代码，没有什么值得看的地方，倒是这种生成Class二进制文件的方式是个亮点，笔者在看dubbo源码时，dubbo也会产生类似的动态代理类，但dubbo的方式是先生成java代码，就是 public class XXX这样，然后通过javassist变成Class文件，但jdk动态代理直接省去了生成java代码这一步，直接写二进制文件，显然这能提高效率，这里可以作为面试的一个点。 顺便介绍下Class文件的结构，java的Class文件是严格按照顺序来书写，各个属性之间没有间隔（如之类称之为间隔），通过预定义好的顺序写入和读取Class文件，以保证能够正确的读写，从上面的代码也能看出来 第一行：writeInt(-889275714) -889275714转成十六进制即为CAFEBABY，熟悉Class文件结构的同学都知道这是Java Class文件的标记，任何Class文件都是以这个开头。 第二行：writeShort(0)，即两个字节的0，转为十六进制是00 00，这两个字节目前没有意义，是Class文件中罕见的没有意义的字符 第三行：writeShort(49)，49是jdk的版本，即jdk1.5，即生成的Class文件，能被jdk1.5以上的虚拟机运行 第四行：cp.write(var14)，写入常量池，常量池包括字面量和符号引用，字面量即文本字符串，声明为final的常量，符号引用即类和接口的全限定名，方法、字段的名称和描述符等，在上面的逻辑步骤中已经解析出了所有需要的常量池 第五行：writeShort(this.accessFlags);accessFlags即类的访问标志，这里的值是17，十六进制为11，查表可知这代表 final 和 public两种访问标志。 第六行：常量池写完，后面的所有操作都是写常量池中的编号，而不会再写入具体的名称 Class文件的结构严谨而复杂，有兴趣的同学可以阅读周志明编写的深入理解java虚拟机这一书 我们可以手动调用ProxyGenerator.generateProxyClass(“$Proxy0”, HelloServiceImpl.class.getInterfaces())这个方法，得到二进制数据，将它写入磁盘，然后用反编译工具看下到底写了什么代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package com.sun.proxy;import com.example.demo.java_demo.jdk_proxy.HelloService;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements HelloService&#123; private static Method m1; private static Method m3; private static Method m2; private static Method m0; public $Proxy0(InvocationHandler paramInvocationHandler) throws &#123; super(paramInvocationHandler); &#125; public final boolean equals(Object paramObject) throws &#123; try &#123; return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final void sayHello() throws &#123; try &#123; this.h.invoke(this, m3, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)this.h.invoke(this, m2, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)this.h.invoke(this, m0, null)).intValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; static &#123; try &#123; m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;); m3 = Class.forName(&quot;com.example.demo.java_demo.jdk_proxy.HelloService&quot;).getMethod(&quot;sayHello&quot;, new Class[0]); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 关键的sayHello方法，其实也是调用了this.h.invoke(this, m2, null);这个h，即我们上面写的那个匿名内部类。 完！]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[java内存结构与垃圾回收]]></title>
    <url>%2F2018%2F02%2F24%2Fjvm%2F</url>
    <content type="text"><![CDATA[内存结构堆内存（线程共享）新生代新创建的对象放入新生代，由于新生代的对象，大部分是朝生夕死，为了更好的垃圾回收，大多数垃圾收集器都采用复制算法，但由于最初的复制算法，将内存一分为二，浪费了50%的内存，因此后来将新生代内存划分为1块Eden区域和两块Survivor区域，默认的比例为8：1：1 Eden新创建的对象优先放入Eden区域 SuviderSurvivor区域有两块，进行一次垃圾回收后，Eden中存活的对象，被复制到Survivor区域中 老年代长期存活的对象放入老年代 方法区（线程共享）用于存储已被加载的类信息，常量，静态变量，即使编译器编译后的代码数据等 虚拟机栈（线程独享）每个方法执行时，都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，栈帧伴随着方法的执行而入栈，随着方法的结束而出栈 本地方法栈（线程独享）功能类似于虚拟机栈，只是这部分内存由native方法使用 程序计数器（线程独享）用于记录方法执行的行号，如果执行native方法，则无法记录行号，这是内存中唯一一块不会出现OOM的区域 如何判断对象为垃圾对象引用计数法添加一个引用计数器，当对象被引用时+1，解除引用时-1，当值为0时，即为垃圾对象，但由于这种算法，无法回收相互引用的对象，因此很少jvm采用这种算法 可达性分析法从GCRoot向下搜索，所走过的路径，称之为引用链，都为有用的对象，否则即为垃圾对象 可作为GCroot的节点：全局性的引用（常量或静态类的引用）与执行上下文（栈帧中的本地变量表） 如何回收回收策略标记-清除算法当对象被确认为垃圾对象之后，就会被标记为垃圾对象，标记的位置，在对象的header中，标记清除算法的两个缺点：1、效率不高 2、空间问题，不连续，后续创建大对象时寻址困难 复制算法将堆内存分为两块区域，当创建对象时，仅仅使用其中一块区域，当进行垃圾回收时，不再是清除那些被标记为垃圾的对象，而是将没有被标记为垃圾的对象，复制到另一块内存区域，然后将原来那块区域清空，这样很好的解决了标记-清除算法的空间问题，但同时引入了一个新问题，就是内存的浪费，将一块内存分为相等的两块内存，意味着浪费了50%的空间，为此，IBM公司的一个专项研究表明，新生代内存中，98%的对象都是朝生夕死，因此不需要按照1：1来分配内存，而是将内存划分为1块较大的Eden空间和两块较小的Survivor空间，具体的比例为8：1：1，在垃圾回收时，Eden区域和其中一块Surivor区域中还存活的对象，一次性被复制到另一块Surivivor空间上，然后清理掉Eden和刚刚那块Surivivor空间，如果遇到大对象，Surivivor空间不够放时，将进行空间分配担保，将对象放入老年代 标记-整理算法复制算法更适合新生代，但对于老年代，对象存活率比较高，无法采用复制算法，因此有人想出标记-整理算法，整个过程也分为两步，标记和整理，标记过程与标记清楚算法无异，但是标记完成后并没有马上清除，而是将所有存活的对象向内存的其中一端移动，然后再清理掉另一端的内存 分代收集算法当前主流的垃圾收集器都采用此算法，但这种算法并没有特别的思想，只是针对不同的区域，进行不同的算法，比如新生代采用复制算法，老年代采用标记-清除或标记-整理算法 垃圾收集器Serial最早的垃圾收集器，使用单线程收集垃圾，收集效率低下，无法利用多核Cpu的资源，但是现在Client模式的jvm，仍然默认使用这个收集器。 Parnew是Serial的多线程版本，能充分利用多核cpu的资源，另一个重要的原因是能与CMS收集器配合使用 Cms并发标记清除垃圾收集器，能使GC产生的停顿时间减小到最小，除了枚举根节点，会产生GC停顿之外，其他的都能并发执行 G1是当今收集器最前沿的成果之一 垃圾回收回收过程分析打印垃圾回收报告1VM参数： -XX:+PrintGCDetails -verbose:gc -XX:+UseSerialGC GC日志分析1[GC (Allocation Failure) [DefNew: 69085K-&gt;8704K(78656K), 0.0203408 secs] 69085K-&gt;64309K(253440K), 0.0203707 secs] [Times: user=0.02 sys=0.02, real=0.02 secs] DefNew新生代区域名称，由垃圾收集器指定，如使用Serial收集器时，新生代的名字叫DefNew，采用Parallel收集器时，新生代的名称为PSYoungGen 69085K-&gt;8704K(78656K)69085K代表本区域GC前的内存大小，8704K代表本区域GC后的内存大小，(78656K)代表本区域总内存大小 69085K-&gt;64309K(253440K)69085K代表堆内存GC前的内存大小，64309K代表堆内存GC后的内存大小，(253440K)代表堆内存的总大小 GC停顿在枚举根节点时，不能出现对象的引用关系还在不断发生变化的情况，因此造成GC进行时，必须停止所有的线程，Sun将这件事称之为“Stop The World”，即使在号称几乎不会发生停顿的CMS（并发标记收集）收集器中，枚举根节点时也必须要停顿 内存的创建内存分配策略优先分配到edenEden区域新生代中的一块区域，也是垃圾收集器最常光顾的地方，新创建对象默认放置这个区域。 大对象直接分配到老年代由于在Eden区域中，一般使用复制算法进行垃圾清理，并且次数非常频繁，大对象在频繁但复制过程中性能低下，因此放到老年代中，gc次数相对较少，并且也并不使用复制算法，以提高性能。大对象的标准会根据内存环境自动计算得出，也可以使用-XX:PretenureSizeThreshold=10M,指定大于10Mb的对象叫大对象。 长期存活到对象分配到老年代每一次的垃圾回收之后，都会给对象的年龄+1，当年龄达到某个值当时候，即称之为长期存活，进入老年代。我们可以使用-XX:MaxTenuringThreshshold=10,指定age达到10的时候进入老年代，默认值为15 空间分配担保动态对象年龄判断并非所有对象都需要到达MaxTenuringThreshshold指定的分代年龄之后才会进入老年代，但Survivor区域中，所有相同年龄的对象内存总和，大于Survivor的一半，即会进入老年代，不受MaxTenuringThreshshold的限制 逃逸分析与栈上分配当对象仅在方法体内部使用时，由于方法当调用会创建栈帧，当调用结束就会出栈，因此将仅供该方法使用的对象，放在栈内存中，随着方法的出入栈而出入栈，而不用垃圾回收机制进行干预，可大大提高性能 虚拟机工具jps是一个命令行工具，全称是java process status，常用的命令如下： jps -l 可以显示java进程执行的主类 jps -m 可以显示程序执行所接收的参数，即main方法中的args参数 jps -v 可以显示虚拟机执行所接收的参数，如-Xms8m 常用参数-Xmx最大堆容量 -Xms最小堆容量 -Xss栈内存大小，注意是单个线程的栈内存大小 -Xmn新生代内存大小 -XX:SurvivorRatio=8新生代中，Eden区域与其中一个Surivivor区的大小比例是8：1 -XX:PertenureSizeThreshold大对象的定义，超过这个值的称之为大对象，直接放入老年代，避免在新生代中来回复制造成性能问题 -XX:MaxTenuringThreshold对象分代年龄分界线，超过这个值进入老年代，默认为15 -XX:MaxPermSize最大方法区(非堆)容量 -XX:MaxDirectMemorySize最大直接内存，如果不指定，默认与最大堆内存一致 -XX:+PrintGCDetail打印GC日志 -XX:+PrintTenuringDistribution打印对象分代年龄 HeapDumpOnOutOfMemoryError当内存溢出时打印堆栈信息]]></content>
      <categories>
        <category>jvm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos7搭建saltstack]]></title>
    <url>%2F2018%2F02%2F07%2Fsalt-install%2F</url>
    <content type="text"><![CDATA[Salt，一种全新的基础设施管理方式，部署轻松，在几分钟内可运行起来，扩展性好，很容易管理上万台服务器，速度够快，服务器之间秒级通讯。 salt底层采用动态的连接总线, 使其可以用于编配, 远程执行, 配置管理等等. 本次搭建使用centos7.1，共搭建1台master，2台minion，ip分配如下： 服务器ip hostname 说明 192.168.32.140 salt-master master 192.168.32.141 salt-minion1 minion 192.168.32.142 salt-minion2 minion 服务器基础设置关闭防火墙12$ systemctl stop firewalld$ systemctl disable firewalld 关闭selinux12$ setenforce 0$ vi /etc/selinux/config 将第6行修改为SELINUX=permissive1234567891011# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=permissive# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected.# mls - Multi Level Security protection.SELINUXTYPE=targeted 设置hostname1$ hostnamectl set-hostname salt-master 修改host文件修改/etc/hosts文件为如下内容123192.168.32.140 salt-master192.168.32.141 salt-minion1192.168.32.142 salt-minion2 使用scp命令复制到其他2台服务器1$ scp /etc/hosts root@salt-minion1:/etc/hosts 环境准备，依赖解决分别为三台机器添加阿里云epel源123$ mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup$ mv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup$ wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo 解决依赖关系，不然会报python依赖错误 1234$ yum clean expire-cache$ yum upgrade$ yum -y install epel-release$ yum install zeromq3 m2crypto python-crypto python-jinja2 python-msgpack python-yaml python-zmq -y 开始安装salt-master安装1$ yum install -y salt-master salt-minion安装1$ yum install -y salt-minion 配置&amp;启动master配置1$ vim /etc/salt/master 修改如下：123456789#master消息发布端口 Default: 4505publish_port: 4505#工作线程数，应答和接受minion Default: 5worker_threads: 100#客户端与服务端通信的端口 Default: 4506ret_port: 4506#自动接受所有客户端auto_accept: True#启动salt-master 启动：1$ systemctl start salt-master minion配置1$ vim /etc/salt/minion 修改如下： 123456# master IP或域名master: salt-master# 客户端与服务端通信的端口。 Default: 4506master_port: 4506# id minion的唯一标示。Default: hostnameid: salt-minion1 启动：1$ systemctl start salt-minion 测试查看master的key列表1234567[root@localhost ~]# salt-key -LAccepted Keys:（接受的key）salt-minion1salt-minion2Denied Keys:（否认的key）Unaccepted Keys:（未接受的key）Rejected Keys:（拒绝的key） salt-key常用参数说明：1234567-L 列出当前所有认证，包括Accepted Keys、Denied Keys、Unaccepted Keys、Rejected Keys-a 添加某个或某些个未接受(Unaccepted Keys)认证-A 添加所有未接受(Unaccepted Keys)认证-d 删除某个或某些个已接受(Accepted Keys)认证-D 删除所有已接受(Accepted Keys)认证-y 使用该参数可免去证书操作的交互，除非对minion端很信任，一般不建议使用-h 帮助 test.ping12345$ salt &apos;*&apos; test.pingsalt-minion1:Truesalt-minion2:True]]></content>
      <categories>
        <category>运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos7搭建mesos集群]]></title>
    <url>%2F2018%2F01%2F09%2Fmesos-install%2F</url>
    <content type="text"><![CDATA[Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。 本次搭建使用centos7.1，共搭建3台master，3台slave，ip分配如下： 服务器ip hostname 说明 192.168.32.131 docker1.nd.com master 192.168.32.132 docker2.nd.com master 192.168.32.133 docker3.nd.com master 192.168.32.134 docker4.nd.com slave 192.168.32.135 docker5.nd.com slave 192.168.32.136 docker6.nd.com slave 服务器基础设置关闭防火墙12$ systemctl stop firewalld$ systemctl disable firewalld 关闭selinux12$ setenforce 0$ vi /etc/selinux/config 将第6行修改为SELINUX=permissive1234567891011# This file controls the state of SELinux on the system.# SELINUX= can take one of these three values:# enforcing - SELinux security policy is enforced.# permissive - SELinux prints warnings instead of enforcing.# disabled - No SELinux policy is loaded.SELINUX=permissive# SELINUXTYPE= can take one of three two values:# targeted - Targeted processes are protected,# minimum - Modification of targeted policy. Only selected processes are protected.# mls - Multi Level Security protection.SELINUXTYPE=targeted 设置hostname1$ hostnamectl set-hostname docker1.nd.com 修改host文件修改/etc/hosts文件为如下内容123456192.168.32.131 docker1.nd.com192.168.32.132 docker2.nd.com192.168.32.133 docker3.nd.com192.168.32.134 docker4.nd.com192.168.32.135 docker5.nd.com192.168.32.136 docker6.nd.com 使用scp命令复制到其他5台服务器1$ scp /etc/hosts root@docker2.nd.com:/etc/hosts 安装mesos、zookeeper包 1、分别在6台服务器上执行如下命令12$ rpm -Uvh http://repos.mesosphere.io/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm$ rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-mesosphere 2、进入3台master服务器安装mesos、marathon和zookeeper1$ yum install mesos marathon mesosphere-zookeeper -y 3、进入3台slave服务器安装mesos1$ yum install mesos -y 配置mesos、zookeeper配置zookeeper1、修改/var/lib/zookeeper/myid文件，三台master服务器，分别设置为1、2、32、修改/etc/zookeeper/conf/zoo.cfg文件，在文件末尾添加以下配置123server.1=192.168.32.131:2888:3888server.2=192.168.32.132:2888:3888server.3=192.168.32.133:2888:3888 3、启动zookeeper服务1$ systemctl start zookeeper 4、查看zookeeper服务是否已启动 1$ systemctl is-active zookeeper 配置mesos-master1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容1zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos 2、设置/etc/mesos-master/quorum文件中quorum的值，这个值要大于master数量的1/2，我们这里设置为23、停用mesos-slave1$ systemctl stop mesos-slave.service 1$ systemctl disable mesos-slave.service 4、启动mesos-master marathon12$ systemctl start mesos-master$ marathon --master zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos 正常情况下此时已经可以通过http://docker1.nd.com:5050打开mesos页面 配置mesos-slave1、在/etc/mesos 和 /etc/marathon/conf目录下，新建文件：zk，添加如下内容1zk://192.168.32.131:2181,192.168.32.132:2181,192.168.32.133:2181/mesos 2、停用mesos-master12$ systemctl stop mesos-master.service$ systemctl disable mesos-master.service 3、启动mesos-slave1$ systemctl start mesos-slave docker配置如需要在slave上运行docker，除docker自身安装配置外，还需要做如下设置1、指定使用docker容器化1$ echo &apos;docker,mesos&apos; &gt; /etc/mesos-slave/containerizers 2、考虑到拉取容器镜像等的操作，适当增加timeout的时间1$ echo &apos;5mins&apos; &gt; /etc/mesos-slave/executor_registration_timeout 3、重启mesos-slave以使上面配置生效1$ systemctl restart mesos-slave 注意事项在测试环境中我们可以关闭防火墙，但在生产环境中，为了安全考虑，还是需要将防火墙开启此时应注意，master需要向agent的所有ip开放5050端口，所有agent需要向master开放5051端口并且为了用户可以访问mesos的前端页面，master需向用户ip开放5050端口，所有agent也需要向用户ip开放5051端口，否则会出现agent信息无法查看，task日志无法查看等问题]]></content>
      <categories>
        <category>运维</category>
      </categories>
  </entry>
</search>
